grammar de.upb.llvm_parser.LLVM with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore"
generate llvm "http://www.upb.de/llvm_parser/llvm"

LLVM:
	elements+=AbstractElement*;

NUMBER returns EBigDecimal:
	'-'? INT ('.' INT)?;

terminal VALID_ID:
			('%' | '@')  (('a'..'z' | 'A'..'Z' | '_' | '.' | '0'..'9')+  | STRING)
;

terminal INT_TYPE:
	'i' ('0'..'9')+ POINTER?;
	
terminal BOOL:
	'true' | 'false'
;	
		
terminal FLOATING_POINT_TYPE:
	'half' | 'float' | 'double' | 'x86_fp80' | 'fp128' | 'ppc_fp128';
	

terminal STRING:
	'c'?'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '0' | '"' | "'" | '\\') | !('\\' | '"'))* '"' |
	'c'?"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '0' | '"' | "'" | '\\') | !('\\' | "'"))* "'";

terminal UNKNOWN_TYPE:
	'(...)' POINTER?;

terminal SL_COMMENT:
	';' !('\n' | '\r')* ('\r'? '\n')?;

terminal POINTER:
	'*'+;
	
terminal METADATA:
	'!'('a'..'z' | 'A'..'Z' | '_' | '0'..'9')+ 
	| '!"' -> '"'
;
	
//Key Words

CALLING_CONV:
	'ccc' | 'fastcc' | 'coldcc' | 'x86_stdcallcc' | 'x86_fastcallcc' | 'x86_thiscallcc' 
	| 'arm_apcscc' | 'arm_aapcscc' | 'arm_aapcs_vfpcc' | 'msp430_intrcc' | 'ptx_kernel' 
	| 'ptx_device' | 'spir_func' | 'spir_kernel' | 'cc' '<' NUMBER '>' NUMBER;

FUNCTION_ATTRIBUTES:
	'address_safety' | 'alignstack' '(' '<' NUMBER '>' ')' | 'alwaysinline' | 'nonlazybind' 
	| 'inlinehint' | 'naked' | 'noimplicitfloat' | 'noinline' | 'noredzone' | 'noreturn' 
	| 'nounwind' | 'optsize' | 'readnone' | 'readonly' | 'returns_twice' | 'ssp' | 'sspreq' | 'uwtable';

LABEL_ID:
	(INT_TYPE|ID|BOOL  | 'catch' | 'invoke' | 'resume' | 'switch' | 
	'xchg' | 'add' | 'sub' | 'and' | 'nand' | 'or' | 'xor' | 'max' | 'min' | 'umax' | 'umin'
	| 'default' | 'hidden' | 'protected'
	| 'external' | 'internal' | 'weak' | 'weak_odr'
	| 'oeq' | 'ogt' | 'oge' | 'olt' | 'ole' | 'one' | 'ord' 
	| 'ueq' | 'ugt' | 'uge' | 'ult' | 'ule' | 'une' | 'uno'
	| 'eq' | 'ne' | 'sgt' | 'sge' | 'slt' | 'sle'
	| 'unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst'
	| 'zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest'
	| 'trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' 
	| 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'	| 'bitcast'
	| 'private' | 'linker_private' | 'linker_private_weak' | 'available_externally' | 'linkonce' 
	| 'common' | 'appending' | 'extern_weak' | 'linkonce_odr' | 'linkonce_odr_auto_hide' | 'dllimport' | 'dllexport'
	| 'void' | 'null' | 'label' | 'undef')
	 
	('.' (INT_TYPE|ID|BOOL | 'catch' | 'invoke' | 'resume' | 'switch' | 
	'xchg' | 'add' | 'sub' | 'and' | 'nand' | 'or' | 'xor' | 'max' | 'min' | 'umax' | 'umin'
	| 'default' | 'hidden' | 'protected'
	| 'external' | 'internal' | 'weak' | 'weak_odr'
	| 'oeq' | 'ogt' | 'oge' | 'olt' | 'ole' | 'one' | 'ord' 
	| 'ueq' | 'ugt' | 'uge' | 'ult' | 'ule' | 'une' | 'uno'
	| 'eq' | 'ne' | 'sgt' | 'sge' | 'slt' | 'sle'
	| 'unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst'
	| 'zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest'
	| 'trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' 
	| 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'	| 'bitcast'
	| 'private' | 'linker_private' | 'linker_private_weak' | 'available_externally' | 'linkonce' 
	| 'common' | 'appending' | 'extern_weak' | 'linkonce_odr' | 'linkonce_odr_auto_hide' | 'dllimport' | 'dllexport'
	| 'void' | 'null' | 'label' | 'undef'))*;


AbstractElement:
	TopLevelEntity SL_COMMENT? |
	MainLevelEntity SL_COMMENT?;

TopLevelEntity:
	'module' 'asm' module=STRING |
	'target' ('datalayout' | 'triple') '=' target=STRING |
	'deplibs' '=' '[' libs+=STRING (',' libs+=STRING)* ']';

	/*
 * This rule is used to devide the Function Definitions form the Variable Definitions.
 */
MainLevelEntity:
	TypeDefinition
	| GlobalDefinition
	| FunctionDefinition
	| AliasDefinition
	| MetadataValue
	;

TypeDefinition:
	(address=Address '=' (('type' (struct=Structure | 'opaque'))));

GlobalDefinition:
	address=Address '=' ('private' | 'linker_private' | 'linker_private_weak' | 'available_externally' 
		| 'linkonce' | 'common' | 'appending' |	'extern_weak' | 'linkonce_odr' | 'linkonce_odr_auto_hide' 
		| 'dllimport' | 'dllexport' | 'external' | 'internal' | 'weak' | 'weak_odr' | 'global' | 'unnamed_addr' | 'constant')* 
	value=Parameter (',' 'align' align = NUMBER)?;

FunctionDefinition:
	('define' ('private' | 'linker_private' | 'linker_private_weak' | 'available_externally' 
		| 'linkonce' | 'common' | 'appending' |
		'extern_weak' | 'linkonce_odr' | 'linkonce_odr_auto_hide' | 'dllimport' | 'dllexport'
		| 'external' | 'internal' | 'weak' | 'weak_odr')? 
		('default' | 'hidden' | 'protected')? 
		CALLING_CONV? 
		('zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest')? 
		returnType=TypeUse
		address=Address ('()' | '(' parameter=FunctionParameterList? ')') 
		'unnamed_addr'? FUNCTION_ATTRIBUTES* ('section ' STRING)? ('align' align = NUMBER)?
	body=FunctionBody) 
	| 
	('declare' ('private' | 'linker_private' | 'linker_private_weak' | 'available_externally' 
		| 'linkonce' | 'common' | 'appending' |	'extern_weak' | 'linkonce_odr' | 'linkonce_odr_auto_hide' 
		| 'dllimport' | 'dllexport'| 'external' | 'internal' | 'weak' | 'weak_odr')? 
		('default' | 'hidden' | 'protected')? 
		CALLING_CONV? 
		('zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest')? 
		returnType=TypeUse
		address=Address ('()' | '(' parameter=FunctionParameterList? ')') 
		'unnamed_addr'? FUNCTION_ATTRIBUTES* ('section ' STRING)? ('align' align = NUMBER)?)
;

AliasDefinition:
	address=Address '=' 'alias' ('external' | 'internal' | 'weak' | 'weak_odr')? 
	('default' | 'hidden' | 'protected')? 
	aliastype=TypeUse aliasvalue=Value aliasee=(TypeUse);

TypeUse:
	(Predefined | AddressUse) functionInput=UNKNOWN_TYPE?	
;

AddressUse:
	address=[Address|VALID_ID] (pointer=POINTER)?
	;

Address:
	name=VALID_ID;

Predefined:
	type=('void' | 'null' | 'label' | 'undef' | '...' | INT_TYPE | FLOATING_POINT_TYPE) (pointer=POINTER)?
	;




Vector:
	'<' length=NUMBER 'x' type=TypeUse '>';

Array:
	{Array} ('[' length=NUMBER 'x' type=(TypeUse|Aggregate_Type) ']' | '[]' | '[' ']') POINTER?;

Aggregate_Type:
	Structure | Array | Vector;

Constant:
	value = NUMBER;
	
PrimitiveValue:
	value = (STRING | 'void' | 'null' | 'label' | 'undef' | '...' | BOOL | 'zeroinitializer');

Value:
	 NestedCast | NestedGetElementPtr | Constant | AddressUse | PrimitiveValue | ValueStruct;

ValueStruct:
	'{' values+=Parameter (',' values+=Parameter)* '}';

Structure:
	{Structure} '{' (types+=(TypeUse|Aggregate_Type) (',' types+=(TypeUse|Aggregate_Type))*)? '}' POINTER?;


Parameter:
	type = (TypeUse | Aggregate_Type) 
	(('zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest')+ value = Value 
		| value = Value? ('zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest')*
	)
;

ParameterList:
	{ParameterList}
	('()' | '('	((params+=Parameter (',' params+=Parameter)*)?) ')');

FunctionParameter:
	type = TypeUse 
	('zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest')* 
	(value = Address)?
;

FunctionParameterList:
	{FunctionParameterList} 
	params+=FunctionParameter (',' params+=FunctionParameter)* 
;


FunctionBody:
	meta+=MetadataValue*
	'{' blocks+=BasicBlock+ '}'
	;
Instruction:
	Store |  Load | GetElementPtr | Alloc | CmpXchg | AtomicRMW    
	| Fence | Return | Branch | Switch | IndirectBranch | Invoke | Resume | Unreachable 
	| LogicOperation | ArithmeticOperation | Compare 
	| Cast | ShuffleVector | InsertElement | ExtractElement | InsertValue | ExtractValue  
	| Phi | Select | Call | VariableAttributeAccess | LandingPad
;
BasicBlock:
	(label=LABEL_ID ':')
	(instructions+= Instruction)+
;


ArithmeticOperation:
	ArithmeticOperationAdd | ArithmeticOperationFadd | ArithmeticOperationSub | ArithmeticOperationFsub
	| ArithmeticOperationMul | ArithmeticOperationFmul | ArithmeticOperationUdiv | ArithmeticOperationSdiv
	| ArithmeticOperationFdiv | ArithmeticOperationUrem | ArithmeticOperationSrem | ArithmeticOperationFrem;
	
ArithmeticOperationAdd:		result=Address '=' operation = 'add' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationFadd:	result=Address '=' operation = 'fadd' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationSub:		result=Address '=' operation = 'sub' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationFsub:	result=Address '=' operation = 'fsub' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationMul:		result=Address '=' operation = 'mul' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationFmul:	result=Address '=' operation = 'fmul' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationUdiv:	result=Address '=' operation = 'udiv' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationSdiv:	result=Address '=' operation = 'sdiv' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationFdiv:	result=Address '=' operation = 'fdiv' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationUrem:	result=Address '=' operation = 'urem' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationSrem:	result=Address '=' operation = 'srem' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;
ArithmeticOperationFrem:	result=Address '=' operation = 'frem' 'nuw'? 'nsw'?	optype=TypeUse value1=Value ',' value2=Value;

LogicOperation:
	result=Address '=' operation = ('shl' | 'lshr' | 'ashr' | 'and' | 'or' | 'xor') optype=TypeUse value1=Value ',' value2=Value;

Cast:
	result=Address '=' 
	operation = ('trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' 
				| 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'	| 'bitcast') 
	from=(TypeUse|Aggregate_Type) value=Value 'to' to=TypeUse;

NestedCast: 
	operation = ('trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' 
				| 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'	| 'bitcast') 
	'(' from=(TypeUse|Aggregate_Type) value=Value 'to' to=TypeUse ')' 
;

MetaArgValue:
	arg=METADATA value=(METADATA|STRING)
;
Meta:
	'metadata' meta=(METADATA) | arg=Predefined? value=Value
;

MetadataValue:
	nodeId=METADATA	'=' 
	'metadata'? ('!' '{' | '!{')  values+=Meta (',' values+=Meta)* '}'
; 


GetElementPtr:
	result=Address '=' 'getelementptr' 'inbounds'? (aggregate=Parameter (',' indices +=Parameter)*)
;
NestedGetElementPtr:
	'getelementptr' 'inbounds'? ('(' aggregate=Parameter (',' indices +=Parameter)* ')')
;



Fence:
	'fence' 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');

CmpXchg:
	result=Address '=' 'cmpxchg' (volatile?='volatile')? address=Parameter ',' value=Parameter',' 
	newValue=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');

AtomicRMW:
	AtomicRmwXchg | AtomicRmwAdd | AtomicRmwSub | AtomicRmwAnd | AtomicRmwNand 
	| AtomicRmwOr | AtomicRmwXor | AtomicRmwMax | AtomicRmwMin | AtomicRmwUmax
	| AtomicRmwUmin
;

AtomicRmwXchg: 	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'xchg' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');
AtomicRmwAdd:  	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'add' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');
AtomicRmwSub:  	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'sub' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');
AtomicRmwAnd:  	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'and' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');
AtomicRmwNand: 	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'nand' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');
AtomicRmwOr:	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'or' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');
AtomicRmwXor:	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'xor' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');
AtomicRmwMax:	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'max' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');
AtomicRmwMin:	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'min' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');
AtomicRmwUmax:	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'umax' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');
AtomicRmwUmin:	result=Address '=' 'atomicrmw' (volatile?='volatile')? operation = 'umin' address=Parameter ',' argument=Parameter 'singlethread'? ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst');


Load:
	result=Address '=' ( volatile?='volatile' 'load'  | 'load' (volatile?='volatile')?) 
	address=Parameter (',' 'align' align = NUMBER)?  (',' meta+=MetaArgValue)* 
	|
	result=Address '=' 'load' atomic?='atomic' (volatile?='volatile'?)? address=Parameter 'singlethread'? 
	ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst') (',' 'align' align = NUMBER)?;

Store:
	(volatile?='volatile' 'store' | 'store' (volatile?='volatile')?) value=Parameter ',' 
	targetAddress=Parameter  (',' 'align' align = NUMBER)? (',' meta+=MetaArgValue)*     
	|
	'store' atomic?='atomic' (volatile?='volatile')? value=Parameter ',' targetAddress=Parameter 'singlethread'? 
	ordering=('unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst') (',' 'align' align = NUMBER)?;

//FIXME: no support for call of functions with a function as a result type
Call:
	(result=Address '=')? 'tail'? 'call' CALLING_CONV? 
	('zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest')? 
	function=Parameter //(('asm' 'sideeffect'? STRING ',' STRING) 
	pList=ParameterList FUNCTION_ATTRIBUTES* (',' '!srcloc' '!' NUMBER)*;

Alloc:
	result=Address '=' 'alloca' type=TypeUse (',' numOfElements=Parameter)? (',' 'align' align = NUMBER)?;

PhiCase:
	value= Value ',' label = VALID_ID
;

Phi:
	result=Address '=' 'phi' type=TypeUse '[' cases+=PhiCase ']' (',' '[' cases+=PhiCase ']')*;

LandingPad:
	result=Address '=' 'landingpad' struct=Structure 'personality' personalitytype=TypeUse
	personalityvalue=Value ('cleanup' clause+=Clause* | clause+=Clause+);

Clause:
	'catch' type=TypeUse value=Value 
	| 'filter' filterarray=Array (constant=Value);

Select:
	result=Address '=' 'select' condition=Parameter ',' trueValue=Parameter ',' elseValue=Parameter;

VariableAttributeAccess:
	result=Address '=' 'va_arg' vaList= Parameter',' aType=TypeUse;


//FIXME TODO

//...Value for structs and arrays 
ExtractValue:
	result=Address '=' 'extractvalue' aggerate=Parameter (',' index+=NUMBER)+;

InsertValue:
	result=Address '=' 'insertvalue' aggerate=Parameter',' value=Parameter (',' index+=NUMBER)+;

//...Element for vectors
ExtractElement:
	result=Address '=' 'extractelement'vector=Parameter ',' index=Parameter
;

InsertElement:
	result=Address '=' 'insertelement' vector=Parameter ',' value=Parameter ',' index=Parameter
;


ShuffleVector:
	result=Address '=' 'shufflevector' value1=Parameter ',' value2=Parameter ',' mask=Parameter;

Compare:
	CompareInt | CompareFloat;
	
CompareInt:
	result=Address '=' 'icmp' 
	cond = ('eq' | 'ne' | 'ugt' | 'uge' | 'ult' | 'ule' | 'sgt' | 'sge' | 'slt' | 'sle') 
	opType=TypeUse operand1=Value ',' operand2=Value;
CompareFloat:
	result=Address '=' 'fcmp' 
	cond = ('oeq' | 'ogt' | 'oge' | 'olt' | 'ole' | 'one' | 'ord' |
	'ueq' | 'ugt' | 'uge' | 'ult' | 'ule' | 'une' | 'uno')
	opType=TypeUse operand1=Value ',' operand2=Value;

IndirectBranch:
	'indirectbr' target=Parameter ',' '[' ('label' potTargetLabels+=VALID_ID (',' 'label' potTargetLabels+=VALID_ID)*)? ']';

Switch:
	'switch' caseValue=Parameter ',' 'label' defaultCase=VALID_ID '[' (cases+= SwitchCase)* ']';
	
SwitchCase:
	caseValue = Parameter ',' 'label' destination=VALID_ID
;

Invoke:
	'invoke' CALLING_CONV? 
	('zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest')? 
	returnType=TypeUse name=Address pList=ParameterList
	FUNCTION_ATTRIBUTES* 'to' 'label' targetLabel=VALID_ID 'unwind' 'label' unwindTargetLabel=VALID_ID;

Resume:
	'resume' type=Structure value=Value;

Unreachable:
	{Unreachable} 'unreachable';

Return:
	'ret' value=Parameter (',' '!dbg' '!' NUMBER)?
;

Branch:
	('br' 'label' destination=VALID_ID) | 
	('br' INT_TYPE condition=Value ',' 'label'	destination=VALID_ID	',' 'label' elseDestination=VALID_ID);

