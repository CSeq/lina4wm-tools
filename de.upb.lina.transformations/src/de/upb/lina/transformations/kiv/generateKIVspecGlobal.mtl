[comment encoding = UTF-8 /]
[module generateKIVspecGlobal('http://www.upb.de/lina/cfg/controlflow', 'http://www.upb.de/lina/cfg/gendata', 'http://www.upb.de/llvm_parser/llvm', 'http://www.eclipse.org/emf/2002/Ecore')]


[template public generateModel(genData : GeneratorData)]
[comment @main/]

[file ('specs/Proc.utf8', false, 'UTF-8')]
specification
	
	sorts Proc;

	variables p : Proc;

end specification
[/file]

[file ('specs/genProc.utf8', false, 'UTF-8')]
generic specification
	
	parameter Proc

	target

end generic specification
[/file]

[file ('specs/pset.utf8', false, 'UTF-8')]
actualize set-union with genProc by morphism

elem → Proc;
a → p;
b → p0;
c → p1;

end actualize
[/file]

[file ('specs/cindex.utf8', false, 'UTF-8')]
data specification
	IJ = [for (cfg : ControlFlowDiagram | genData.cfgs) separator ('|')] [generateCfgLabel(genData, cfg)/]ini [/for];
	CJ = [for (label : TransitionLabel | genData.transitionLabels->select(transition.instruction.oclIsUndefined()._or((transition.instruction.eClass() = Return)._not())))separator ('|')] [label.name/] [/for];
	[let returns : OrderedSet(TransitionLabel) = genData.transitionLabels->select(transition.instruction.oclIsUndefined()._not()._and(transition.instruction.eClass() = Return))]
	[if(returns->size() > 0)]
	RJ = [for (label : TransitionLabel | returns )separator ('|')] [label.name/]ret [/for];
[/if]
variables
		ij : IJ;
		cj : CJ;
[if(returns->size() > 0)]
		rj : RJ;
[/if]
end data specification[/let]
[/file]

[file ('specs/PC.utf8', false, 'UTF-8')]
data specification
	PC = N |[for (l : LocationLabel | genData.locationLabels) separator  (' |')] 
		
		[l.name/] [/for];
variables
pc : PC;

end data specification
[/file]

[file ('specs/CS.utf8', false, 'UTF-8')]
data specification
	using [basis(genData)/]ref, PC, pset
	CS := mkcs([for(am: AddressMapping | genData.getFilteredAddresses('globals'))]. .[am.name/] : [am.type/];
[/for]			. .pc : Proc → PC; . .lnext : Proc → nat; . .aux : set);
	variables
		cs, cs' : CS;
		pcf, pcf' : Proc → PC;
		lnf,lnf' : Proc → nat;
end data specification
[/file]

[file ('specs/COP.utf8', false, 'UTF-8')]
enrich 	CS,
		cindex with 

	functions
		;;INVOP : Proc × IJ → CS × CS → bool;
		COP : Proc × CJ → CS × CS → bool;
		;;RETOP : Proc × RJ → CS × CS × [if(genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->size()>0)][genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->first().type/][else][basis(genData)/][/if] → bool;

	predicates
		CSInit : CS;

	variables
		;;invop : CS × CS → bool;
		cop : CS × CS → bool;
		;;retop : CS × CS × [if(genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->size()>0)][genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->first().type/][else][basis(genData)/][/if] → bool;
		
	axioms
	CSInit : 
	⊦ CSInit(mkcs([for(am: AddressMapping | genData.getFilteredAddresses('globals'))][am.name/], [/for]pcf, lnf, s)) ↔ ([for(am: AddressMapping | genData.getFilteredAddresses('globals'))][am.name/] = 1 ∧[/for] pcf = (λ p. N) ∧ lnf = (λ p. 0) ∧ s = ∅);
	used for : s, ls;

[for (cfg : ControlFlowDiagram | genData.cfgs)] 
;; 	[generateCfgLabel(genData, cfg)/] reflects function [cfg.name/]
[/for]

	[for(label : TransitionLabel | genData.transitionLabels)]
;;	[label.transition.createComment()/]
	[label.name/] :
	COP(p, [label.name/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, label.transition)/] ∧ cs' = cs .pc:= cs.pc(p ; [genData.generateNextPC(genData, label.transition)/]);
	used for : s, ls;

	[/for]


[/file]

[/template]

[template private basis(genData : GeneratorData)]
[for(basis: String | genData.transformationSpecificKeys)][if (basis.equalsIgnoreCase('INT'))]int[/if][if (basis.equalsIgnoreCase('NAT'))]nat[/if][/for]
[/template]

[template private generateCfgLabel(genData : GeneratorData, cfg : ControlFlowDiagram)]
[for(mapping : OldToNewCfgNameMapping |genData.oldToNewCfgName)][if(mapping.key.equalsIgnoreCase(cfg.name))][mapping.value/][/if][/for]
[/template]

[template private generatePrevPC(genData: GeneratorData, transition: Transition)]
[for (label : LocationLabel | genData.locationLabels)][if(label.controlFlowLocation = transition.source)][label.name/][/if][/for]
[/template]

[template private generateNextPC(genData: GeneratorData, transition: Transition)]
[for (label : LocationLabel | genData.locationLabels)][if(label.controlFlowLocation = transition.target)][label.name/][/if][/for]
[/template]

[template private createComment(t : Transition)]
[let l : Load = t.instruction]
[l.result.name/] = load [l.address.displayParameter()/][if(l.align.oclIsUndefined()._not())], align [l.align/][/if][for(m : MetaArgValue | l.meta)], [m.arg/] [m.value/][/for][elselet s : Store = t.instruction]
store [s.value.displayParameter()/], [s.targetAddress.displayParameter()/][if(s.align.oclIsUndefined()._not())], align [s.align/][/if][for(m : MetaArgValue | s.meta)], [m.arg/] [m.value/][/for][elselet s : GetElementPtr = t.instruction]
[s.result.name/] = getelementptr [s.aggregate.displayParameter()/][for(index : Parameter | s.indices)], [index.displayParameter()/][/for][elselet s : Alloc = t.instruction]
[s.result.name/] = alloca [s.type.extractType()/][if(s.numOfElements.oclIsUndefined()._not())], [s.numOfElements.displayParameter()/][/if][if(s.align.oclIsUndefined()._not())], align [s.align/][/if][elselet s : CmpXchg = t.instruction]
[s.result.name/] = cmpxchg [if(s.volatile)]volatile [/if][s.address.displayParameter()/], [s.value.displayParameter()/], [s.newValue.displayParameter()/] [s.ordering/][elselet s : AtomicRMW = t.instruction]
[s.result.name/] = atomicrmw [if(s.volatile)]volatile [/if][s.operation/] [s.address.displayParameter()/], [s.argument.displayParameter()/] [s.ordering/][elselet s : Fence = t.instruction]
fence [s.ordering/][elselet s : Return = t.instruction]
ret [if(s.value.oclIsTypeOf(Parameter))][s.value.oclAsType(Parameter).displayParameter()/][else][s.value.oclAsType(PrimitiveValue).value/][/if][elselet s : Branch = t.instruction]
br [if(s.condition.oclIsUndefined()._not())][s.condition.extractValue()/], [/if]label [s.destination/][if(s.elseDestination.oclIsUndefined()._not())], label [s.elseDestination/][/if][elselet s : Switch = t.instruction]
switch [s.caseValue.displayParameter()/], label [s.defaultCase/] ['['/] [for(case : SwitchCase | s.cases)][case.caseValue.displayParameter()/], label [case.destination/] [/for][']'/][elselet s : IndirectBranch = t.instruction]
indirectbr [s.target.displayParameter()/], ['['/][for(target : EString | s.potTargetLabels)separator(', ')]label [target/][/for][']'/]
	NEEDS ATTENTION ![elselet s : Invoke = t.instruction]
invoke [s.returnType.extractType()/] [s.name.name/] ([if(s.pList.oclIsUndefined()._not())][for(param : Parameter | s.pList.params)separator(', ')][param.displayParameter()/][/for][/if]) to label [s.targetLabel/] unwind label [s.unwindTargetLabel/]
	NEEDS ATTENTION ![elselet s : Resume = t.instruction]
resume [s.type.extractType()/] [s.value.extractValue()/]
	NEEDS ATTENTION ![elselet s : LogicOperation = t.instruction]
[s.result.name/] = [s.operation/] [s.optype.extractType()/] [s.value1.extractValue()/], [s.value2.extractValue()/]
	NEEDS ATTENTION ![elselet s : ArithmeticOperation = t.instruction]
[s.result.name/] = [s.operation/] [s.optype.extractType()/] [s.value1.extractValue()/], [s.value2.extractValue()/][elselet s : Compare = t.instruction]
[s.result.name/] = [if(s.oclIsTypeOf(CompareInt))]icmp[else]fcmp[/if] [s.cond/] [s.opType.extractType()/] [s.operand1.extractValue()/], [s.operand2.extractValue()/][elselet s : Cast = t.instruction]
[s.result.name/] = [s.operation/] [s.from.extractType()/] [s.value.extractValue()/] to [s.to.extractType()/][elselet s : ShuffleVector = t.instruction]
[s.result.name/] = shufflevector [s.value1.displayParameter()/], [s.value2.displayParameter()/], [s.mask.displayParameter()/]
	NEEDS ATTENTION ![elselet s : InsertElement = t.instruction]
[s.result.name/] = insertelement [s.vector.displayParameter()/], [s.value.displayParameter()/], [s.index.displayParameter()/]
	NEEDS ATTENTION ![elselet s : ExtractElement = t.instruction]
[s.result.name/] = extractelement [s.vector.displayParameter()/], [s.index.displayParameter()/]
	NEEDS ATTENTION ![elselet s : InsertValue = t.instruction]
[s.result.name/] = insertvalue [s.aggerate.displayParameter()/], [s.value.displayParameter()/][for(i : EInt | s.index)separator(', ')][i/][/for]
	NEEDS ATTENTION ![elselet s : ExtractValue = t.instruction]
[s.result.name/] = extractvalue [s.aggerate.displayParameter()/][for(i : EInt | s.index)separator(', ')][i/][/for]
	NEEDS ATTENTION ![elselet s : Phi = t.instruction]
[s.result.name/] = phi [s.type.extractType()/] [for(case : PhiCase | s.cases)]['['/][case.value.extractType()/], [case.label/][']'/][/for][elselet s : Select = t.instruction]
[s.result.name/] = select [s.condition.displayParameter()/], [s.trueValue.displayParameter()/], [s.elseValue.displayParameter()/][elselet s : Call = t.instruction]
[if(s.result.oclIsUndefined()._not())][s.result.name/] = [/if]call [s.function.displayParameter()/] ([if(s.pList.oclIsUndefined()._not())][for(param : Parameter | s.pList.params)separator(', ')][param.displayParameter()/][/for][/if])
	NEEDS ATTENTION ![elselet s : VariableAttributeAccess = t.instruction]
[s.result.name/] = va_arg [s.vaList.displayParameter()/], [s.aType.extractType()/]
	NEEDS ATTENTION ![elselet s : LandingPad = t.instruction]
[s.result.name/] = landingpad [s.struct.extractType()/] personality [s.personalitytype.extractType()/] [s.personalityvalue.extractValue()/]
	NEEDS ATTENTION ![else]
[if(t.instruction.oclIsUndefined()._not())][t.instruction.eClass().name/]
	NEEDS ATTENTION ![else][t.eClass().name/][/if][/let]
[/template]

[template private displayParameter(param : Parameter)]
[param.type.extractType()/] [param.value.extractValue()/]
[/template]

[template public extractType(type : EObject)]
[let type : Predefined = type]
[type.type/][if(type.pointer.oclIsUndefined()._not())][type.pointer/][/if][elselet type : AddressUse = type]
[type.address.name/] [if(type.pointer.oclIsUndefined()._not())][type.pointer/][/if][elselet type : FunctionType = type]
[type.returnType.extractType()/]([if(type.parameter.oclIsUndefined()._not())][for(t : FunctionParameter | type.parameter.params)separator(', ')][t.type.extractType()/] [if(t.value.oclIsUndefined()._not())][t.value.name/][/if][/for][/if])[if(type.pointer.oclIsUndefined()._not())][type.pointer/][/if][elselet struct : Structure = type]
{[for(type : EObject | struct.types)separator(', ')][type.extractType()/][/for]}[if(struct.pointer.oclIsUndefined()._not())][struct.pointer/][/if][elselet type : Array = type]
['['/][if(type.length.oclIsUndefined()._not())][type.length/] x [extractType(type.type)/][/if][']'/][if(type.pointer.oclIsUndefined()._not())][type.pointer/][/if][elselet type : Vector = type]
<[type.length/] x [extractType(type.type.oclAsType(EObject))/]>;[/let]
[/template]

[template extractValue(v : Value)]
[let value : AddressUse = v]
[value.address.name/][elselet value : PrimitiveValue = v]
[value.value/][elselet value : IntegerConstant = v]
[value.value/][elselet value : NestedGetElementPtr = v]
getelementptr [value.aggregate.displayParameter()/][for(index : Parameter | value.indices)], [index.displayParameter()/][/for][elselet value : NestedCast = v]
[value.operation/]([value.from.extractType()/] [value.value.extractValue()/] to [value.to.extractType()/])[/let]
[/template]