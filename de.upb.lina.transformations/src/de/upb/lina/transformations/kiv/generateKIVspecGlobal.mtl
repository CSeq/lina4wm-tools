[comment encoding = UTF-8 /]
[module generateKIVspecGlobal('http://www.upb.de/lina/cfg/controlflow', 'http://www.upb.de/lina/cfg/gendata', 'http://www.upb.de/llvm_parser/llvm', 'http://www.eclipse.org/emf/2002/Ecore')]


[template public generateModel(genData : GeneratorData)]
[comment @main/]

[file ('specs/Proc.utf8', false, 'UTF-8')]
specification
	
	sorts Proc;

	variables p : Proc;

end specification
[/file]

[file ('specs/genProc.utf8', false, 'UTF-8')]
generic specification
	
	parameter Proc

	target

end generic specification
[/file]

[file ('specs/cindex.utf8', false, 'UTF-8')]
data specification
	IJ = [for (cfg : ControlFlowDiagram | genData.cfgs) separator ('|')] [generateCfgLabel(genData, cfg)/]ini [/for];
	CJ = [for (label : TransitionLabel | genData.transitionLabels->select(transition.instruction.oclIsUndefined()._or((transition.instruction.eClass() = Return)._not())))separator ('|')] [label.name/] [/for];
	[let returns : OrderedSet(TransitionLabel) = genData.transitionLabels->select(transition.instruction.oclIsUndefined()._not()._and(transition.instruction.eClass() = Return))]
	[if(returns->size() > 0)]
	RJ = [for (label : TransitionLabel | returns )separator ('|')] [label.name/]ret [/for];
[/if]
variables
		ij : IJ;
		cj : CJ;
[if(returns->size() > 0)]
		rj : RJ;
[/if]
end data specification[/let]
[/file]

[file ('specs/PC.utf8', false, 'UTF-8')]
data specification
	PC = N |[for (l : LocationLabel | genData.locationLabels) separator  (' |')] 
		
		[l.name/] [/for];
variables
pc : PC;

end data specification
[/file]

[if(input(genData))]
[file ('specs/input.utf8', false, 'UTF-8')]
data specification
	using [basis(genData)/]ref

	input =[for(inpList : InputTypeList | genData.inputTypes)separator('|')] mk[i/]([for(inputType : String | inpList.inputType->asSequence()->select(equalsIgnoreCase(basis(genData))))] . .[inputType/][i/]: [inputType/];[/for][for(inputType : String | inpList.inputType->asSequence()->select(equalsIgnoreCase('ref')))] . .[inputType/][i/]: [inputType/];[/for]) with [for(inputType : String | inpList.inputType->select(equalsIgnoreCase(genData.basis())))][inputType/][/for][for(inputType : String | inpList.inputType->select(equalsIgnoreCase('ref')))][inputType/][/for]? [/for];
	variables
		inp : input;
end data specification
[/file]
[/if]

[file ('specs/CS.utf8', false, 'UTF-8')]
data specification
	using [basis(genData)/]ref, PC, genProc, [basis(genData)/]ref-memory
	CS := mkcs([for(am: AddressMapping | genData.getFilteredAddresses('globals'))]
				. .[am.name/] : [am.type/];
[/for]				. .pc : Proc → PC;
				. .mem : memory;
[for(am: AddressMapping | genData.getFilteredAddresses('all-declare-params')->select(name.equalsIgnoreCase('returnvalue')._not()))]
				. .[am.name/] : Proc → [am.type/];
[/for]);
	variables
		cs, cs' : CS;
		pcf, pcf' : Proc → PC;
		[basis(genData)/]f,[basis(genData)/]f' : Proc → [basis(genData)/];
		reff, reff' : Proc → ref;
end data specification
[/file]

[file ('specs/COP.utf8', false, 'UTF-8')]
enrich 	CS,
		cindex[if(input(genData))],
		input[/if] with 

	functions
		INVOP : Proc × IJ → [if(input(genData))]input[else][inputType(genData)/][/if] × CS × CS → bool;
		COP : Proc × CJ → CS × CS → bool;
[let returns : OrderedSet(TransitionLabel) = genData.transitionLabels->select(transition.instruction.oclIsUndefined()._not()._and(transition.instruction.eClass() = Return))]
	[if(returns->size() > 0)]
		RETOP : Proc × RJ → CS × CS × [if(genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->size()>0)][genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->first().type/][else][basis(genData)/][/if] → bool;
[/if]
	predicates
		CSInit : CS;

	variables
		invop : [if(input(genData))]input[else][inputType(genData)/][/if] × CS × CS → bool;
		cop : CS × CS → bool;
[if(returns->size() > 0)]
		retop : CS × CS × [if(genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->size()>0)][genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->first().type/][else][basis(genData)/][/if] → bool;
[/if]		[for(am: AddressMapping | genData.getFilteredAddresses('globals'))]
		[am.name/], [am.name/]' : [am.type/];
		[/for]
		[if(input(genData)._not())]
		inp : [inputType(genData)/];
[/if][if(returns->size() > 0)]
		return : [if(genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->size()>0)][genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->first().type/][else][basis(genData)/][/if];
[/if][/let]
	axioms
	CSInit : 
	⊦ CSInit(mkcs([for(am: AddressMapping | genData.getFilteredAddresses('globals'))][am.name/], [/for]pcf, mem[for(am: AddressMapping | genData.getFilteredAddresses('all-declare-params')->select(name.equalsIgnoreCase('returnvalue')._not()))], [am.type/]f[i/][/for])) ↔ ([for(am: AddressMapping | genData.getFilteredAddresses('globals'))] [am.name/] = [if(am.type.equalsIgnoreCase('ref'))]⌜0⌝[else]0[/if] ∧[/for] pcf = (λ p. N) [for(am: AddressMapping | genData.getFilteredAddresses('all-declare-params')->select(name.equalsIgnoreCase('returnvalue')._not()))] ∧ [am.type/]f[i/] = (λ p. [if(am.type.equalsIgnoreCase('ref'))]⌜0⌝[else]0[/if])[/for]);
	used for : s, ls;

	[for (cfg : ControlFlowDiagram | genData.cfgs)] 
;; 	[generateCfgLabel(genData, cfg)/] reflects function [cfg.name/]
	[generateCfgLabel(genData, cfg)/]ini :
	⊦ INVOP(p, [generateCfgLabel(genData, cfg)/]ini)(inp, cs, cs') ↔ cs .pc(p) = N [if(input(genData))][let params : OrderedSet(AddressMapping) = genData.getFilteredAddresses('func-params:'+cfg.name)->select(name.equalsIgnoreCase('returnvalue')._not())][if(params->size()>0)]∧ [for(am : AddressMapping | params->select(type.equalsIgnoreCase(genData.basis())))][am.type/][/for][for(am : AddressMapping | params->select(type.equalsIgnoreCase('ref')))][am.type/][/for]?(inp) [/if][/let][/if]∧ cs' = cs .pc:= cs.pc(p ; [generateStartPC(genData, cfg)/]) [generateFunctionParameter(cfg, genData)/]; 
	used for : s, ls;

	[/for]
	[for (label : TransitionLabel | genData.transitionLabels->select(transition.instruction.oclIsUndefined()._or((transition.instruction.eClass() = Return)._not())))]
;;	[label.transition.createComment()/]
	[label.name/] :
	⊦ COP(p, [label.name/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, label.transition)/] ∧ [label.transition.transformTransition(genData)/];
	used for : s, ls;

	[/for]
	[for (label : TransitionLabel | genData.transitionLabels->select(transition.instruction.oclIsUndefined()._not()._and(transition.instruction.eClass() = Return)))]
;;	[label.transition.createComment()/]
	[label.name/]ret :
	⊦ RETOP(p, [label.name/]ret)(cs, cs', return) ↔ cs .pc(p) = [genData.generatePrevPC(genData, label.transition)/] ∧ cs' = cs .pc:= cs.pc(p ; N)[generateReturn(genData, label.transition.instruction.oclAsType(Return))/];
	used for : s, ls;
	
	[/for]
end enrich
[/file]

[/template]

[template private basis(genData : GeneratorData)]
[for(basis: String | genData.transformationSpecificKeys)][if (basis.equalsIgnoreCase('int'))]int[/if][if (basis.equalsIgnoreCase('nat'))]nat[/if][/for]
[/template]

[query private input(genData : GeneratorData) : Boolean = 
if genData.transformationSpecificKeys->indexOf('INPUT_NEEDED').oclIsUndefined() then false else true endif/]

[query private inputType(genData : GeneratorData) : String =
if genData.transformationSpecificKeys->indexOf('INPUT_REF').oclIsUndefined() then basis(genData) else 'ref' endif /]

[template private generateCfgLabel(genData : GeneratorData, cfg : ControlFlowDiagram)]
[for(mapping : OldToNewCfgNameMapping |genData.oldToNewCfgName)][if(mapping.key.equalsIgnoreCase(cfg.name))][mapping.value/][/if][/for]
[/template]

[template private generatePrevPC(genData: GeneratorData, transition: Transition)]
[for (label : LocationLabel | genData.locationLabels)][if(label.controlFlowLocation = transition.source)][label.name/][/if][/for]
[/template]

[template private generateNextPC(genData: GeneratorData, transition: Transition)]
[for (label : LocationLabel | genData.locationLabels)][if(label.controlFlowLocation = transition.target)][label.name/][/if][/for]
[/template]

[template private generateStartPC(genData : GeneratorData, cfg : ControlFlowDiagram)]
[for (l : ControlFlowLocation | cfg.locations)]
[if (l = cfg.start)][for (label : LocationLabel | genData.locationLabels)][if (l = label.controlFlowLocation)][label.name/][/if][/for][/if][/for]
[/template]

[template private generateFunctionParameter(cfg: ControlFlowDiagram, genData : GeneratorData)]
[for(am : AddressMapping | genData.getFilteredAddresses('func-params:' + cfg.name)->select(type.equalsIgnoreCase('ref'))->select(name.equalsIgnoreCase('returnvalue')._not()))]
.[am.name/]:= cs.[am.name/](p ; inp[if(input(genData))] .[am.type/][i/][/if])[/for][for(am : AddressMapping | genData.getFilteredAddresses('func-params:' + cfg.name)->select(type.equalsIgnoreCase(basis(genData)))->select(name.equalsIgnoreCase('returnvalue')._not()))]
.[am.name/]:= cs.[am.name/](p ; inp[if(genData.transformationSpecificKeys->indexOf('INPUT_REF').oclIsUndefined()._not() and input(genData)._not())] .v [/if][if(input(genData))] .[am.type/][i/][/if])[/for]
[/template]

[comment ============================= Transitions=============================================== /]

[template private transformTransition(t: Transition, genData: GeneratorData)]
[let pc : String = generateNextPC(genData, t)]
[if( canGeneratePCDirectly(t))]cs' = cs .pc:= cs.pc(p ; [pc/])[/if][if (canGenerateCSPart(t))][t.instruction.genCSPart(t,genData)/][/if][if(canGeneratePhiInstruction(t))][t.genPhiInstruction(genData)/][/if][t.instruction.genMemPart(t,genData)/][/let]
[/template]

[query private canGeneratePCDirectly(t : Transition) : Boolean = 
if t.instruction.oclIsUndefined() or t.instruction.oclIsKindOf(Select) or t.instruction.oclIsTypeOf(CompareInt) or t.instruction.oclIsTypeOf(CmpXchg) 
or t.instruction.oclIsTypeOf(AtomicRmwMax) or t.instruction.oclIsTypeOf(AtomicRmwMin) or t.instruction.oclIsTypeOf(AtomicRmwUmax) or t.instruction.oclIsTypeOf(AtomicRmwUmin) 
then false else true endif /]

[query private canGenerateCSPart(t : Transition) : Boolean = 
if t.instruction.oclIsUndefined() or t.instruction.oclIsTypeOf(AtomicRmwMax) or t.instruction.oclIsTypeOf(AtomicRmwMin) or t.instruction.oclIsTypeOf(AtomicRmwUmax) or t.instruction.oclIsTypeOf(AtomicRmwUmin) 
then false else true endif /]

[query private canGeneratePhiInstruction(t : Transition) : Boolean = 
if t.instruction.oclIsTypeOf(CmpXchg) or t.instruction.oclIsTypeOf(AtomicRmwMax) or t.instruction.oclIsTypeOf(AtomicRmwMin) or t.instruction.oclIsTypeOf(AtomicRmwUmax) or t.instruction.oclIsTypeOf(AtomicRmwUmin) 
then false else true endif /]

[comment === Flush ====/]
[template private transformTransition(t: FlushTransition, genData: GeneratorData)]
[let flushed : AddressValuePair = getFlushedAvp(t)]
cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, t)/]) .mem:= cs.mem['[ '/][flushed.address.value.castFromRef(genData)/] ,[flushed.values->first().value.castToRef(genData)/][']'/][/let]
[/template]

[query public getFlushedAvp(t: FlushTransition) : AddressValuePair = invoke('de.upb.lina.cfg.tools.GraphUtility','getFlushedAddressValuePair(de.upb.lina.cfg.controlflow.FlushTransition)', Sequence{t})/]
[query public getcorrespondingAddressMapping(a: Address, genData : GeneratorData, keyForMapping : String) : AddressMapping = invoke('de.upb.lina.transformations.logic.GendataPrecomputer','getCorrespondingAddressMapping(de.upb.llvm_parser.llvm.Address, de.upb.lina.cfg.gendata.GeneratorData, java.lang.String)', Sequence{a,genData,keyForMapping})/]

[comment === WriteDefChainTransition ====/]
[template private transformTransition(t : WriteDefChainTransition, genData : GeneratorData)]
cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, t)/])[if(t.copyAddress.oclIsUndefined()._not())][transformCopyAddress(t, genData)/][/if][if(t.copyValue.oclIsUndefined()._not())][transformCopyValue(t, genData)/][/if]
[/template]

[template private transformCopyAddress(t : WriteDefChainTransition, genData : GeneratorData)]
 .[t.copyAddress.addressToString(genData)/]:= [globalOrLocalVariableAcces(t.copyAddress, 'cs.'+t.instruction.oclAsType(Store).targetAddress.value.valueToString(genData), genData)/]
[/template]

[template private transformCopyValue(t : WriteDefChainTransition, genData : GeneratorData)]
 .[t.copyValue.addressToString(genData)/]:= [globalOrLocalVariableAcces(t.copyValue, 'cs.'+t.instruction.oclAsType(Store).value.value.valueToString(genData), genData)/]
[/template]

[comment === EarlyReadTransition ====/]
[template private transformTransition(t : EarlyReadTransition, genData: GeneratorData)]
cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, t)/]) .[t.instruction.oclAsType(Load).result.addressToString(genData)/]:= [findValueForEarlyReadExpression(t, genData)/]
[/template]

[template private findValueForEarlyReadExpression(t : EarlyReadTransition, genData : GeneratorData)]
[for (avp: AddressValuePair | t.source.buffer.addressValuePairs)]
[for(parameter : Parameter | avp.values)]
[let v : String = parameter.value.valueToString(genData)]
[let am : AddressMapping = getcorrespondingAddressMapping(t.instruction.oclAsType(Load).result, genData, null)]
[if (parameter.value.oclIsKindOf(IntegerConstant))][let intParam : String = possiblyZeroBeforeMinus(parameter.value.oclAsType(IntegerConstant).value).toString()][if(intParam.equalsIgnoreCase(v))][globalOrLocalVariableAcces(t.instruction.oclAsType(Load).result, possiblyCast(parameter.value, am.type, genData), genData)/][/if][/let][else]
[if(t.assignmentExpression.concat('(p)').equalsIgnoreCase(v) or t.assignmentExpression.equalsIgnoreCase(v))][globalOrLocalVariableAcces(t.instruction.oclAsType(Load).result, possiblyCast(parameter.value, am.type, genData), genData)/][/if][/if][/let][/let][/for][/for]
[/template]

[comment ============================== Instructions ==================================================/]
[template private genCSPart(e : Instruction, t: Transition, genData : GeneratorData)]
[comment Abstract/]
[/template]

[template private genMemPart(e : Instruction, t: Transition, genData : GeneratorData)]
[/template]

[template private globalOrLocalVariableAcces(a : Address, s : String, genData : GeneratorData)]
[if(local(a, genData))]cs.[a.addressToString(genData)/](p ; [s/])[else][s/][/if]
[/template]

[template private genPhiInstruction(t : Transition, genData : GeneratorData)]
[for(map : PhiMapping| genData.phiMappings)][if(map.transition = t)][for(phi : Phi | map.phi)] .[phi.result.addressToString(genData)/]:= [for(case : PhiCase|phi.cases)]
[if(case.label.replace('%', '').equalsIgnoreCase(map.blockLabelToUse))][let am : AddressMapping = getcorrespondingAddressMapping(phi.result, genData, null)]
[if(am.type.equalsIgnoreCase('ref'))][globalOrLocalVariableAcces(phi.result, castToRef(case.value, genData), genData)/][else][globalOrLocalVariableAcces(phi.result, possiblyAddCS(case.value, genData)+case.value.valueToString(genData), genData)/][/if][/let][/if][/for][/for][/if][/for]
[/template]

[template private genCSPart(e : ArithmeticOperation, t: Transition, genData : GeneratorData)]
 .[e.result.addressToString(genData)/]:= [globalOrLocalVariableAcces(e.result, possiblyAddCS(e.value1, genData)+e.value1.valueToString(genData)+' '+e.operation.arithmeticOp()+' '+possiblyAddCS(e.value2, genData)+e.value2.valueToString(genData), genData)/]
[/template]

[query private arithmeticOp(s : EString) : String = 
if s.equalsIgnoreCase('add') then
	'+'
else if s.equalsIgnoreCase('sub') or s.equalsIgnoreCase('ashr') then
	'-'
else if s.equalsIgnoreCase('mul') then
	'*'
else if s.equalsIgnoreCase('sdiv') or s.equalsIgnoreCase('udiv') then
	'/'
else
	'NEEDS ATTENTION -> UNSUPPORTED ARITHMETIC OPERATION'
endif
endif
endif
endif
/]

[template private genCSPart(e : Load, t : Transition, genData : GeneratorData)]
 .[e.result.addressToString(genData)/]:= [if(getcorrespondingAddressMapping(e.result, genData, null).type.equalsIgnoreCase('ref')._not())][globalOrLocalVariableAcces(e.result, 'cs.mem['+e.address.value.castFromRef(genData)+'] .v', genData)/][else][globalOrLocalVariableAcces(e.result, 'cs.mem['+e.address.value.castFromRef(genData)+']', genData)/][/if]
[/template]

[template private genCSPart(e : CompareInt, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)][let res : String = e.result.addressToString(genData)]
[if(e.cond.equalsIgnoreCase('eq'))]([compareTypecorrect(e.operand1, e.operand2, genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ne'))]([compareTypecorrect(e.operand1, e.operand2, genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, genData)/])[else]
[if(e.cond.equalsIgnoreCase('uge')._or(e.cond.equalsIgnoreCase('sge')))]([e.operand1.castFromRef(genData)/] ≥ [e.operand2.castFromRef(genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ugt')._or(e.cond.equalsIgnoreCase('sgt')))]([e.operand1.castFromRef(genData)/] ≤ [e.operand2.castFromRef(genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ult')._or(e.cond.equalsIgnoreCase('slt')))]([e.operand1.castFromRef(genData)/] ≥ [e.operand2.castFromRef(genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ule')._or(e.cond.equalsIgnoreCase('sle')))]([e.operand1.castFromRef(genData)/] ≤ [e.operand2.castFromRef(genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, genData)/])[/if][/if][/if][/if][/if][/if]
[/let][/let]
[/template]

[template private genCSPart(e : CmpXchg, t: Transition, genData : GeneratorData)]
[let res : String = e.result.addressToString(genData)][let adr : String = e.address.value.valueToString(genData)][let pc : String = generateNextPC(genData, t)]
( cs.mem['['/][e.address.value.castFromRef(genData)/][']'/] = [e.value.value.castToRef(genData)/] ⊃ (cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, genData)/][genPhiInstruction(t, genData)/] .mem:= cs.mem['['/][e.address.value.castFromRef(genData)/], [e.newValue.value.castToRef(genData)/][']'/]) ; (cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, genData)/][genPhiInstruction(t, genData)/]))[/let]
[/let][/let]
[/template]

[template private genCSPart(e : AtomicRMW, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(genData)/]:= [globalOrLocalVariableAcces(e.result, 'cs.mem ['+e.address.value.castFromRef(genData)+'] .v', genData)/]
[let adr : String = e.address.value.castFromRef(genData)][let arg : String = e.argument.value.valueToString(genData)]
[if(e.operation.equalsIgnoreCase('xchg'))] .mem:= cs.mem['[ '/][adr/], [e.argument.value.castToRef(genData)/][']'/][else]
[if(e.operation.equalsIgnoreCase('add'))] .mem:= cs.mem['[ '/][adr/], ⌜(cs.mem['['/][adr/][']'/] .v) + [possiblyAddCS(e.argument.value, genData)/][arg/]⌝[']'/][else]
[if(e.operation.equalsIgnoreCase('sub'))] .mem:= cs.mem['[ '/][adr/], ⌜(cs.mem['['/][adr/][']'/] .v) - [possiblyAddCS(e.argument.value, genData)/][arg/]⌝[']'/][else]unsupported operation[/if][/if][/if][/let][/let]
[/template]

[template private genMemPart(e: AtomicRMW, t: Transition, genData : GeneratorData)]
[let adr : String = e.address.value.castFromRef(genData)][let pc : String = generateNextPC(genData, t)]
[if(e.operation.equalsIgnoreCase('max')._or(e.operation.equalsIgnoreCase('umax')))](cs.mem['['/][adr/][']'/] .v > [e.argument.value.castFromRef(genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/])[genPhiInstruction(t, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/])[genPhiInstruction(t, genData)/] .mem:= cs.mem['[ '/][adr/], [e.argument.value.castToRef(genData)/][']'/])[else]
[if(e.operation.equalsIgnoreCase('min')._or(e.operation.equalsIgnoreCase('umin')))](cs.mem['['/][adr/][']'/] .v < [e.argument.value.castFromRef(genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/])[genPhiInstruction(t, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/])[genPhiInstruction(t, genData)/] .mem:= cs.mem['[ '/][adr/], [e.argument.value.castToRef(genData)/][']'/])
[/if][/if][/let][/let]
[/template]

[template private genMemPart(e: Branch, t: Transition, genData : GeneratorData)]
[if(e.condition.oclIsUndefined()._not())] ∧ [for(ct : ConstraintMapping | genData.constraints)][if(ct.transition = t)][if(ct.condition.contains('!')._not())][possiblyAddCS(e.condition, genData)/][e.condition.valueToString(genData)/] = 1[else][possiblyAddCS(e.condition, genData)/][e.condition.valueToString(genData)/] = 0[/if][/if][/for][/if]
[/template]

[template private genCSPart(e : GetElementPtr, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(genData)/]:= [for(mm : MemorySizeMapping | genData.memorySizeMappings)][if(mm.instruction = e)][let offset : EInt = mm.offset][possiblyCastToRef('('+ e.aggregate.value.castFromRef(genData) +' + '+ offset + ')', e.result, genData)/][/let][/if][/for]
[/template]

[template private genCSPart(e : Cast, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(genData)/]:= [let amRes : AddressMapping = getcorrespondingAddressMapping(e.result, genData, null)]
[globalOrLocalVariableAcces(e.result, e.value.possiblyCast(amRes.type, genData), genData)/][/let]
[/template]

[template private genCSPart(e : Select, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)]
([castFromRef(e.condition.value, genData)/] = 1 ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[e.result.addressToString(genData)/]:= [globalOrLocalVariableAcces(e.result, possiblyCast(e.trueValue.value, getcorrespondingAddressMapping(e.result, genData, null).type, genData), genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[e.result.addressToString(genData)/]:= [globalOrLocalVariableAcces(e.result, possiblyCast(e.elseValue.value, getcorrespondingAddressMapping(e.result, genData, null).type, genData), genData)/])[/let]
[/template]

[template private genCSPart(e : Switch, t : Transition, genData : GeneratorData)]
 ∧[let cond : String = t.oclAsType(GuardedTransition).condition.substitute('[', '').substitute(']', '').trim()]
[for (case : SwitchCase | e.cases) separator (' ∧')] [possiblyAddCS(e.caseValue.value, genData)/][e.caseValue.value.valueToString(genData)/][if(case.caseValue.value.valueToString(genData).trim().equalsIgnoreCase(cond))] = [cond/][else] ≠ [case.caseValue.value.valueToString(genData).trim()/][/if][/for][/let]
[/template]

[template private genNestedCast(cast : NestedCast, genData : GeneratorData)]
[if(extractType(cast.from).contains('*'))][possiblyCast(cast.value, 'ref', genData)/][else][possiblyCast(cast.value, genData.basis(), genData)/][/if]
[/template]

[template private genNestedGetElemPtr(nestedPtr : NestedGetElementPtr, genData : GeneratorData)]
([nestedPtr.aggregate.value.castFromRef(genData)/][for(mm : MemorySizeMapping | genData.memorySizeMappings)][if(mm.instruction = nestedPtr)] + [mm.offset/][/if][/for])
[/template]

[comment ================================ Return =================================================/]

[template private generateReturn(genData : GeneratorData, ret : Return)]
[if(ret.value.oclIsTypeOf(Parameter))] ∧ return = [if(genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->first().type.equalsIgnoreCase('ref'))][castToRef(ret.value.oclAsType(Parameter).value, genData)/][else][possiblyAddCS(ret.value.oclAsType(Parameter).value, genData)/][ret.value.oclAsType(Parameter).value.valueToString(genData)/][/if][else]
[if(ret.value.oclAsType(PrimitiveValue).value.equalsIgnoreCase('void')._not())] ∧ return = [ret.value.oclAsType(PrimitiveValue).valueToString(genData)/][/if][/if]
[/template]

[comment ====== General Calls ======/]
[template private possiblyCastToRef(s : String, address : Address, genData : GeneratorData)]
[let am : AddressMapping = getcorrespondingAddressMapping(address, genData, null)][if(am.type.equalsIgnoreCase('ref'))][globalOrLocalVariableAcces(address, '⌜'+s+'⌝', genData)/][else][globalOrLocalVariableAcces(address, s, genData)/][/if][/let]
[/template]

[query private addressToString(address: Address, genData: GeneratorData) : String = getcorrespondingAddressMapping(address, genData, null).name/]

[query private possiblyZeroBeforeMinus(s : EInt) : String = if (s < 0) then '(0 - '+s.abs()+')' else s endif /]

[query private possiblyAddCS(v : Value, genData: GeneratorData) : String = if v.oclIsTypeOf(AddressUse) then 'cs .' else '' endif /]

[template private valueToString(v : Value, genData: GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][v.oclAsType(PrimitiveValue).value.transformBooleanToNumber()/][elseif ( v.oclIsKindOf(Constant))]
[v.oclAsType(Constant).getValueFromConstant()/][elseif (v.oclIsTypeOf(AddressUse))]
[let am : AddressMapping = getcorrespondingAddressMapping(v.oclAsType(AddressUse).address, genData, null)][am.name.transformBooleanToNumber()/][if(local(v.oclAsType(AddressUse).address,genData))](p)[/if][/let][elseif(v.oclIsKindOf(NestedGetElementPtr))]
[genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), genData)/][elseif(v.oclIsKindOf(NestedCast))]
[genNestedCast(v.oclAsType(NestedCast), genData)/][/if]
[/template]

[query private transformBooleanToNumber(b : String) : String =
if b.equalsIgnoreCase('true') then '1'
else if b.equalsIgnoreCase('false') then '0' 
else b endif endif /]

[template public castToRef(v : Value, genData : GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][if(v.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[possiblyAddCS(v, genData)/][v.valueToString(genData)/]⌝[/if][elseif ( v.oclIsKindOf(Constant))]
⌜[v.oclAsType(Constant).getValueFromConstant()/]⌝[elseif (v.oclIsTypeOf(AddressUse))]
[let am : AddressMapping = getcorrespondingAddressMapping(v.oclAsType(AddressUse).address, genData, null)]
[let addressName : String = possiblyAddCS(v, genData)+v.valueToString(genData).transformBooleanToNumber()]
[if (am.type.equalsIgnoreCase(genData.basis()))]⌜ [addressName/]⌝[else][addressName/][/if][/let][/let][elseif (v.oclIsTypeOf(NestedGetElementPtr))]
[genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), genData)/][elseif (v.oclIsTypeOf(NestedCast))]
[genNestedCast(v.oclAsType(NestedCast), genData)/][/if]
[/template]

[template public castFromRef(v : Value, genData : GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][possiblyAddCS(v, genData)/][v.oclAsType(PrimitiveValue).value.transformBooleanToNumber()/][elseif ( v.oclIsKindOf(Constant))]
[v.oclAsType(Constant).getValueFromConstant()/][elseif (v.oclIsTypeOf(AddressUse))]
[let am : AddressMapping = getcorrespondingAddressMapping(v.oclAsType(AddressUse).address, genData, null)]
[let addressName : String = possiblyAddCS(v, genData)+v.valueToString(genData).transformBooleanToNumber()]
[if (am.type.equalsIgnoreCase('ref'))][addressName/] .v[else][addressName/][/if][/let][/let][elseif (v.oclIsTypeOf(NestedGetElementPtr))]
[genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), genData)/][elseif (v.oclIsTypeOf(NestedCast))]
[genNestedCast(v.oclAsType(NestedCast), genData)/][/if]
[/template]

[query public getValueFromConstant(c : Constant) : String =
if c.oclIsTypeOf(IntegerConstant) then c.oclAsType(IntegerConstant).value.possiblyZeroBeforeMinus() else c.oclAsType(DecimalConstant).value endif/]

[template private compareTypecorrect(v1 : Value, v2 : Value, genData : GeneratorData)]
[let cs1 : String = possiblyAddCS(v1, genData)][let cs2 : String = possiblyAddCS(v2, genData)]
[let s1 : String = cs1+v1.valueToString(v1, genData)][let s2 : String = cs2+v2.valueToString(v2, genData)]
[if(v1.oclIsTypeOf(AddressUse) or v2.oclIsTypeOf(AddressUse))]
	[if(v1.oclIsTypeOf(AddressUse))][let am1 : AddressMapping = getcorrespondingAddressMapping(v1.oclAsType(AddressUse).address, genData, null)]
		[if(v2.oclIsTypeOf(AddressUse))][let am2 : AddressMapping = getcorrespondingAddressMapping(v2.oclAsType(AddressUse).address, genData, null)]
			[if(am1.type.equalsIgnoreCase(genData.basis()) and am2.type.equalsIgnoreCase('ref'))]⌜[s1/]⌝ = [s2/][else]
			[if(am1.type.equalsIgnoreCase('ref') and am2.type.equalsIgnoreCase(genData.basis()))][s1/] = ⌜[s2/]⌝[else][s1/] = [s2/]
			[/if][/if][/let]
		[else]
			[if(v2.oclIsTypeOf(PrimitiveValue) and am1.type.equalsIgnoreCase('ref'))][s1/] = [if(v2.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[s2/]⌝[/if][else]
			[if(v2.oclIsKindOf(Constant) and am1.type.equalsIgnoreCase('ref'))][s1/] = ⌜[v2.oclAsType(Constant).getValueFromConstant()/]⌝[else][s1/] = [s2/]
			[/if][/if]
		[/if][/let]
	[elseif(v2.oclIsTypeOf(AddressUse))][let am2 : AddressMapping = getcorrespondingAddressMapping(v2.oclAsType(AddressUse).address, genData, null)]
		[if(v1.oclIsTypeOf(PrimitiveValue) and am2.type.equalsIgnoreCase('ref'))][if(v1.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[s1/]⌝[/if] = [s2/][else]
		[if(v1.oclIsKindOf(Constant) and am2.type.equalsIgnoreCase('ref'))]⌜[v1.oclAsType(Constant).getValueFromConstant()/]⌝ = [s2/][else][s1/] = [s2/]
		[/if][/if][/let]
	[else][s1/] = [s2/][/if]
[else][s1/] = [s2/][/if]
[/let][/let][/let][/let]
[/template]

[template private possiblyCast(v: Value, resultType : String, genData : GeneratorData)]
[if (v.oclIsTypeOf(AddressUse))][let am : AddressMapping = getcorrespondingAddressMapping(v.oclAsType(AddressUse).address, genData, null)]
[if (resultType.equalsIgnoreCase(genData.basis()) and am.type.equalsIgnoreCase('ref'))][v.castFromRef(genData)/][elseif(resultType.equalsIgnoreCase('ref') and am.type.equalsIgnoreCase(genData.basis()))]
[v.castToRef(genData)/][else][possiblyAddCS(v, genData)/][v.valueToString(genData)/][/if][/let]
[elseif(resultType.equalsIgnoreCase('ref'))][v.castToRef(genData)/][else][possiblyAddCS(v, genData)/][v.valueToString(genData)/][/if]
[/template]

[query private local(a : Address, genData : GeneratorData) : Boolean = if getcorrespondingAddressMapping(a, genData, 'globals') = null then true else false endif/]

[comment ========================== create comments =============================================/]

[template private createComment(t : Transition)]
[let l : Load = t.instruction]
[l.result.name/] = load [l.address.displayParameter()/][if(l.align.oclIsUndefined()._not())], align [l.align/][/if][for(m : MetaArgValue | l.meta)], [m.arg/] [m.value/][/for][elselet s : Store = t.instruction]
store [s.value.displayParameter()/], [s.targetAddress.displayParameter()/][if(s.align.oclIsUndefined()._not())], align [s.align/][/if][for(m : MetaArgValue | s.meta)], [m.arg/] [m.value/][/for][elselet s : GetElementPtr = t.instruction]
[s.result.name/] = getelementptr [s.aggregate.displayParameter()/][for(index : Parameter | s.indices)], [index.displayParameter()/][/for][elselet s : Alloc = t.instruction]
[s.result.name/] = alloca [s.type.extractType()/][if(s.numOfElements.oclIsUndefined()._not())], [s.numOfElements.displayParameter()/][/if][if(s.align.oclIsUndefined()._not())], align [s.align/][/if][elselet s : CmpXchg = t.instruction]
[s.result.name/] = cmpxchg [if(s.volatile)]volatile [/if][s.address.displayParameter()/], [s.value.displayParameter()/], [s.newValue.displayParameter()/] [s.ordering/][elselet s : AtomicRMW = t.instruction]
[s.result.name/] = atomicrmw [if(s.volatile)]volatile [/if][s.operation/] [s.address.displayParameter()/], [s.argument.displayParameter()/] [s.ordering/][elselet s : Fence = t.instruction]
fence [s.ordering/][elselet s : Return = t.instruction]
ret [if(s.value.oclIsTypeOf(Parameter))][s.value.oclAsType(Parameter).displayParameter()/][else][s.value.oclAsType(PrimitiveValue).value/][/if][elselet s : Branch = t.instruction]
br [if(s.condition.oclIsUndefined()._not())][s.condition.extractValue()/], [/if]label [s.destination/][if(s.elseDestination.oclIsUndefined()._not())], label [s.elseDestination/][/if][elselet s : Switch = t.instruction]
switch [s.caseValue.displayParameter()/], label [s.defaultCase/] ['['/] [for(case : SwitchCase | s.cases)][case.caseValue.displayParameter()/], label [case.destination/] [/for][']'/][elselet s : IndirectBranch = t.instruction]
indirectbr [s.target.displayParameter()/], ['['/][for(target : EString | s.potTargetLabels)separator(', ')]label [target/][/for][']'/]
	NEEDS ATTENTION ![elselet s : Invoke = t.instruction]
invoke [s.returnType.extractType()/] [s.name.name/] ([if(s.pList.oclIsUndefined()._not())][for(param : Parameter | s.pList.params)separator(', ')][param.displayParameter()/][/for][/if]) to label [s.targetLabel/] unwind label [s.unwindTargetLabel/]
	NEEDS ATTENTION ![elselet s : Resume = t.instruction]
resume [s.type.extractType()/] [s.value.extractValue()/]
	NEEDS ATTENTION ![elselet s : LogicOperation = t.instruction]
[s.result.name/] = [s.operation/] [s.optype.extractType()/] [s.value1.extractValue()/], [s.value2.extractValue()/]
	NEEDS ATTENTION ![elselet s : ArithmeticOperation = t.instruction]
[s.result.name/] = [s.operation/] [s.optype.extractType()/] [s.value1.extractValue()/], [s.value2.extractValue()/][elselet s : Compare = t.instruction]
[s.result.name/] = [if(s.oclIsTypeOf(CompareInt))]icmp[else]fcmp[/if] [s.cond/] [s.opType.extractType()/] [s.operand1.extractValue()/], [s.operand2.extractValue()/][elselet s : Cast = t.instruction]
[s.result.name/] = [s.operation/] [s.from.extractType()/] [s.value.extractValue()/] to [s.to.extractType()/][elselet s : ShuffleVector = t.instruction]
[s.result.name/] = shufflevector [s.value1.displayParameter()/], [s.value2.displayParameter()/], [s.mask.displayParameter()/]
	NEEDS ATTENTION ![elselet s : InsertElement = t.instruction]
[s.result.name/] = insertelement [s.vector.displayParameter()/], [s.value.displayParameter()/], [s.index.displayParameter()/]
	NEEDS ATTENTION ![elselet s : ExtractElement = t.instruction]
[s.result.name/] = extractelement [s.vector.displayParameter()/], [s.index.displayParameter()/]
	NEEDS ATTENTION ![elselet s : InsertValue = t.instruction]
[s.result.name/] = insertvalue [s.aggerate.displayParameter()/], [s.value.displayParameter()/][for(i : EInt | s.index)separator(', ')][i/][/for]
	NEEDS ATTENTION ![elselet s : ExtractValue = t.instruction]
[s.result.name/] = extractvalue [s.aggerate.displayParameter()/][for(i : EInt | s.index)separator(', ')][i/][/for]
	NEEDS ATTENTION ![elselet s : Phi = t.instruction]
[s.result.name/] = phi [s.type.extractType()/] [for(case : PhiCase | s.cases)]['['/][case.value.extractType()/], [case.label/][']'/][/for][elselet s : Select = t.instruction]
[s.result.name/] = select [s.condition.displayParameter()/], [s.trueValue.displayParameter()/], [s.elseValue.displayParameter()/][elselet s : Call = t.instruction]
[if(s.result.oclIsUndefined()._not())][s.result.name/] = [/if]call [s.function.displayParameter()/] ([if(s.pList.oclIsUndefined()._not())][for(param : Parameter | s.pList.params)separator(', ')][param.displayParameter()/][/for][/if])
	NEEDS ATTENTION ![elselet s : VariableAttributeAccess = t.instruction]
[s.result.name/] = va_arg [s.vaList.displayParameter()/], [s.aType.extractType()/]
	NEEDS ATTENTION ![elselet s : LandingPad = t.instruction]
[s.result.name/] = landingpad [s.struct.extractType()/] personality [s.personalitytype.extractType()/] [s.personalityvalue.extractValue()/]
	NEEDS ATTENTION ![else]
[if(t.instruction.oclIsUndefined()._not())][t.instruction.eClass().name/]
	NEEDS ATTENTION ![else][t.eClass().name/][/if][/let]
[/template]

[query private displayParameter(param : Parameter) : String = param.type.extractType() +' '+ param.value.extractValue()/]

[template public extractType(type : EObject)]
[let type : Predefined = type]
[type.type/][if(type.pointer.oclIsUndefined()._not())][type.pointer/][/if][elselet type : AddressUse = type]
[type.address.name/] [if(type.pointer.oclIsUndefined()._not())][type.pointer/][/if][elselet type : FunctionType = type]
[type.returnType.extractType()/]([if(type.parameter.oclIsUndefined()._not())][for(t : FunctionParameter | type.parameter.params)separator(', ')][t.type.extractType()/] [if(t.value.oclIsUndefined()._not())][t.value.name/][/if][/for][/if])[if(type.pointer.oclIsUndefined()._not())][type.pointer/][/if][elselet struct : Structure = type]
{[for(type : EObject | struct.types)separator(', ')][type.extractType()/][/for]}[if(struct.pointer.oclIsUndefined()._not())][struct.pointer/][/if][elselet type : Array = type]
['['/][if(type.length.oclIsUndefined()._not())][type.length/] x [extractType(type.type)/][/if][']'/][if(type.pointer.oclIsUndefined()._not())][type.pointer/][/if][elselet type : Vector = type]
<[type.length/] x [extractType(type.type.oclAsType(EObject))/]>;[/let]
[/template]

[template extractValue(v : Value)]
[let value : AddressUse = v]
[value.address.name/][elselet value : PrimitiveValue = v]
[value.value/][elselet value : IntegerConstant = v]
[value.value/][elselet value : NestedGetElementPtr = v]
getelementptr [value.aggregate.displayParameter()/][for(index : Parameter | value.indices)], [index.displayParameter()/][/for][elselet value : NestedCast = v]
[value.operation/]([value.from.extractType()/] [value.value.extractValue()/] to [value.to.extractType()/])[/let]
[/template]