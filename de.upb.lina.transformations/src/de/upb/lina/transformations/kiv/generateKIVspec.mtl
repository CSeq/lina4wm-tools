[comment encoding = UTF-8 /]
[module generateKIVspec('http://www.upb.de/lina/cfg/controlflow', 'http://www.upb.de/lina/cfg/gendata', 'http://www.upb.de/llvm_parser/llvm', 'http://www.eclipse.org/emf/2002/Ecore')]

[template public generateModel(genData : GeneratorData) ]
[comment @main/]

[file ( 'localstate.utf8', false, 'UTF-8')]
data specification
	using [basis(genData)/]ref, PC, PID
	Localstate :=mkls( . .pc : PC; . .pid : PID;
					[for(am: AddressMapping | genData.getFilteredAddresses('all-declare'))] 
					. .[am.name/] : [am.type/];
					[/for]
					[for(am: AddressMapping | genData.getFilteredAddresses('all-params'))]. .[am.name/] : [am.type/]; [/for]);
	variables
		ls : Localstate;
end data specification
[/file]

[file ('PC.utf8', false, 'UTF-8')]
data specification
	PC = N |[for (l : LocationLabel | genData.locationLabels) separator  (' |')] 
		
		[l.name/] [/for];
variables
pc : PC;

end data specification
[/file]

[file ('PID.utf8', false, 'UTF-8')]
specification
	sorts
		PID;
	variables
		p : PID;
end specification
[/file]

[file ('cindex.utf8', false, 'UTF-8')]
data specification
	IJ = [for (cfg : ControlFlowDiagram | genData.cfgs) separator ('|')] [generateCfgLabel(genData, cfg)/]ini [/for];
	CJ = [for (label : TransitionLabel | genData.transitionLabels->select(transition.instruction.oclIsUndefined()._or((transition.instruction.eClass() = Return)._not())))separator ('|')] [label.name/] [/for];
	RJ = [for (label : TransitionLabel | genData.transitionLabels->select(transition.instruction.oclIsUndefined()._not()._and((transition.instruction.eClass() = Return))))separator ('|')] [label.name/]ret [/for];
	variables
		ij : IJ;
		cj : CJ;
		rj : RJ;
end data specification
[/file]

[file ('COP.utf8', false, 'UTF-8')]
enrich 	[basis(genData)/]ref-memory,
		localstate,
		cindex with

	[generateGlobalConstants(genData)/]
	functions
		INVOP : IJ → [basis(genData)/] ×  memory ×  Localstate ×  memory ×  Localstate → bool;
		COP : CJ → memory × Localstate × memory × Localstate → bool;
		RETOP : RJ → memory × Localstate × memory × Localstate × ref → bool;
	predicates
		LSInit : Localstate × PID;
		GSInit : memory;
	variables
		invop : [basis(genData)/] × memory × Localstate × memory × Localstate → bool;
		cop : memory × Localstate × memory × Localstate → bool;
		retop : memory × Localstate × memory × Localstate × ref → bool;
		mem' : memory;
		ls' : Localstate;
		elem : [basis(genData)/];
		return : ref;

	axioms

	LSInit : ⊦ LSInit(ls, p) ↔ ls .pc = N ∧ ls .pid = p;
	used for : s, ls;

	[for (cfg : ControlFlowDiagram | genData.cfgs)] 
;; 	[generateCfgLabel(genData, cfg)/] reflects function [cfg.name/]
	[generateCfgLabel(genData, cfg)/]ini : ⊦ INVOP([generateCfgLabel(genData, cfg)/]ini)(elem, mem, ls, mem', ls') ↔ ls .pc = N ∧ ls' = ls .pc:= [generateStartPC(genData, cfg)/] ∧ mem' = mem;
	used for : s, ls;

	[/for]
	[for (label : TransitionLabel | genData.transitionLabels->select(transition.instruction.oclIsUndefined()._or((transition.instruction.eClass() = Return)._not())))]
;;	[label.transition.createComment()/]
	[label.name/] : ⊦ COP([label.name/])(mem, ls, mem', ls') ↔ ls .pc = [genData.generatePrevPC(genData, label.transition)/] ∧ [label.transition.transformTransition(genData)/];
	used for : s, ls;

	[/for]
	[for (label : TransitionLabel | genData.transitionLabels->select(transition.instruction.oclIsUndefined()._not()._and(transition.instruction.eClass() = Return)))]
;;	[label.transition.createComment()/]
	[label.name/]ret : ⊦ RETOP([label.name/]ret)(mem, ls, mem', ls', return) ↔ ls .pc = [genData.generatePrevPC(genData, label.transition)/] ∧ ls' = ls .pc:= N ∧ mem' = mem;
	used for : s, ls;
	
	[/for]
end enrich
		
[/file]

[/template]

[template private createComment(t : Transition)]
[if(t.instruction.oclIsUndefined())][t.eClass().name/][else][t.instruction.eClass().name/][/if]
[/template]

[template private generateGlobalConstants(genData : GeneratorData)]
[if(genData.getFilteredAddresses('globals')->size() > 0)]
constants
[for(am : AddressMapping| genData.getFilteredAddresses('globals'))]
	[am.name/] : [am.type/];
[/for][/if]
[/template]

[template private generatePrevPC(genData: GeneratorData, transition: Transition)]
[for (label : LocationLabel | genData.locationLabels)][if(label.controlFlowLocation = transition.source)][label.name/][/if][/for]
[/template]

[template private generateNextPC(genData: GeneratorData, transition: Transition)]
[for (label : LocationLabel | genData.locationLabels)][if(label.controlFlowLocation = transition.target)][label.name/][/if][/for]
[/template]

[template private generateCfgLabel(genData : GeneratorData, cfg : ControlFlowDiagram)]
[for (l : LocationLabel | genData.locationLabels)][if (l.controlFlowLocation = cfg.start)]
[l.name.substring(1, 1).toLowerCase()/][/if][/for]
[/template]

[template private generateStartPC(genData : GeneratorData, cfg : ControlFlowDiagram)]
[for (l : ControlFlowLocation | cfg.locations)]
[if (l = cfg.start)][for (label : LocationLabel | genData.locationLabels)][if (l = label.controlFlowLocation)][label.name/][/if][/for][/if][/for]
[/template]

[template private basis(genData : GeneratorData)]
[for(basis: String | genData.transformationSpecificKeys)][if (basis.equalsIgnoreCase('INT'))]int[/if][if (basis.equalsIgnoreCase('NAT'))]nat[/if][/for]
[/template]

[template private genPhiInstruction(t : Transition, genData : GeneratorData)]
[for(map : PhiMapping| genData.phiMappings)][if(map.transition = t)][for(phi : Phi | map.phi)] .[phi.result.addressToString(genData)/]:= [for(case : PhiCase|phi.cases)][if(case.label.equalsIgnoreCase(map.blockLabelToUse))][possiblyAddLS(case.value, genData)/][case.value.valueToString(genData)/][/if][/for][/for][/if][/for]
[/template]


[comment ====== Transitions ======/]
[template private transformTransition(t: Transition, genData: GeneratorData)]
[let pc : String = generateNextPC(genData, t)]
[if((t.instruction.oclIsUndefined() or t.instruction.oclIsTypeOf(CompareInt) or t.instruction.oclIsTypeOf(CmpXchg))._not())]ls' = ls .pc:= [pc/][/if][if (t.instruction.oclIsUndefined()._not())][t.instruction.genLsPart(t,genData)/][/if][if(t.instruction.oclIsTypeOf(CmpXchg)._not())][t.genPhiInstruction(genData)/][/if][t.instruction.genMemPart(t,genData)/][/let]
[/template]

[comment === WriteDefChainTransition ====/]
[template private transformTransition(t : WriteDefChainTransition, genData : GeneratorData)]
ls' = ls .pc:= [generateNextPC(genData, t)/][if(t.copyAddress.oclIsUndefined()._not())][transformCopyAddress(t, genData)/][/if][if(t.copyValue.oclIsUndefined()._not())][transformCopyValue(t, genData)/][/if] ∧ mem' = mem
[/template]

[template private transformCopyAddress(t : WriteDefChainTransition, genData : GeneratorData)]
 .[t.copyAddress.addressToString(genData)/]:= ls.[valueToString(t.instruction.oclAsType(Store).targetAddress.value, genData)/]
[/template]

[template private transformCopyValue(t : WriteDefChainTransition, genData : GeneratorData)]
 .[t.copyValue.addressToString(genData)/]:= ls.[valueToString(t.instruction.oclAsType(Store).value.value, genData)/]
[/template]

[comment === Flush ====/]
[template private transformTransition(t: FlushTransition, genData: GeneratorData)]
ls' = ls .pc:= [generateNextPC(genData, t)/] ∧ mem' = mem['[ '/][let first : AddressValuePair = t.source.buffer.addressValuePairs->first()][first.address.value.castFromRef(genData)/] ,[let v : Value = first.value.value][v.castToRef(genData)/][']'/][/let][/let]
[/template]

[comment === EarlyReadTransition ====/]
[template private transformTransition(t : EarlyReadTransition, genData: GeneratorData)]
ls' = ls .pc:= [generateNextPC(genData, t)/] .[t.instruction.oclAsType(Load).result.addressToString(genData)/]:= [findValueForEarlyReadExpression(t, genData)/] ∧ mem' = mem
[/template]

[template private findValueForEarlyReadExpression(t : EarlyReadTransition, genData : GeneratorData)]
[for (avp: AddressValuePair | t.source.buffer.addressValuePairs)][if(t.assignmentExpression.equalsIgnoreCase(avp.value.value.name(genData)))][let v : Value = avp.value.value][possiblyAddLS(v, genData)/][v.valueToString(genData)/][/let][/if][/for]
[/template]

[query private name(v : Value, genData: GeneratorData) : String = 
if(v.oclIsTypeOf(AddressUse)) then 
v.oclAsType(AddressUse).address.name
else if(v.oclIsTypeOf(Constant)) then
v.oclAsType(Constant).value.toString()
else if(v.oclIsTypeOf(PrimitiveValue)) then
v.oclAsType(PrimitiveValue).value
else
''
endif
endif
endif
/]

[comment ====== Instructions ======/]
[template private genLsPart(e : Instruction, t: Transition, genData : GeneratorData)]
[comment Abstract/]
[/template]

[template private genMemPart(e : Instruction, t: Transition, genData : GeneratorData)]
 ∧ mem' = mem
[/template]

[template private genLsPart(e : ArithmeticOperation, t: Transition, genData : GeneratorData)]
[e.arithmeticInstr(e, genData)/]
[/template]

[query private arithmeticInstr(e : ArithmeticOperation, genData: GeneratorData) : String = 
' .' + e.result.addressToString(genData) + ':= ( ' 
+ possiblyAddLS(e.value1, genData)
+ e.value1.valueToString(genData)
+ ' '
+ e.operation.arithmeticOp() + ' ' 
+ possiblyAddLS(e.value2, genData) 
+ e.value2.valueToString(genData) 
+ ')'
/]

[query private arithmeticOp(s : EString) : String = 
if s.equalsIgnoreCase('add') then
	'+'
else if s.equalsIgnoreCase('sub') or s.equalsIgnoreCase('ashr') then
	'-'
else if s.equalsIgnoreCase('mul') then
	'*'
else if s.equalsIgnoreCase('sdiv') or s.equalsIgnoreCase('udiv') then
	'/'
else
	'TODO: UNHANDLED'
endif
endif
endif
endif
/]

[template private genLsPart(e : Load, t : Transition, genData : GeneratorData)]
 .[e.result.addressToString(genData)/]:= mem['['/][e.address.value.castFromRef(genData)/][']'/][for (am1: AddressMapping | genData.addressMappings)]
[for (a: Address | am1.adresses)]
[if (e.result = a)][if(am1.type.equalsIgnoreCase('ref')._not())] .v[/if][/if][/for][/for]
[/template]

[template private genLsPart(e : CompareInt, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)][let op1 : String = e.operand1.valueToString(genData)][let op2 : String = e.operand2.valueToString(genData)][let res : String = e.result.addressToString(genData)]
[if(e.cond.equalsIgnoreCase('eq'))]([compareTypecorrect(e.operand1, e.operand2, genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= 1 ; ls' = ls .pc:= [pc/] .[res/]:= 0)[else]
[if(e.cond.equalsIgnoreCase('ne'))]([compareTypecorrect(e.operand1, e.operand2, genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= 0 ; ls' = ls .pc:= [pc/] .[res/]:= 1)[else]
[if(e.cond.equalsIgnoreCase('uge')._or(e.cond.equalsIgnoreCase('sge')))]([e.operand1.castFromRef(genData)/] ≥ [e.operand2.castFromRef(genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= 1 ; ls' = ls .pc:= [pc/] .[res/]:= 0)[else]
[if(e.cond.equalsIgnoreCase('ugt')._or(e.cond.equalsIgnoreCase('sgt')))]([e.operand1.castFromRef(genData)/] ≤ [e.operand2.castFromRef(genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= 0 ; ls' = ls .pc:= [pc/] .[res/]:= 1)[else]
[if(e.cond.equalsIgnoreCase('ult')._or(e.cond.equalsIgnoreCase('slt')))]([e.operand1.castFromRef(genData)/] ≥ [e.operand2.castFromRef(genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= 0 ; ls' = ls .pc:= [pc/] .[res/]:= 1)[else]
[if(e.cond.equalsIgnoreCase('ule')._or(e.cond.equalsIgnoreCase('sle')))]([e.operand1.castFromRef(genData)/] ≤ [e.operand2.castFromRef(genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= 1 ; ls' = ls .pc:= [pc/] .[res/]:= 0)[/if][/if][/if][/if][/if][/if]
[/let][/let][/let][/let]
[/template]

[template private genLsPart(e : CmpXchg, t: Transition, genData : GeneratorData)]
[let res : String = e.result.addressToString(genData)][let adr : String = e.address.value.valueToString(genData)][let pc : String = generateNextPC(genData, t)]
( [compareTypecorrect(e.address.value,e.value.value, genData)/] ⊃ (ls' = ls .pc:= [pc/] .[res/]:= 1[genPhiInstruction(t, genData)/] ∧ mem' = mem['['/][e.address.value.castFromRef(genData)/], [e.newValue.value.castToRef(genData)/][']'/]) ; (ls' = ls .pc:= [pc/] .[res/]:= 0[genPhiInstruction(t, genData)/] ∧ mem' = mem))[/let]
[/let][/let]
[/template]

[template private genMemPart(e : CmpXchg, t: Transition, genData: GeneratorData)]
[/template]

[template private genLsPart(e : AtomicRMW, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(genData)/]:= mem['['/][e.address.value.castFromRef(genData)/][']'/] .v
[/template]

[template private genMemPart(e: AtomicRMW, t: Transition, genData : GeneratorData)]
 ∧ [let adr : String = e.address.value.castFromRef(genData)][let arg : String = e.argument.value.valueToString(genData)][let res : String = e.result.addressToString(genData)]
[if(e.operation.equalsIgnoreCase('xchg'))]mem' = mem['[ '/][adr/], [e.argument.value.castToRef(genData)/][']'/][else]
[if(e.operation.equalsIgnoreCase('add'))]mem' = mem['[ '/][adr/], ⌜(mem['['/][adr/][']'/] .v) + [possiblyAddLS(e.argument.value, genData)/][arg/]⌝[']'/][else]
[if(e.operation.equalsIgnoreCase('sub'))]mem' = mem['[ '/][adr/], ⌜(mem['['/][adr/][']'/] .v) - [possiblyAddLS(e.argument.value, genData)/][arg/]⌝[']'/][else]
[if(e.operation.equalsIgnoreCase('max')._or(e.operation.equalsIgnoreCase('umax')))]([adr/] > [e.argument.value.castFromRef(genData)/] ⊃ mem' = mem ; mem' = mem['[ '/][adr/], [e.argument.value.castToRef(genData)/][']'/])[else]
[if(e.operation.equalsIgnoreCase('min')._or(e.operation.equalsIgnoreCase('umin')))]([adr/] < [e.argument.value.castFromRef(genData)/] ⊃ mem' = mem ; mem' = mem['[ '/][adr/], [e.argument.value.castToRef(genData)/][']'/])[/if][/if][/if][/if][/if][/let][/let][/let]
[/template]

[template private genMemPart(e: Branch, t: Transition, genData : GeneratorData)]
[if(e.condition.oclIsUndefined()._not())] ∧ [for(ct : ConstraintMapping | genData.constraints)][if(ct.transition = t)]ls.[if(ct.condition.contains('!')._not())][e.condition.valueToString(genData)/] = 1[else][e.condition.valueToString(genData)/] = 0[/if][/if][/for][/if]
[/template]

[template private genLsPart(e : GetElementPtr, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(genData)/]:= [possiblyAddLS(e.aggregate.value, genData)/][e.aggregate.value.valueToString(genData)/]
[/template]

[template private genLsPart(e : Cast, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(genData)/]:= [e.value.getTypeOfCast(e.result, genData)/]
[/template]

[template private getTypeOfCast(v: Value, result : Address, genData : GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][v.oclAsType(PrimitiveValue).value.transformBooleanToNumber()/]
[elseif ( v.oclIsTypeOf(Constant))][v.oclAsType(Constant).value/] 
[elseif (v.oclIsTypeOf(AddressUse))]
[for (am: AddressMapping | genData.addressMappings)]
[for (a: Address | am.adresses)]
[if (v.oclAsType(AddressUse).address = a)]
[for (amRes: AddressMapping | genData.addressMappings)]
[for (a: Address | amRes.adresses)]
[if (result = a)]
[if (amRes.type.equalsIgnoreCase(genData.basis()) and am.type.equalsIgnoreCase('ref'))][v.castFromRef(genData)/][else][possiblyAddLS(v, genData)/][v.valueToString(genData)/][/if][/if][/for][/for][/if][/for][/for][/if]
[/template]

[comment ====== General Calls ======/]
[template private addressToString(address: Address, genData: GeneratorData)]
[for (am: AddressMapping | genData.addressMappings)][for (a: Address | am.adresses)][if (address = a)][am.name/][/if][/for][/for]
[/template]

[template private valueToString(v : Value, genData: GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][v.oclAsType(PrimitiveValue).value.transformBooleanToNumber()/][elseif ( v.oclIsTypeOf(Constant))][v.oclAsType(Constant).value/] [elseif (v.oclIsTypeOf(AddressUse))]
[for (am: AddressMapping | genData.addressMappings)][for (a: Address | am.adresses)][if (v.oclAsType(AddressUse).address = a)][am.name.transformBooleanToNumber()/][/if][/for][/for][/if]
[/template]

[template private possiblyAddLS(v : Value, genData: GeneratorData)]
[if(v.oclIsTypeOf(PrimitiveValue)._not()._and(v.oclIsTypeOf(Constant)._not()))]
[for(am : AddressMapping| genData.getFilteredAddresses('all-declare'))][for(a : Address | am.adresses)][if(a = v.oclAsType(AddressUse).address)]ls .[/if][/for][/for][for(am : AddressMapping| genData.getFilteredAddresses('all-params'))][for(a : Address | am.adresses)][if(a = v.oclAsType(AddressUse).address)]ls .[/if][/for][/for][/if]
[/template]

[template private transformBooleanToNumber(b : String)]
[if(b.equalsIgnoreCase('true'))]1[elseif (b.equalsIgnoreCase('false'))]0[else][b/][/if]
[/template]

[template public castToRef(v : Value, genData : GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][if(v.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[possiblyAddLS(v, genData)/][v.valueToString(genData)/]⌝[/if][elseif ( v.oclIsTypeOf(Constant))]⌜[v.oclAsType(Constant).value/]⌝[elseif (v.oclIsTypeOf(AddressUse))]
[for (am: AddressMapping | genData.addressMappings)]
[for (a: Address | am.adresses)]
[if (v.oclAsType(AddressUse).address = a)][if (am.type.equalsIgnoreCase(genData.basis()))]⌜ [possiblyAddLS(v, genData)/][am.name.transformBooleanToNumber()/]⌝[else][possiblyAddLS(v, genData)/][am.name.transformBooleanToNumber()/][/if][/if][/for][/for][/if]
[/template]

[template public castFromRef(v : Value, genData : GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][possiblyAddLS(v, genData)/][v.oclAsType(PrimitiveValue).value.transformBooleanToNumber()/]
[elseif ( v.oclIsTypeOf(Constant))][v.oclAsType(Constant).value/] 
[elseif (v.oclIsTypeOf(AddressUse))]
[for (am: AddressMapping | genData.addressMappings)]
[for (a: Address | am.adresses)]
[if (v.oclAsType(AddressUse).address = a)][if (am.type.equalsIgnoreCase('ref'))][possiblyAddLS(v, genData)/][am.name.transformBooleanToNumber()/] .v[else][possiblyAddLS(v, genData)/][am.name.transformBooleanToNumber()/][/if][/if][/for][/for][/if]
[/template]

[template private compareTypecorrect(v1 : Value, v2 : Value, genData : GeneratorData)]
[let ls1 : String = possiblyAddLS(v1, genData)][let ls2 : String = possiblyAddLS(v2, genData)]
[if(v1.oclIsTypeOf(AddressUse) or v2.oclIsTypeOf(AddressUse))]
	[if(v1.oclIsTypeOf(AddressUse))]
		[for (am1: AddressMapping | genData.addressMappings)]
		[for (a: Address | am1.adresses)]
		[if (v1.oclAsType(AddressUse).address = a)]
			[if(v2.oclIsTypeOf(AddressUse))]
				[for (am2: AddressMapping | genData.addressMappings)]
				[for (a: Address | am2.adresses)]
					[if (v2.oclAsType(AddressUse).address = a)]
					[if(am1.type.equalsIgnoreCase(genData.basis()) and am2.type.equalsIgnoreCase('ref'))]⌜[ls1/][am1.name/]⌝ = [ls2/][am2.name/][else]
					[if(am1.type.equalsIgnoreCase('ref') and am2.type.equalsIgnoreCase(genData.basis()))][ls1/][am1.name/] = ⌜[ls2/][am2.name/]⌝[else][ls1/][am1.name/] = [ls2/][am2.name/]
					[/if][/if][/if]
				[/for][/for]
			[else]
				[if(v2.oclIsTypeOf(PrimitiveValue) and am1.type.equalsIgnoreCase('ref'))][ls1/][am1.name/] = [if(v2.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[ls2/][v2.valueToString(genData)/]⌝[/if][else]
				[if(v2.oclIsTypeOf(Constant) and am1.type.equalsIgnoreCase('ref'))][ls1/][am1.name/] = ⌜[v2.oclAsType(Constant).value/]⌝[else][ls1/][v1.valueToString(genData)/] = [ls2/][v2.valueToString(genData)/]
				[/if][/if]
			[/if]
		[/if]
		[/for]
		[/for]
	[elseif(v2.oclIsTypeOf(AddressUse))]
		[for (am2: AddressMapping | genData.addressMappings)]
		[for (a: Address | am2.adresses)]
		[if (v2.oclAsType(AddressUse).address = a)]
			[if(v1.oclIsTypeOf(PrimitiveValue) and am2.type.equalsIgnoreCase('ref'))][if(v1.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[ls1/][v1.valueToString(genData)/]⌝[/if] = [ls2/][am2.name/][else]
			[if(v1.oclIsTypeOf(Constant) and am2.type.equalsIgnoreCase('ref'))]⌜[v1.oclAsType(Constant).value/]⌝ = [ls2/][am2.name/][else][ls1/][v1.valueToString(genData)/] = [ls2/][v2.valueToString(genData)/]
			[/if][/if]
		[/if][/for][/for]
	[else][ls1/][v1.valueToString(genData)/] = [ls2/][v2.valueToString(genData)/][/if]
[else][ls1/][v1.valueToString(genData)/] = [ls2/][v2.valueToString(genData)/][/if]
[/let][/let]
[/template]