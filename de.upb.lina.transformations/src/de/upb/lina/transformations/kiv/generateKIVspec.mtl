[comment encoding = UTF-8 /]
[module generateKIVspec('http://www.upb.de/lina/cfg/controlflow', 'http://www.upb.de/lina/cfg/gendata', 'http://www.upb.de/llvm_parser/llvm', 'http://www.eclipse.org/emf/2002/Ecore')]
[import de::upb::lina::transformations::TransformationCommon/]
[import de::upb::lina::transformations::kiv::KivCommon/]

[template public generateModel(genData : GeneratorData) ]
[comment @main/]

[generateLocalstateFile(genData)/]

[generatePCFile(genData)/]

[generatePIDFile(genData)/]

[generateCIndexFile(genData)/]

[if(input(genData))]
[file ('specs/input.utf8', false, 'UTF-8')]
data specification
	using [basis(genData)/]ref

	input =[for(inpList : InputTypeList | genData.inputTypes)separator('|')] mk[i/]([for(inputType : String | inpList.inputType->asSequence()->select(equalsIgnoreCase(basis(genData))))] . .[inputType/][i/]: [inputType/];[/for][for(inputType : String | inpList.inputType->asSequence()->select(equalsIgnoreCase('ref')))] . .[inputType/][i/]: [inputType/];[/for]) with [for(inputType : String | inpList.inputType->select(equalsIgnoreCase(genData.basis())))][inputType/][/for][for(inputType : String | inpList.inputType->select(equalsIgnoreCase('ref')))][inputType/][/for]? [/for];
	variables
		inp : input;
end data specification
[/file]
[/if]

[generateCOPFile(genData)/]


[/template]

[template private generateCOPFile(genData: GeneratorData)]
[file ('specs/COP.utf8', false, 'UTF-8')]
enrich 	[basis(genData)/]ref-memory,
		localstate,
		cindex[if(input(genData))],
		input[/if] with 

	[generateGlobalConstants(genData)/]
	functions
		INVOP : IJ → [if(input(genData))]input[else][inputType(genData)/][/if] ×  memory ×  Localstate ×  memory ×  Localstate → bool;
		COP : CJ → memory × Localstate × memory × Localstate → bool;
[let returnTransitions : Sequence(Transition) = getAllReturnTransitions(genData)]
	[if(returnTransitions->size() > 0)]
		RETOP : RJ → memory × Localstate × memory × Localstate × [if(getAllReturnVariables(genData)->size()>0)][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if] → bool;
	[/if]
	predicates
		LSInit : Localstate × PID;
		GSInit : memory;
	variables
		invop : [if(input(genData))]input[else][inputType(genData)/][/if] × memory × Localstate × memory × Localstate → bool;
		cop : memory × Localstate × memory × Localstate → bool;
	[if(returnTransitions->size() > 0)]
		retop : memory × Localstate × memory × Localstate × [if(getAllReturnVariables(genData)->size()>0)][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if] → bool;
		[/if]
		mem' : memory;
[if(input(genData)._not())]
		inp : [inputType(genData)/];
[/if][if(returnTransitions->size() > 0)]
		return : [if(getAllReturnVariables(genData)->size() > 0)][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if];
[/if][/let]
	axioms

	LSInit : ⊦ LSInit(ls, p) ↔ ls .pc = N ∧ ls .pid = p;
	used for : s, ls;

	[for (cfg : ControlFlowDiagram | genData.cfgs)] 
;; 	[generateCfgLabel(genData, cfg)/] reflects function [cfg.name/]
	[generateCfgLabel(genData, cfg)/]ini :
	⊦ INVOP([generateCfgLabel(genData, cfg)/]ini)(inp, mem, ls, mem', ls') ↔ ls .pc = N [if(input(genData))][let params : OrderedSet(AddressMapping) = genData.getFilteredAddresses('func-params:'+cfg.name)->select(name.equalsIgnoreCase('returnvalue')._not())][if(params->size()>0)]∧ [for(am : AddressMapping | params->select(type.equalsIgnoreCase(genData.basis())))][am.type/][/for][for(am : AddressMapping | params->select(type.equalsIgnoreCase('ref')))][am.type/][/for]?(inp) [/if][/let][/if]∧ ls' = ls .pc:= [generateStartPC(genData, cfg)/] [generateFunctionParameter(cfg, genData)/]∧ mem' = mem; 
	used for : s, ls;

	[/for]
	[for (transition : Transition | getAllCopTransitions(genData))]
;;	[transition.createComment()/]
	[transition.label/] :
	⊦ COP([transition.label/])(mem, ls, mem', ls') ↔ ls .pc = [genData.generatePrevPC(genData, transition)/] ∧ [transition.transformTransition(genData)/];
	used for : s, ls;

	[/for]
	[for (transition : Transition | getAllReturnTransitions(genData))]
;;	[transition.createComment()/]
	[transition.label/]ret :
	⊦ RETOP([transition.label/]ret)(mem, ls, mem', ls', return) ↔ ls .pc = [genData.generatePrevPC(genData, transition)/] ∧ ls' = ls .pc:= N[generateReturn(genData, transition.instruction.oclAsType(Return))/] ∧ mem' = mem;
	used for : s, ls;
	
	[/for]
end enrich
		
[/file]
[/template]

[template private generateLocalstateFile(genData: GeneratorData)]
[file ( 'specs/localstate.utf8', false, 'UTF-8')]
data specification
	using [basis(genData)/]ref, PC, PID
	Localstate :=mkls( . .pc : PC; . .pid : PID;
					[for(variable: Variable | getAllLocalAndParameterVariables(genData)->select(newName.equalsIgnoreCase('returnvalue')._not()))]
					. .[variable.newName/] : [variable.type/];
					[/for]);
	variables
		ls , ls' : Localstate;
end data specification
[/file]
[/template]

[template private generatePIDFile(genData: GeneratorData)]
[file ('specs/PID.utf8', false, 'UTF-8')]
specification
	sorts
		PID;
	variables
		p : PID;
end specification
[/file]
[/template]


[template private generateFunctionParameter(cfg: ControlFlowDiagram, genData : GeneratorData)]
[for(am : AddressMapping | genData.getFilteredAddresses('func-params:' + cfg.name)->select(type.equalsIgnoreCase('ref'))->select(name.equalsIgnoreCase('returnvalue')._not()))]
.[am.name/]:= inp [if(input(genData))].[am.type/][i/] [/if][/for][for(am : AddressMapping | genData.getFilteredAddresses('func-params:' + cfg.name)->select(type.equalsIgnoreCase(basis(genData)))->select(name.equalsIgnoreCase('returnvalue')._not()))]
.[am.name/]:= inp [if(genData.transformationSpecificKeys->indexOf('INPUT_REF').oclIsUndefined()._not() and input(genData)._not())].v [/if][if(input(genData))].[am.type/][i/] [/if][/for]
[/template]

[template private generateGlobalConstants(genData : GeneratorData)]
[if(genData.globalVariables->size() > 0)]
constants
[for(variable : Variable| genData.globalVariables)]
	[variable.newName/] : [variable.type/];
[/for][/if]
[/template]


[comment ============================= Transitions=============================================== /]
[template private transformTransition(t: Transition, genData: GeneratorData)]
[let pc : String = generateNextPC(genData, t)]
[if((t.instruction.oclIsUndefined() or t.instruction.oclIsKindOf(Select) or t.instruction.oclIsTypeOf(CompareInt) or t.instruction.oclIsTypeOf(CmpXchg))._not())]ls' = ls .pc:= [pc/][/if][if (t.instruction.oclIsUndefined()._not())][t.instruction.genLsPart(t,genData)/][/if][if(t.instruction.oclIsTypeOf(CmpXchg)._not())][t.genPhiInstruction(genData)/][/if][t.instruction.genMemPart(t,genData)/][/let]
[/template]

[comment === WriteDefChainTransition ====/]
[template private transformTransition(t : WriteDefChainTransition, genData : GeneratorData)]
ls' = ls .pc:= [generateNextPC(genData, t)/][if(t.copyAddress.oclIsUndefined()._not())][transformCopyAddress(t, genData)/][/if][if(t.copyValue.oclIsUndefined()._not())][transformCopyValue(t, genData)/][/if] ∧ mem' = mem
[/template]

[template private transformCopyAddress(t : WriteDefChainTransition, genData : GeneratorData)]
 .[t.copyAddress.addressToString(genData)/]:= ls.[valueToString(t.instruction.oclAsType(Store).targetAddress.value, genData)/]
[/template]

[template private transformCopyValue(t : WriteDefChainTransition, genData : GeneratorData)]
 .[t.copyValue.addressToString(genData)/]:= ls.[valueToString(t.instruction.oclAsType(Store).value.value, genData)/]
[/template]

[comment === Flush ====/]
[template private transformTransition(t: FlushTransition, genData: GeneratorData)]
[let flushed : AddressValuePair = getFlushedAvp(t)]
ls' = ls .pc:= [generateNextPC(genData, t)/] ∧ mem' = mem['[ '/][flushed.address.value.castFromRef(genData)/] ,[flushed.values->first().value.castToRef(genData)/][']'/][/let]
[/template]

[comment === EarlyReadTransition ====/]
[template private transformTransition(t : EarlyReadTransition, genData: GeneratorData)]
ls' = ls .pc:= [generateNextPC(genData, t)/] .[t.instruction.oclAsType(Load).result.addressToString(genData)/]:= [findValueForEarlyReadExpression(t, genData)/] ∧ mem' = mem
[/template]

[template private findValueForEarlyReadExpression(t : EarlyReadTransition, genData : GeneratorData)]
[for (avp: AddressValuePair | t.source.buffer.addressValuePairs)]
[for(parameter : Parameter | avp.values)]
[let v : String = parameter.value.valueToString(genData)]
[let am : AddressMapping = getcorrespondingAddressMapping(t.instruction.oclAsType(Load).result, genData, null)]
[if (parameter.value.oclIsKindOf(IntegerConstant))][let intParam : String = possiblyZeroBeforeMinus(parameter.value.oclAsType(IntegerConstant).value).toString()][if(intParam.equalsIgnoreCase(v))][possiblyCast(parameter.value, am.type, genData)/][/if][/let][else]
[if(t.assignmentExpression.equalsIgnoreCase(v))][possiblyCast(parameter.value, am.type, genData)/][/if][/if][/let][/let][/for][/for]
[/template]

[comment === Return ====/]
[template private generateReturn(genData : GeneratorData, ret : Return)]
[if(ret.value.oclIsTypeOf(Parameter))] ∧ return = [if(genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->first().type.equalsIgnoreCase('ref'))][castToRef(ret.value.oclAsType(Parameter).value, genData)/][else][possiblyAddLS(ret.value.oclAsType(Parameter).value, genData)/][ret.value.oclAsType(Parameter).value.valueToString(genData)/][/if][else]
[if(ret.value.oclAsType(PrimitiveValue).value.equalsIgnoreCase('void')._not())] ∧ return = [ret.value.oclAsType(PrimitiveValue).valueToString(genData)/][/if][/if]
[/template]

[comment ====== Instructions ======/]

[template private genMemPart(e : Instruction, t: Transition, genData : GeneratorData)]
 ∧ mem' = mem
[/template]

[template private genPhiInstruction(t : Transition, genData : GeneratorData)]
[for(map : PhiMapping| genData.phiMappings)][if(map.transition = t)][for(phi : Phi | map.phi)] .[phi.result.addressToString(genData)/]:= [for(case : PhiCase|phi.cases)][if(case.label.replace('%', '').equalsIgnoreCase(map.blockLabelToUse))][for (am: AddressMapping | genData.addressMappings)][for (a: Address | am.adresses)]
[if (phi.result = a)][if(am.type.equalsIgnoreCase('ref'))][castToRef(case.value, genData)/][else][possiblyAddLS(case.value, genData)/][case.value.valueToString(genData)/][/if][/if][/for][/for][/if][/for][/for][/if][/for]
[/template]

[template private genLsPart(e : Instruction, t: Transition, genData : GeneratorData)]
[comment Abstract/]
[/template]

[comment ====== Arithmetic Operation ======/]
[template private genLsPart(e : ArithmeticOperation, t: Transition, genData : GeneratorData)]
[e.arithmeticInstr(e, genData)/]
[/template]

[comment ====== Load ======/]
[template private genLsPart(e : Load, t : Transition, genData : GeneratorData)]
 .[e.result.addressToString(genData)/]:= mem['['/][e.address.value.castFromRef(genData)/][']'/][for (am1: AddressMapping | genData.addressMappings)]
[for (a: Address | am1.adresses)]
[if (e.result = a)][if(am1.type.equalsIgnoreCase('ref')._not())] .v[/if][/if][/for][/for]
[/template]

[comment ====== CompareInt ======/]
[template private genLsPart(e : CompareInt, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)][let res : String = e.result.addressToString(genData)]
[if(e.cond.equalsIgnoreCase('eq'))]([compareTypecorrect(e.operand1, e.operand2, genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ne'))]([compareTypecorrect(e.operand1, e.operand2, genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, genData)/])[else]
[if(e.cond.equalsIgnoreCase('uge')._or(e.cond.equalsIgnoreCase('sge')))]([e.operand1.castFromRef(genData)/] ≥ [e.operand2.castFromRef(genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ugt')._or(e.cond.equalsIgnoreCase('sgt')))]([e.operand1.castFromRef(genData)/] ≤ [e.operand2.castFromRef(genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ult')._or(e.cond.equalsIgnoreCase('slt')))]([e.operand1.castFromRef(genData)/] ≥ [e.operand2.castFromRef(genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ule')._or(e.cond.equalsIgnoreCase('sle')))]([e.operand1.castFromRef(genData)/] ≤ [e.operand2.castFromRef(genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, genData)/])[/if][/if][/if][/if][/if][/if]
[/let][/let]
[/template]

[comment ====== Compare Exchange ======/]
[template private genLsPart(e : CmpXchg, t: Transition, genData : GeneratorData)]
[let res : String = e.result.addressToString(genData)][let adr : String = e.address.value.valueToString(genData)][let pc : String = generateNextPC(genData, t)]
( mem['['/][e.address.value.castFromRef(genData)/][']'/] = [e.value.value.castToRef(genData)/] ⊃ (ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, genData)/][genPhiInstruction(t, genData)/] ∧ mem' = mem['['/][e.address.value.castFromRef(genData)/], [e.newValue.value.castToRef(genData)/][']'/]) ; (ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, genData)/][genPhiInstruction(t, genData)/] ∧ mem' = mem))[/let]
[/let][/let]
[/template]

[template private genMemPart(e : CmpXchg, t: Transition, genData: GeneratorData)]
[/template]

[comment ====== Atomic Read Modify Write ======/]
[template private genLsPart(e : AtomicRMW, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(genData)/]:= mem['['/][e.address.value.castFromRef(genData)/][']'/] .v
[/template]

[template private genMemPart(e: AtomicRMW, t: Transition, genData : GeneratorData)]
[let adr : String = e.address.value.castFromRef(genData)][let arg : String = e.argument.value.valueToString(genData)][let res : String = e.result.addressToString(genData)]
[if(e.operation.equalsIgnoreCase('xchg'))] ∧ mem' = mem['[ '/][adr/], [e.argument.value.castToRef(genData)/][']'/][else]
[if(e.operation.equalsIgnoreCase('add'))] ∧ mem' = mem['[ '/][adr/], ⌜(mem['['/][adr/][']'/] .v) + [possiblyAddLS(e.argument.value, genData)/][arg/]⌝[']'/][else]
[if(e.operation.equalsIgnoreCase('sub'))] ∧ mem' = mem['[ '/][adr/], ⌜(mem['['/][adr/][']'/] .v) - [possiblyAddLS(e.argument.value, genData)/][arg/]⌝[']'/][else]
[if(e.operation.equalsIgnoreCase('max')._or(e.operation.equalsIgnoreCase('umax')))] ∧ (mem['['/][adr/][']'/] > [e.argument.value.castToRef(genData)/] ⊃ mem' = mem ; mem' = mem['[ '/][adr/], [e.argument.value.castToRef(genData)/][']'/])[else]
[if(e.operation.equalsIgnoreCase('min')._or(e.operation.equalsIgnoreCase('umin')))] ∧ (mem['['/][adr/][']'/] < [e.argument.value.castFromRef(genData)/] ⊃ mem' = mem ; mem' = mem['[ '/][adr/], [e.argument.value.castToRef(genData)/][']'/])[else]
unsupported operation
[/if][/if][/if][/if][/if][/let][/let][/let]
[/template]

[comment ====== Branch ======/]
[template private genMemPart(e: Branch, t: Transition, genData : GeneratorData)]
[if(e.condition.oclIsUndefined()._not())] ∧ [for(ct : ConstraintMapping | genData.constraints)][if(ct.transition = t)][if(ct.condition.contains('!')._not())][possiblyAddLS(e.condition, genData)/][e.condition.valueToString(genData)/] = 1[else][possiblyAddLS(e.condition, genData)/][e.condition.valueToString(genData)/] = 0[/if][/if][/for][/if]
[/template]

[comment ====== Get Element Pointer ======/]
[template private genLsPart(e : GetElementPtr, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(genData)/]:= [for(mm : MemorySizeMapping | genData.memorySizeMappings)][if(mm.instruction = e)][let offset : EInt = mm.offset][possiblyCastToRef('('+ e.aggregate.value.castFromRef(genData) +' + '+ offset + ')', e.result, genData)/][/let][/if][/for]
[/template]

[comment ====== Cast ======/]
[template private genLsPart(e : Cast, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(genData)/]:= [for (amRes: AddressMapping | genData.addressMappings)]
[for (ad: Address | amRes.adresses)]
[if (e.result = ad)][e.value.possiblyCast(amRes.type, genData)/][/if][/for][/for]
[/template]

[comment ====== Select ======/]
[template private genLsPart(e : Select, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)]
([possiblyAddLS(e.condition.value, genData)/][e.condition.value.valueToString(genData)/] = 1 ⊃ ls' = ls .pc:= [pc/] .[e.result.addressToString(genData)/]:= [possiblyAddLS(e.trueValue.value, genData)/][e.trueValue.value.valueToString(genData)/] ; ls' = ls .pc:= [pc/] .[e.result.addressToString(genData)/]:= [possiblyAddLS(e.elseValue.value, genData)/][e.elseValue.value.valueToString(genData)/])
[/let]
[/template]

[comment ====== Switch ======/]
[template private genLsPart(e : Switch, t : Transition, genData : GeneratorData)]
 ∧[let cond : String = t.oclAsType(GuardedTransition).condition.substitute('[', '').substitute(']', '').trim()]
[for (case : SwitchCase | e.cases) separator (' ∧')] [possiblyAddLS(e.caseValue.value, genData)/][e.caseValue.value.valueToString(genData)/][if(case.caseValue.value.valueToString(genData).trim().equalsIgnoreCase(cond))] = [cond/][else] ≠ [case.caseValue.value.valueToString(genData).trim()/][/if][/for][/let]
[/template]

[template private genNestedCast(cast : NestedCast, genData : GeneratorData)]
[if(extractType(cast.from).contains('*'))][possiblyCast(cast.value, 'ref', genData)/][else][possiblyCast(cast.value, genData.basis(), genData)/][/if]
[/template]

[comment ====== General Calls ======/]

[query private arithmeticInstr(e : ArithmeticOperation, genData: GeneratorData) : String = 
' .' + e.result.addressToString(genData) + ':= ( ' 
+ possiblyAddLS(e.value1, genData)
+ e.value1.valueToString(genData)
+ ' '
+ e.operation.arithmeticOp() + ' ' 
+ possiblyAddLS(e.value2, genData) 
+ e.value2.valueToString(genData) 
+ ')'
/]

[template private possiblyCast(v: Value, resultType : String, genData : GeneratorData)]
[if (v.oclIsTypeOf(AddressUse))][let am : AddressMapping = getcorrespondingAddressMapping(v.oclAsType(AddressUse).address, genData, null)]
[if (resultType.equalsIgnoreCase(genData.basis()) and am.type.equalsIgnoreCase('ref'))][v.castFromRef(genData)/][elseif(resultType.equalsIgnoreCase('ref') and am.type.equalsIgnoreCase(genData.basis()))]
[v.castToRef(genData)/][else][possiblyAddLS(v, genData)/][v.valueToString(genData)/][/if][/let][elseif(resultType.equalsIgnoreCase('ref'))]
[v.castToRef(genData)/][else][possiblyAddLS(v, genData)/][v.valueToString(genData)/][/if]
[/template]

[query private possiblyCastToRef(s : String, address : Address, genData : GeneratorData) : String =
if (getcorrespondingAddressMapping(address, genData, null).type.equalsIgnoreCase('ref')) then '⌜'+s+'⌝' else s endif/]

[query public valueToString(v : PrimitiveValue, t: Transition, genData: GeneratorData): String = '' + v.value.transformBooleanToNumber() /]

[query public valueToString(v : IntegerConstant, t: Transition, genData: GeneratorData) : String = '' + v.getValueFromConstant() /]

[query public valueToString(v : DecimalConstant, t : Transition, genData: GeneratorData) : String = '' + v.getValueFromConstant() /]

[query public valueToString(v : AddressUse, t : Transition, genData: GeneratorData) : String = 
getVariableForAddress(v.address, t, genData).newName.transformBooleanToNumber()/]

[query public valueToString(v : NestedCast, t : Transition, genData: GeneratorData) : String = genNestedCast(v.oclAsType(NestedCast), genData) /]

[query public valueToString(v : NestedGetElementPtr, t : Transition, genData: GeneratorData) : String = genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), genData) /]

[template private valueToString(v : Value, genData: GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][v.oclAsType(PrimitiveValue).value.transformBooleanToNumber()/][elseif ( v.oclIsKindOf(Constant))]
[v.oclAsType(Constant).getValueFromConstant()/][elseif (v.oclIsTypeOf(AddressUse))]
[for (am: AddressMapping | genData.addressMappings)][for (a: Address | am.adresses)][if (v.oclAsType(AddressUse).address = a)][am.name.transformBooleanToNumber()/][/if][/for][/for][elseif(v.oclIsKindOf(NestedGetElementPtr))]
[genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), genData)/][elseif(v.oclIsKindOf(NestedCast))]
[genNestedCast(v.oclAsType(NestedCast), genData)/][/if]
[/template]

[template private possiblyAddLS(v : Value, genData: GeneratorData)]
[if(v.oclIsTypeOf(AddressUse))]
[for(am : AddressMapping | genData.getFilteredAddresses('all-declare-params'))][for(a: Address | am.adresses)][if(a = v.oclAsType(AddressUse).address)]ls .[/if][/for][/for][/if]
[/template]

[template public castToRef(v : Value, genData : GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][if(v.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[possiblyAddLS(v, genData)/][v.valueToString(genData)/]⌝[/if][elseif ( v.oclIsKindOf(Constant))]
⌜[v.oclAsType(Constant).getValueFromConstant()/]⌝[elseif (v.oclIsTypeOf(AddressUse))]
[let am : AddressMapping = getcorrespondingAddressMapping(v.oclAsType(AddressUse).address, genData, null)]
[let addressName : String = possiblyAddLS(v, genData)+am.name.transformBooleanToNumber()]
[if (am.type.equalsIgnoreCase(genData.basis()))]⌜ [addressName/]⌝[else][addressName/][/if][/let][/let][elseif (v.oclIsTypeOf(NestedGetElementPtr))]
[genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), genData)/][elseif (v.oclIsTypeOf(NestedCast))]
[genNestedCast(v.oclAsType(NestedCast), genData)/][/if]
[/template]

[template public castFromRef(v : Value, genData : GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][possiblyAddLS(v, genData)/][v.oclAsType(PrimitiveValue).value.transformBooleanToNumber()/][elseif ( v.oclIsKindOf(Constant))]
[v.oclAsType(Constant).getValueFromConstant()/][elseif (v.oclIsTypeOf(AddressUse))]
[let am : AddressMapping = getcorrespondingAddressMapping(v.oclAsType(AddressUse).address, genData, null)]
[let addressName : String = possiblyAddLS(v, genData)+am.name.transformBooleanToNumber()]
[if (am.type.equalsIgnoreCase('ref'))][addressName/] .v[else][addressName/][/if][/let][/let][elseif (v.oclIsTypeOf(NestedGetElementPtr))]
[genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), genData)/][elseif (v.oclIsTypeOf(NestedCast))]
[genNestedCast(v.oclAsType(NestedCast), genData)/][/if]
[/template]

[template public genNestedGetElemPtr(nestedPtr : NestedGetElementPtr, genData : GeneratorData)]
([nestedPtr.aggregate.value.castFromRef(genData)/][for(mm : MemorySizeMapping | genData.memorySizeMappings)][if(mm.instruction = nestedPtr)] + [mm.offset/][/if][/for])
[/template]

[template private compareTypecorrect(v1 : Value, v2 : Value, genData : GeneratorData)]
[let ls1 : String = possiblyAddLS(v1, genData)][let ls2 : String = possiblyAddLS(v2, genData)]
[if(v1.oclIsTypeOf(AddressUse) or v2.oclIsTypeOf(AddressUse))]
	[if(v1.oclIsTypeOf(AddressUse))]
		[let am1 : AddressMapping = getcorrespondingAddressMapping(v1.oclAsType(AddressUse).address, genData, null)]
			[if(v2.oclIsTypeOf(AddressUse))]
				[let am2 : AddressMapping = getcorrespondingAddressMapping(v2.oclAsType(AddressUse).address, genData, null)]
					[if(am1.type.equalsIgnoreCase(genData.basis()) and am2.type.equalsIgnoreCase('ref'))]⌜[ls1/][am1.name/]⌝ = [ls2/][am2.name/][else]
					[if(am1.type.equalsIgnoreCase('ref') and am2.type.equalsIgnoreCase(genData.basis()))][ls1/][am1.name/] = ⌜[ls2/][am2.name/]⌝[else][ls1/][am1.name/] = [ls2/][am2.name/]
					[/if][/if]
				[/let]
			[else]
				[if(v2.oclIsTypeOf(PrimitiveValue) and am1.type.equalsIgnoreCase('ref'))][ls1/][am1.name/] = [if(v2.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[ls2/][v2.valueToString(genData)/]⌝[/if][else]
				[if(v2.oclIsKindOf(Constant) and am1.type.equalsIgnoreCase('ref'))][ls1/][am1.name/] = ⌜[v2.oclAsType(Constant).getValueFromConstant()/]⌝[else][ls1/][v1.valueToString(genData)/] = [ls2/][v2.valueToString(genData)/]
				[/if][/if]
			[/if]
		[/let]
	[elseif(v2.oclIsTypeOf(AddressUse))]
		[let am2 : AddressMapping = getcorrespondingAddressMapping(v2.oclAsType(AddressUse).address, genData, null)]
			[if(v1.oclIsTypeOf(PrimitiveValue) and am2.type.equalsIgnoreCase('ref'))][if(v1.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[ls1/][v1.valueToString(genData)/]⌝[/if] = [ls2/][am2.name/][else]
			[if(v1.oclIsKindOf(Constant) and am2.type.equalsIgnoreCase('ref'))]⌜[v1.oclAsType(Constant).getValueFromConstant()/]⌝ = [ls2/][am2.name/][else][ls1/][v1.valueToString(genData)/] = [ls2/][v2.valueToString(genData)/]
			[/if][/if]
		[/let]
	[else][ls1/][v1.valueToString(genData)/] = [ls2/][v2.valueToString(genData)/][/if]
[else][ls1/][v1.valueToString(genData)/] = [ls2/][v2.valueToString(genData)/][/if]
[/let][/let]
[/template]