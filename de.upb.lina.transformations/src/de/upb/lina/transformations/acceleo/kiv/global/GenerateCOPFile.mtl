[comment encoding = UTF-8 /]
[module GenerateCOPFile('http://www.upb.de/lina/cfg/controlflow', 'http://www.upb.de/lina/cfg/gendata', 'http://www.upb.de/llvm_parser/llvm', 'http://www.eclipse.org/emf/2002/Ecore')]
[import de::upb::lina::transformations::acceleo::TransformationCommon/]
[import de::upb::lina::transformations::acceleo::kiv::KivCommon/]

[template public generateCOPFile (genData : GeneratorData) ]
[file ('specs/COP.utf8', false, 'UTF-8')]
enrich 	CS,
		cindex[if(input(genData))],
		input[/if] with 

	functions
		INVOP : Proc × IJ → [if(input(genData))]input[else][inputType(genData)/][/if] × CS × CS → bool;
		COP : Proc × CJ → CS × CS → bool;
[let returnTransitions : Sequence(Transition) = getAllReturnTransitions(genData)]
	[if(not returnTransitions->isEmpty())]
		RETOP : Proc × RJ → CS × CS × [if(not getAllReturnVariables(genData)->isEmpty())][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if] → bool;
[/if]
	predicates
		CSInit : CS;

	variables
		invop : [if(input(genData))]input[else][inputType(genData)/][/if] × CS × CS → bool;
		cop : CS × CS → bool;
[if(not returnTransitions->isEmpty())]
		retop : CS × CS × [if(not getAllReturnVariables(genData)->isEmpty())][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if] → bool;
[/if]		[for(variable: Variable | genData.globalVariables)]
		[variable.newName/], [variable.newName/]' : [variable.type/];
		[/for]
		[if(not input(genData))]
		inp : [inputType(genData)/];
[/if][if(not returnTransitions->isEmpty())]
		return : [if(not getAllReturnVariables(genData)->isEmpty())][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if];
[/if][/let]
	axioms
	CSInit : 
	⊦ CSInit(mkcs([for(variable: Variable | genData.globalVariables)][variable.newName/], [/for]pcf, mem[for(variable: Variable | getAllLocalAndParameterVariables(genData)->select(not newName.equalsIgnoreCase('returnvalue')))], [variable.type/]f[i/][/for])) ↔ ([for(variable: Variable | genData.globalVariables)] [variable.newName/] = [if(variable.type.equalsIgnoreCase('ref'))]⌜0⌝[else]0[/if] ∧[/for] pcf = (λ p. N) [for(variable: Variable | getAllLocalAndParameterVariables(genData)->select(not newName.equalsIgnoreCase('returnvalue')))] ∧ [variable.type/]f[i/] = (λ p. [if(variable.type.equalsIgnoreCase('ref'))]⌜0⌝[else]0[/if])[/for]);
	used for : s, ls;

	[for (cfg : ControlFlowDiagram | genData.cfgs)] 
;; 	[generateCfgLabel(genData, cfg)/] reflects function [cfg.functionDefinition.address.name/]
	[generateCfgLabel(genData, cfg)/]ini :
	⊦ INVOP(p, [generateCfgLabel(genData, cfg)/]ini)(inp, cs, cs') ↔ cs .pc(p) = N [if(input(genData))][let parameterVariables : OrderedSet(Variable) = cfg.parameterVariables->select(not newName.equalsIgnoreCase('returnvalue'))][if(not parameterVariables->isEmpty())]∧ [for(variable : Variable | parameterVariables->select(type.equalsIgnoreCase(genData.basis())))][variable.type/][/for][for(variable : Variable | parameterVariables->select(type.equalsIgnoreCase('ref')))][variable.type/][/for]?(inp) [/if][/let][/if]∧ cs' = cs .pc:= cs.pc(p ; [generateStartPC(genData, cfg)/]) [generateFunctionParameters(cfg, genData)/]; 
	used for : s, ls;

	[/for]
	[for (copTransition : Transition | getAllCopTransitions(genData))]
;;	[copTransition.createComment()/]
	[copTransition.label/] :
	⊦ COP(p, [copTransition.label/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [copTransition.transformTransition(genData)/];
	used for : s, ls;

	[/for]
	[for (returnTransition : Transition | getAllReturnTransitions(genData))]
;;	[returnTransition.createComment()/]
	[returnTransition.label/]ret :
	⊦ RETOP(p, [returnTransition.label/]ret)(cs, cs', return) ↔ cs .pc(p) = [genData.generatePrevPC(genData, returnTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; N)[generateReturn(genData, returnTransition.instruction.oclAsType(Return), returnTransition)/];
	used for : s, ls;
	
	[/for]
end enrich
[/file]

[/template]

[template private generateFunctionParameters(cfg: ControlFlowDiagram, genData : GeneratorData)]
[for(variable : Variable | getParameterVariablesOfTypeExcludingReturnVariables(cfg, 'ref'))]
.[variable.newName/]:= cs.[variable.newName/](p ; inp[if(input(genData))] .[variable.type/][i/][/if])[/for]
[for(variable : Variable | getParameterVariablesOfTypeExcludingReturnVariables(cfg, basis(genData)))]
.[variable.newName/]:= cs.[variable.newName/](p ; inp[if(hasTransformationSpecificKey(genData, 'INPUT_REF') and not input(genData))] .v [/if][if(input(genData))] .[variable.type/][i/][/if])[/for]
[/template]

[comment ============================= Transitions=============================================== /]

[template private transformTransition(t: Transition, genData: GeneratorData)]
[let pc : String = generateNextPC(genData, t)]
[handlePCGeneration(t, pc, genData)/][handleCSPartGeneration(t, pc, genData)/][handlePhiInstructionGeneration(t, pc, genData)/][genMemPart(t.instruction, t ,genData)/][/let]
[/template]

[template private handlePCGeneration(t : Transition, pc : String, genData : GeneratorData)]
[if( canGeneratePCDirectly(t))]cs' = cs .pc:= cs.pc(p ; [pc/])[/if]
[/template]

[query private canGeneratePCDirectly(t : Transition) : Boolean = 
if t.instruction.oclIsUndefined() 
	or t.instruction.oclIsKindOf(Select) 
	or t.instruction.oclIsTypeOf(CompareInt) 
	or t.instruction.oclIsTypeOf(CmpXchg) 
	or t.instruction.oclIsTypeOf(AtomicRmwMax) 
	or t.instruction.oclIsTypeOf(AtomicRmwMin) 
	or t.instruction.oclIsTypeOf(AtomicRmwUmax) 
	or t.instruction.oclIsTypeOf(AtomicRmwUmin) 
then false 
else true endif /]

[template public handleCSPartGeneration (t : Transition, pc : String, genData : GeneratorData) ]
[if (canGenerateCSPart(t))][genCSPart(t.instruction, t, genData)/][/if]
[/template]

[query private canGenerateCSPart(t : Transition) : Boolean = 
if t.instruction.oclIsUndefined() or t.instruction.oclIsTypeOf(AtomicRmwMax) or t.instruction.oclIsTypeOf(AtomicRmwMin) or t.instruction.oclIsTypeOf(AtomicRmwUmax) or t.instruction.oclIsTypeOf(AtomicRmwUmin) 
then false else true endif /]

[template public handlePhiInstructionGeneration (t : Transition, pc : String, genData : GeneratorData) ]
[if(canGeneratePhiInstruction(t))][genPhiInstruction(t, genData)/][/if]
[/template]

[query private canGeneratePhiInstruction(t : Transition) : Boolean = 
if t.instruction.oclIsTypeOf(CmpXchg) or t.instruction.oclIsTypeOf(AtomicRmwMax) or t.instruction.oclIsTypeOf(AtomicRmwMin) or t.instruction.oclIsTypeOf(AtomicRmwUmax) or t.instruction.oclIsTypeOf(AtomicRmwUmin) 
then false else true endif /]

[comment]Returns the proper address access expression for the given addres based on if it a local address or a global one.[/comment]
[query private getAddressAccessExpression(address : Address, transition : Transition, s : String, genData : GeneratorData) : String = 
if isLocalAddress(address, genData) then 
	'cs.' + addressToString(address, transition, genData) + '(p ; ' + s + ')'
else 
	s
endif
/]

[comment]Checks whether the given address is a local adress or a global one. Returns true if it is a local one.[/comment]
[query private isLocalAddress(a : Address, genData : GeneratorData) : Boolean = if genData.globalVariables->select(originalAddresses->indexOf(a) > 0)->isEmpty() then true else false endif/]


[comment === WriteDefChainTransition ====/]
[template private transformTransition(t : WriteDefChainTransition, genData : GeneratorData)]
cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, t)/])[if(not t.copyAddress.oclIsUndefined())][transformCopyAddress(t, genData)/][/if][if(not t.copyValue.oclIsUndefined())][transformCopyValue(t, genData)/][/if]
[/template]

[template private transformCopyAddress(t : WriteDefChainTransition, genData : GeneratorData)]
 .[addressToString(t.copyAddress, t, genData)/]:= [getAddressAccessExpression(t.copyAddress, t, 'cs.' + t.instruction.oclAsType(Store).targetAddress.value.valueToString(t, genData), genData)/]
[/template]

[template private transformCopyValue(t : WriteDefChainTransition, genData : GeneratorData)]
 .[addressToString(t.copyValue, t, genData)/]:= [getAddressAccessExpression(t.copyValue, t, 'cs.' + t.instruction.oclAsType(Store).value.value.valueToString(t, genData), genData)/]
[/template]

[comment === Flush ====/]
[template private transformTransition(t: FlushTransition, genData: GeneratorData)]
cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, t)/]) .mem:= cs.mem['[ '/][castFromRef(t.flushedEntry.address.value, t, genData)/] ,[castToRef(t.flushedEntry.values->first().value, t, genData)/][']'/]
[/template]

[comment === EarlyReadTransition ====/]
[template private transformTransition(t : EarlyReadTransition, genData: GeneratorData)]
cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, t)/]) .[addressToString(t.instruction.oclAsType(Load).result, t, genData)/]:= [findValueForEarlyReadExpression(t, genData)/]
[/template]

[template private findValueForEarlyReadExpression(t : EarlyReadTransition, genData : GeneratorData)]
[for (avp: AddressValuePair | t.source.buffer.addressValuePairs)]
[for(parameter : Parameter | avp.values)]
[let v : String = parameter.value.valueToString(t, genData)]
[let am : Variable = getVariableForAddress(t.instruction.oclAsType(Load).result, t, genData)]
[if (parameter.value.oclIsKindOf(IntegerConstant))][let intParam : String = possiblyZeroBeforeMinus(parameter.value.oclAsType(IntegerConstant).value).toString()][if(intParam.equalsIgnoreCase(v))][getAddressAccessExpression(t.instruction.oclAsType(Load).result, t, possiblyCast(parameter.value, t, am.type, genData), genData)/][/if][/let][else]
[if(t.assignmentExpression.concat('(p)').equalsIgnoreCase(v) or t.assignmentExpression.equalsIgnoreCase(v))][getAddressAccessExpression(t.instruction.oclAsType(Load).result, t, possiblyCast(parameter.value, t, am.type, genData), genData)/][/if][/if][/let][/let][/for][/for]
[/template]



[comment ============================== Instructions ==================================================/]
[template private genMemPart(e : Instruction, t: Transition, genData : GeneratorData)]
[/template]

[template private genPhiInstruction(t : Transition, genData : GeneratorData)]
[for(map : PhiMapping| genData.phiMappings)][if(map.transition = t)][for(phi : Phi | map.phi)] .[addressToString(phi.result, t, genData)/]:= [for(case : PhiCase|phi.cases)]
[if(case.label.replace('%', '').equalsIgnoreCase(map.blockLabelToUse))][let am : Variable = getVariableForAddress(phi.result, t, genData)]
[if(am.type.equalsIgnoreCase('ref'))][getAddressAccessExpression(phi.result, t, castToRef(case.value, t, genData), genData)/][else][getAddressAccessExpression(phi.result, t, possiblyAddCS(case.value, genData)+case.value.valueToString(t, genData), genData)/][/if][/let][/if][/for][/for][/if][/for]
[/template]

[template private genCSPart(e : Instruction, t: Transition, genData : GeneratorData)]
[comment Abstract/]
[/template]

[template private genCSPart(e : ArithmeticOperation, t: Transition, genData : GeneratorData)]
 .[addressToString(e.result, t, genData)/]:= [getAddressAccessExpression(e.result, t, possiblyAddCS(e.value1, genData)+e.value1.valueToString(t, genData)+' '+e.operation.arithmeticOp()+' '+possiblyAddCS(e.value2, genData)+e.value2.valueToString(t, genData), genData)/]
[/template]

[template private genCSPart(e : Load, t : Transition, genData : GeneratorData)]
 .[addressToString(e.result, t, genData)/]:= [if(not getVariableForAddress(e.result, t, genData).type.equalsIgnoreCase('ref'))][getAddressAccessExpression(e.result, t, 'cs.mem['+castFromRef(e.address.value , t, genData)+'] .v', genData)/][else][getAddressAccessExpression(e.result, t, 'cs.mem[' + castFromRef(e.address.value, t, genData)+']', genData)/][/if]
[/template]

[template private genCSPart(e : CompareInt, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)][let res : String = addressToString(e.result, t, genData)]
[if(e.cond.equalsIgnoreCase('eq'))]([compareTypecorrect(e.operand1, t, e.operand2, t, genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ne'))]([compareTypecorrect(e.operand1, t, e.operand2, t, genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('uge')._or(e.cond.equalsIgnoreCase('sge')))]([castFromRef(e.operand1, t, genData)/] ≥ [castFromRef(e.operand2, t, genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0', e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ugt')._or(e.cond.equalsIgnoreCase('sgt')))]([castFromRef(e.operand1, t, genData)/] ≤ [castFromRef(e.operand2, t, genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1', e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ult')._or(e.cond.equalsIgnoreCase('slt')))]([castFromRef(e.operand1, t, genData)/] ≥ [castFromRef(e.operand2, t, genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1', e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ule')._or(e.cond.equalsIgnoreCase('sle')))]([castFromRef(e.operand1, t, genData)/] ≤ [castFromRef(e.operand2, t, genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0', e.result, t, genData)/])[/if][/if][/if][/if][/if][/if]
[/let][/let]
[/template]

[template private genCSPart(e : CmpXchg, t: Transition, genData : GeneratorData)]
[let res : String = addressToString(e.result, t, genData)][let adr : String = e.address.value.valueToString(t, genData)][let pc : String = generateNextPC(genData, t)]
( cs.mem['['/][castFromRef(e.address.value, t, genData)/][']'/] = [castToRef(e.value.value, t, genData)/] ⊃ (cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1', e.result, t, genData)/][genPhiInstruction(t, genData)/] .mem:= cs.mem['['/][castFromRef(e.address.value, t, genData)/], [castToRef(e.newValue.value, t, genData)/][']'/]) ; (cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0', e.result, t, genData)/][genPhiInstruction(t, genData)/]))[/let]
[/let][/let]
[/template]

[template private genCSPart(e : AtomicRMW, t: Transition, genData: GeneratorData)]
 .[addressToString(e.result, t, genData)/]:= [getAddressAccessExpression(e.result, t, 'cs.mem [' + castFromRef(e.address.value, t, genData) + '] .v', genData)/]
[let adr : String = castFromRef(e.address.value, t, genData)][let arg : String = e.argument.value.valueToString(t, genData)]
[if(e.operation.equalsIgnoreCase('xchg'))] .mem:= cs.mem['[ '/][adr/], [castToRef(e.argument.value, t, genData)/][']'/][else]
[if(e.operation.equalsIgnoreCase('add'))] .mem:= cs.mem['[ '/][adr/], ⌜(cs.mem['['/][adr/][']'/] .v) + [possiblyAddCS(e.argument.value, genData)/][arg/]⌝[']'/][else]
[if(e.operation.equalsIgnoreCase('sub'))] .mem:= cs.mem['[ '/][adr/], ⌜(cs.mem['['/][adr/][']'/] .v) - [possiblyAddCS(e.argument.value, genData)/][arg/]⌝[']'/][else]unsupported operation[/if][/if][/if][/let][/let]
[/template]

[template private genMemPart(e: AtomicRMW, t: Transition, genData : GeneratorData)]
[let adr : String = castFromRef(e.address.value, t, genData)][let pc : String = generateNextPC(genData, t)]
[if(e.operation.equalsIgnoreCase('max')._or(e.operation.equalsIgnoreCase('umax')))](cs.mem['['/][adr/][']'/] .v > [castFromRef(e.argument.value, t, genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/])[genPhiInstruction(t, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/])[genPhiInstruction(t, genData)/] .mem:= cs.mem['[ '/][adr/], [castToRef(e.argument.value, t, genData)/][']'/])[else]
[if(e.operation.equalsIgnoreCase('min')._or(e.operation.equalsIgnoreCase('umin')))](cs.mem['['/][adr/][']'/] .v < [castFromRef(e.argument.value, t, genData)/] ⊃ cs' = cs .pc:= cs.pc(p; [pc/])[genPhiInstruction(t, genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/])[genPhiInstruction(t, genData)/] .mem:= cs.mem['[ '/][adr/], [castToRef(e.argument.value, t, genData)/][']'/])
[/if][/if][/let][/let]
[/template]

[template private genMemPart(e: Branch, t: Transition, genData : GeneratorData)]
[if(e.condition.oclIsUndefined()._not())] ∧ [for(ct : ConstraintMapping | genData.constraints)][if(ct.transition = t)][if(ct.condition.contains('!')._not())][possiblyAddCS(e.condition, genData)/][e.condition.valueToString(t, genData)/] = 1[else][possiblyAddCS(e.condition, genData)/][e.condition.valueToString(t, genData)/] = 0[/if][/if][/for][/if]
[/template]

[template private genCSPart(e : GetElementPtr, t: Transition, genData: GeneratorData)]
 .[addressToString(e.result, t, genData)/]:= [for(mm : MemorySizeMapping | genData.memorySizeMappings)][if(mm.instruction = e)][let offset : EInt = mm.offset][possiblyCastToRef('('+ castFromRef(e.aggregate.value, t, genData) +' + '+ offset + ')', e.result, t, genData)/][/let][/if][/for]
[/template]

[template private genCSPart(e : Cast, t: Transition, genData: GeneratorData)]
 .[addressToString(e.result, t, genData)/]:= [let variable : Variable = getVariableForAddress(e.result, t, genData)]
[getAddressAccessExpression(e.result, t, possiblyCast(e.value, t, variable.type, genData), genData)/][/let]
[/template]

[template private genCSPart(e : Select, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)]
([castFromRef(e.condition.value, t, genData)/] = 1 ⊃ cs' = cs .pc:= cs.pc(p; [pc/]) .[addressToString(e.result, t, genData)/]:= [getAddressAccessExpression(e.result, t, possiblyCast(e.trueValue.value, t, getVariableForAddress(e.result, t, genData).type, genData), genData)/] ; cs' = cs .pc:= cs.pc(p; [pc/]) .[addressToString(e.result, t, genData)/]:= [getAddressAccessExpression(e.result, t, possiblyCast(e.elseValue.value, t, getVariableForAddress(e.result, t, genData).type, genData), genData)/])[/let]
[/template]

[template private genCSPart(e : Switch, t : Transition, genData : GeneratorData)]
 ∧[let cond : String = t.oclAsType(GuardedTransition).condition.substitute('[', '').substitute(']', '').trim()]
[for (case : SwitchCase | e.cases) separator (' ∧')] [possiblyAddCS(e.caseValue.value, genData)/][e.caseValue.value.valueToString(t, genData)/][if(case.caseValue.value.valueToString(t, genData).trim().equalsIgnoreCase(cond))] = [cond/][else] ≠ [case.caseValue.value.valueToString(t, genData).trim()/][/if][/for][/let]
[/template]

[template private genNestedCast(cast : NestedCast, t : Transition, genData : GeneratorData)]
[if(extractType(cast.from).contains('*'))][possiblyCast(cast.value, t, 'ref', genData)/][else][possiblyCast(cast.value, t, genData.basis(), genData)/][/if]
[/template]

[template private genNestedGetElemPtr(nestedPtr : NestedGetElementPtr, t : Transition, genData : GeneratorData)]
([castFromRef(nestedPtr.aggregate.value, t, genData)/][for(mm : MemorySizeMapping | genData.memorySizeMappings)][if(mm.instruction = nestedPtr)] + [mm.offset/][/if][/for])
[/template]

[comment ================================ Return =================================================/]

[template private generateReturn(genData : GeneratorData, ret : Return, t : Transition)]
[if(ret.value.oclIsTypeOf(Parameter))] ∧ return = [if(genData.addressMappings->select(name.equalsIgnoreCase('returnvalue'))->first().type.equalsIgnoreCase('ref'))][castToRef(ret.value.oclAsType(Parameter).value, t, genData)/][else][possiblyAddCS(ret.value.oclAsType(Parameter).value, genData)/][ret.value.oclAsType(Parameter).value.valueToString(t, genData)/][/if][else]
[if(ret.value.oclAsType(PrimitiveValue).value.equalsIgnoreCase('void')._not())] ∧ return = [ret.value.oclAsType(PrimitiveValue).valueToString(t, genData)/][/if][/if]
[/template]

[comment ====== General Calls ======/]
[template private possiblyCastToRef(s : String, address : Address, t : Transition, genData : GeneratorData)]
[let am : Variable = getVariableForAddress(address, t, genData)][if(am.type.equalsIgnoreCase('ref'))][getAddressAccessExpression(address, t, '⌜'+s+'⌝', genData)/][else][getAddressAccessExpression(address, t, s, genData)/][/if][/let]
[/template]

[query private possiblyAddCS(v : Value, genData: GeneratorData) : String = if v.oclIsTypeOf(AddressUse) then 'cs .' else '' endif /]

[template private valueToString(v : Value, t : Transition, genData: GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][v.oclAsType(PrimitiveValue).value.transformBooleanToNumber()/][elseif ( v.oclIsKindOf(Constant))]
[v.oclAsType(Constant).getValueFromConstant()/][elseif (v.oclIsTypeOf(AddressUse))]
[let am : Variable = getVariableForAddress(v.oclAsType(AddressUse).address, t, genData)][am.newName.transformBooleanToNumber()/][if(isLocalAddress(v.oclAsType(AddressUse).address,genData))](p)[/if][/let][elseif(v.oclIsKindOf(NestedGetElementPtr))]
[genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), t, genData)/][elseif(v.oclIsKindOf(NestedCast))]
[genNestedCast(v.oclAsType(NestedCast), t, genData)/][/if]
[/template]

[template public castToRef(v : Value, t : Transition, genData : GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][if(v.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[possiblyAddCS(v, genData)/][v.valueToString(t, genData)/]⌝[/if][elseif ( v.oclIsKindOf(Constant))]
⌜[v.oclAsType(Constant).getValueFromConstant()/]⌝[elseif (v.oclIsTypeOf(AddressUse))]
[let am : Variable = getVariableForAddress(v.oclAsType(AddressUse).address, t, genData)]
[let addressName : String = possiblyAddCS(v, genData)+v.valueToString(t, genData).transformBooleanToNumber()]
[if (am.type.equalsIgnoreCase(genData.basis()))]⌜ [addressName/]⌝[else][addressName/][/if][/let][/let][elseif (v.oclIsTypeOf(NestedGetElementPtr))]
[genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), t, genData)/][elseif (v.oclIsTypeOf(NestedCast))]
[genNestedCast(v.oclAsType(NestedCast), t, genData)/][/if]
[/template]

[template public castFromRef(v : Value, t : Transition, genData : GeneratorData)]
[if (v.oclIsTypeOf(PrimitiveValue))][possiblyAddCS(v, genData)/][v.oclAsType(PrimitiveValue).value.transformBooleanToNumber()/][elseif ( v.oclIsKindOf(Constant))]
[v.oclAsType(Constant).getValueFromConstant()/][elseif (v.oclIsTypeOf(AddressUse))]
[let am : Variable = getVariableForAddress(v.oclAsType(AddressUse).address, t, genData)]
[let addressName : String = possiblyAddCS(v, genData)+v.valueToString(t, genData).transformBooleanToNumber()]
[if (am.type.equalsIgnoreCase('ref'))][addressName/] .v[else][addressName/][/if][/let][/let][elseif (v.oclIsTypeOf(NestedGetElementPtr))]
[genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), t, genData)/][elseif (v.oclIsTypeOf(NestedCast))]
[genNestedCast(v.oclAsType(NestedCast), t, genData)/][/if]
[/template]

[template private compareTypecorrect(v1 : Value, t1 : Transition, v2 : Value, t2 :Transition, genData : GeneratorData)]
[let cs1 : String = possiblyAddCS(v1, genData)][let cs2 : String = possiblyAddCS(v2, genData)]
[let s1 : String = cs1+valueToString(v1, t1, genData)][let s2 : String = cs2+valueToString(v2, t2, genData)]
[if(v1.oclIsTypeOf(AddressUse) or v2.oclIsTypeOf(AddressUse))]
	[if(v1.oclIsTypeOf(AddressUse))][let am1 : Variable = getVariableForAddress(v1.oclAsType(AddressUse).address, t1, genData)]
		[if(v2.oclIsTypeOf(AddressUse))][let am2 : Variable = getVariableForAddress(v2.oclAsType(AddressUse).address, t2, genData)]
			[if(am1.type.equalsIgnoreCase(genData.basis()) and am2.type.equalsIgnoreCase('ref'))]⌜[s1/]⌝ = [s2/][else]
			[if(am1.type.equalsIgnoreCase('ref') and am2.type.equalsIgnoreCase(genData.basis()))][s1/] = ⌜[s2/]⌝[else][s1/] = [s2/]
			[/if][/if][/let]
		[else]
			[if(v2.oclIsTypeOf(PrimitiveValue) and am1.type.equalsIgnoreCase('ref'))][s1/] = [if(v2.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[s2/]⌝[/if][else]
			[if(v2.oclIsKindOf(Constant) and am1.type.equalsIgnoreCase('ref'))][s1/] = ⌜[v2.oclAsType(Constant).getValueFromConstant()/]⌝[else][s1/] = [s2/]
			[/if][/if]
		[/if][/let]
	[elseif(v2.oclIsTypeOf(AddressUse))][let am2 : Variable = getVariableForAddress(v2.oclAsType(AddressUse).address, t2, genData)]
		[if(v1.oclIsTypeOf(PrimitiveValue) and am2.type.equalsIgnoreCase('ref'))][if(v1.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[s1/]⌝[/if] = [s2/][else]
		[if(v1.oclIsKindOf(Constant) and am2.type.equalsIgnoreCase('ref'))]⌜[v1.oclAsType(Constant).getValueFromConstant()/]⌝ = [s2/][else][s1/] = [s2/]
		[/if][/if][/let]
	[else][s1/] = [s2/][/if]
[else][s1/] = [s2/][/if]
[/let][/let][/let][/let]
[/template]

[template private possiblyCast(v: Value, t : Transition, resultType : String, genData : GeneratorData)]
[if (v.oclIsTypeOf(AddressUse))][let am : Variable = getVariableForAddress(v.oclAsType(AddressUse).address, t, genData)]
[if (resultType.equalsIgnoreCase(genData.basis()) and am.type.equalsIgnoreCase('ref'))][castFromRef(v, t, genData)/][elseif(resultType.equalsIgnoreCase('ref') and am.type.equalsIgnoreCase(genData.basis()))]
[castToRef(v, t, genData)/][else][possiblyAddCS(v, genData)/][valueToString(v, t, genData)/][/if][/let]
[elseif(resultType.equalsIgnoreCase('ref'))][castToRef(v, t, genData)/][else][possiblyAddCS(v, genData)/][valueToString(v, t, genData)/][/if]
[/template]
