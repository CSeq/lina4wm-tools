[comment encoding = UTF-8 /]
[module GenerateCOPFile('http://www.upb.de/lina/cfg/controlflow', 'http://www.upb.de/lina/cfg/gendata', 'http://www.upb.de/llvm_parser/llvm', 'http://www.eclipse.org/emf/2002/Ecore')]
[import de::upb::lina::transformations::acceleo::TransformationCommon/]
[import de::upb::lina::transformations::acceleo::kiv::KivCommon/]

[template public generateCOPFile (genData : GeneratorData) ]
[file ('specs/COP.utf8', false, 'UTF-8')]
enrich 	CS,
		cindex[if(input(genData))],
		input[/if] with 

	functions
		INVOP : Proc × IJ → [if(input(genData))]input[else][inputType(genData)/][/if] × CS × CS → bool;
		COP : Proc × CJ → CS × CS → bool;
[let returnTransitions : Sequence(Transition) = getAllReturnTransitions(genData)]
	[if(not returnTransitions->isEmpty())]
		RETOP : Proc × RJ → CS × CS × [if(not getAllReturnVariables(genData)->isEmpty())][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if] → bool;
[/if]
	predicates
		CSInit : CS;

	variables
		invop : [if(input(genData))]input[else][inputType(genData)/][/if] × CS × CS → bool;
		cop : CS × CS → bool;
[if(not returnTransitions->isEmpty())]
		retop : CS × CS × [if(not getAllReturnVariables(genData)->isEmpty())][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if] → bool;
[/if]		[for(variable: Variable | genData.globalVariables)]
		[variable.newName/], [variable.newName/]' : [variable.type/];
		[/for]
		[if(not input(genData))]
		inp : [inputType(genData)/];
[/if][if(not returnTransitions->isEmpty())]
		return : [if(not getAllReturnVariables(genData)->isEmpty())][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if];
[/if][/let]
	axioms
	CSInit : 
	⊦ CSInit(mkcs([for(variable: Variable | genData.globalVariables)][variable.newName/], [/for]pcf, mem[for(variable: Variable | getAllLocalAndParameterVariables(genData)->select(not newName.equalsIgnoreCase('returnvalue')))], [variable.type/]f[i/][/for])) ↔ ([for(variable: Variable | genData.globalVariables)] [variable.newName/] = [if(variable.type.equalsIgnoreCase('ref'))]⌜0⌝[else]0[/if] ∧[/for] pcf = (λ p. N) [for(variable: Variable | getAllLocalAndParameterVariables(genData)->select(not newName.equalsIgnoreCase('returnvalue')))] ∧ [variable.type/]f[i/] = (λ p. [if(variable.type.equalsIgnoreCase('ref'))]⌜0⌝[else]0[/if])[/for]);
	used for : s, ls;

[transformINVOPTransitions()/]
[transformCOPTransitions(genData)/]
[transformRETOPTransitions(genData)/]
end enrich
[/file]
[/template]

[template public transformINVOPTransitions (genData : GeneratorData) ]
	[for (cfg : ControlFlowDiagram | genData.cfgs)] 
;; 	[generateCfgLabel(genData, cfg)/] reflects function [cfg.functionDefinition.address.name/]
	[generateCfgLabel(genData, cfg)/]ini :
	⊦ INVOP(p, [generateCfgLabel(genData, cfg)/]ini)(inp, cs, cs') ↔ cs .pc(p) = N [if(input(genData))][let parameterVariables : OrderedSet(Variable) = cfg.parameterVariables->select(not newName.equalsIgnoreCase('returnvalue'))][if(not parameterVariables->isEmpty())]∧ [for(variable : Variable | parameterVariables->select(type.equalsIgnoreCase(genData.basis())))][variable.type/][/for][for(variable : Variable | parameterVariables->select(type.equalsIgnoreCase('ref')))][variable.type/][/for]?(inp) [/if][/let][/if]∧ cs' = cs .pc:= cs.pc(p ; [generateStartPC(genData, cfg)/]) [generateFunctionParameters(cfg, genData)/]; 
	used for : s, ls;

	[/for]
[/template]

[template public transformRETOPTransitions (genData : GeneratorData) ]
	[for (returnTransition : Transition | getAllReturnTransitions(genData))]
;;	[returnTransition.createComment()/]
	[returnTransition.label/]ret :
	⊦ RETOP(p, [returnTransition.label/]ret)(cs, cs', return) ↔ cs .pc(p) = [genData.generatePrevPC(genData, returnTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; N)[generateReturn(genData, returnTransition.instruction.oclAsType(Return), returnTransition)/];
	used for : s, ls;

	[/for]
[/template]

[template public generateTransitionCommentLabelAndDefaultBeginning(copTransition : Transition, genData : GeneratorData)]
;;	[copTransition.createComment()/]
	[copTransition.label/] :
	⊦ COP(p, [copTransition.label/])(cs, cs') ↔ cs .pc(p) = 
[/template]

[template public transformCOPTransitions (genData : GeneratorData) ]
[for (copTransition : Transition | getAllCopTransitions(genData))]
[if(not copTransition.instruction.oclIsUndefined())]
[transformCOPTransition(copTransition, copTransition.instruction, genData)/]
[else]
[transformCOPTransition(copTransition, genData)/]
[/if]

[/for]
[/template]


[comment]:::::::::::======== COP Transition Transformation ========:::::::::::[/comment]
[template public transformCOPTransition (copTransition : Transition, instruction : Instruction, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/]) [genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[comment]======== GetElementPtr ========[/comment]
[template public transformCOPTransition (copTransition : Transition, getElementPtr : GetElementPtr, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/]) [generateGetElementPtrCSPart(copTransition, getElementPtr, genData)/] [genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[query private generateGetElementPtrCSPart(transition : Transition, getElementPtr : GetElementPtr, genData : GeneratorData) : String = 
'.' + addressToString(getElementPtr.result, transition, genData) + ':=' + possiblyCastToRef('('+ castFromRef(getElementPtr.aggregate.value, transition, genData) +' + '+ genPtrOffset(getElementPtr, 'cs.', '(p)', transition, genData) + ')', getElementPtr.result, transition, genData)
/]

[query private findMemorySizeMappingForInstruction(pInstruction : EObject, genData : GeneratorData) : MemorySizeMapping = 
	genData.memorySizeMappings->any(instruction = pInstruction)
/]

[comment]======== Load ========[/comment]
[template public transformCOPTransition (copTransition : Transition, load : Load, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/])[generateLoadCSPart(copTransition, load, genData)/][genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[query private generateLoadCSPart(transition : Transition, load : Load, genData : GeneratorData): String =
	' .' + addressToString(load.result, transition, genData) + ':= ' + 
	if(not getVariableForAddress(load.result, transition, genData).type.equalsIgnoreCase('ref')) then
		getAddressAccessExpression(load.result, transition, 'cs.mem[' + castFromRef(load.address.value, transition, genData)+'] .v', genData)
	else
		getAddressAccessExpression(load.result, transition, 'cs.mem[' + castFromRef(load.address.value, transition, genData)+']', genData)
	endif
/]

[comment]======== Branch ========[/comment]
[template public transformCOPTransition (copTransition : Transition, branch : Branch, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/])[genPhiInstruction(copTransition, genData)/][generateBranchSpecificPart(copTransition, branch, genData)/];
	used for : s, ls;
[/template]

[query private generateBranchSpecificPart(transition : Transition, branch : Branch, genData : GeneratorData) : String = 
	if(not branch.condition.oclIsUndefined()) then
		generateBranchMemPart(transition.oclAsType(GuardedTransition), branch, genData)
	else
		''
	endif
/]

[query private generateBranchMemPart(guardedTransition : GuardedTransition, branch : Branch, genData : GeneratorData): String = 
	' ∧ ' + possiblyAddCS(branch.condition, genData) 
		+ branch.condition.valueToString(guardedTransition, genData) +
		if(guardedTransition.condition.contains('!')) then 
			' = 0' 
		else
			' = 1'
		endif
/]

[comment]======== Switch ========[/comment]
[template public transformCOPTransition (copTransition : Transition, switch : Switch, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/]) [generateSwitchCSPart(switch, copTransition.oclAsType(GuardedTransition), genData)/] [genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[template private generateSwitchCSPart(switch : Switch, guardedTransition : GuardedTransition, genData : GeneratorData)]
 ∧[for (case : SwitchCase | switch.cases) separator (' ∧')][generateSwitchCSPartForSingleCase(switch, case, guardedTransition, genData)/][/for]
[/template]

[query private getTransitionConditionWithoutBrackets(guardedTransition: GuardedTransition) : String = 
	guardedTransition.condition.substitute('[', '').substitute(']', '').trim()
/]

[query private generateSwitchCSPartForSingleCase(switch : Switch, case : SwitchCase, guardedTransition : GuardedTransition, genData : GeneratorData) : String = 
	let cleanedCondition : String = getTransitionConditionWithoutBrackets(guardedTransition) in	
		possiblyAddCS(switch.caseValue.value, genData) +  switch.caseValue.value.valueToString(guardedTransition, genData) + 
		if(case.caseValue.value.valueToString(guardedTransition, genData).trim().equalsIgnoreCase(cleanedCondition)) then
			'=' + cleanedCondition 
		else 
			'≠' + case.caseValue.value.valueToString(guardedTransition, genData).trim()
		endif
/]

[comment]======== Cast ========[/comment]
[template public transformCOPTransition (copTransition : Transition, cast : Cast, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/])[generateCastCSPart(cast, copTransition, genData)/][genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[query private generateCastCSPart(cast : Cast, transition : Transition, genData : GeneratorData) : String = 
 ' .' + addressToString(cast.result, transition, genData) + ':= ' 
	 + getAddressAccessExpression(cast.result, transition, possiblyCast(cast.value, transition, getVariableForAddress(cast.result, transition, genData).type, genData), genData)
/]

[comment]======== Arithmetic Operation ========[/comment]
[template public transformCOPTransition (copTransition : Transition, arithmeticOperation : ArithmeticOperation, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/])[generateArithmeticOperationCSPart(arithmeticOperation, copTransition, genData)/][genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[query private generateArithmeticOperationCSPart(arithmeticOperation : ArithmeticOperation, transition : Transition, genData : GeneratorData) : String = 
	' .' + addressToString(arithmeticOperation.result, transition, genData) + ':= ' 
		+ getAddressAccessExpression(arithmeticOperation.result, transition, possiblyAddCS(arithmeticOperation.value1, genData) 
																			 + arithmeticOperation.value1.valueToString(transition, genData) 
																			 + ' ' + arithmeticOperation.operation.arithmeticOp() 
																			 + ' ' + possiblyAddCS(arithmeticOperation.value2, genData) 
																			 + arithmeticOperation.value2.valueToString(transition, genData)
		 							, genData)
/]

[template private genCSPart(e : ArithmeticOperation, t: Transition, genData : GeneratorData)]
 .[addressToString(e.result, t, genData)/]:= [getAddressAccessExpression(e.result, t, possiblyAddCS(e.value1, genData)+e.value1.valueToString(t, genData)+' '+e.operation.arithmeticOp()+' '+possiblyAddCS(e.value2, genData)+e.value2.valueToString(t, genData), genData)/]
[/template]

[comment]======== CmpXchg ========[/comment]
[template public transformCOPTransition (copTransition : Transition, compareExchange : CmpXchg, genData : GeneratorData) ]
;;	[copTransition.createComment()/] _ positive case
	[getPositiveLabelForTransition(copTransition)/] :
	⊦ COP(p, [getPositiveLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generatePositiveCompareExchangeCsPart(copTransition, compareExchange, genData)/];
	used for : s, ls;

;;	[copTransition.createComment()/] _ negative case
	[getNegativeLabelForTransition(copTransition)/] :
	⊦ COP(p, [getNegativeLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generateNegativeCompareExchangeCsPart(copTransition, compareExchange, genData)/];
	used for : s, ls;
[/template]

[query private generatePositiveCompareExchangeCsPart(transition : Transition, compareExchange : CmpXchg, genData : GeneratorData) : String =
	' cs.mem[' + castFromRef(compareExchange.address.value, transition, genData) + '] = ' + castToRef(compareExchange.value.value, transition, genData) + ' ∧ cs\' = cs .pc:= cs.pc(p; ' + generateNextPC(genData, transition) + ') .' + addressToString(compareExchange.result, transition, genData) + ':= ' + possiblyCastToRef('1', compareExchange.result, transition, genData) + genPhiInstruction(transition, genData) + ' .mem:= cs.mem[' + castFromRef(compareExchange.address.value, transition, genData) + ','  + castToRef(compareExchange.newValue.value, transition, genData) + '] '
/]

[query private generateNegativeCompareExchangeCsPart(transition : Transition, compareExchange : CmpXchg, genData : GeneratorData) : String =
	' cs.mem[' + castFromRef(compareExchange.address.value, transition, genData) + '] ≠ ' + castToRef(compareExchange.value.value, transition, genData) + ' ∧ cs\' = cs .pc:= cs.pc(p; ' + generateNextPC(genData, transition) + ') .' + addressToString(compareExchange.result, transition, genData) + ':= ' + possiblyCastToRef('0', compareExchange.result, transition, genData) + genPhiInstruction(transition, genData)
/]

[comment]======== Select ========[/comment]
[template public transformCOPTransition (copTransition : Transition, select : Select, genData : GeneratorData) ]
;;	[copTransition.createComment()/] _ positive case
	[getPositiveLabelForTransition(copTransition)/] :
	⊦ COP(p, [getPositiveLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧  [generatePositiveSelectCSPart(copTransition, select, genData)/] [genPhiInstruction(copTransition, genData)/];
	used for : s, ls;

;;	[copTransition.createComment()/] _ negative case
	[getNegativeLabelForTransition(copTransition)/] :
	⊦ COP(p, [getNegativeLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧  [generateNegativeSelectCSPart(copTransition, select, genData)/] [genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[query private generatePositiveSelectCSPart(transition : Transition, select : Select, genData : GeneratorData) : String = 
	castFromRef(select.condition.value, transition, genData) + '= 1' + ' ∧ cs\' = cs .pc:= cs.pc(p; ' + generateNextPC(genData, transition) + ') .' + addressToString(select.result, transition, genData) + ':= '+ getAddressAccessExpression(select.result, transition, possiblyCast(select.trueValue.value, transition, getVariableForAddress(select.result, transition, genData).type, genData), genData)
/]

[query private generateNegativeSelectCSPart(transition : Transition, select : Select, genData : GeneratorData) : String = 
	castFromRef(select.condition.value, transition, genData) + '≠ 1' + ' ∧ cs\' = cs .pc:= cs.pc(p;' +  generateNextPC(genData, transition) + ') .' + addressToString(select.result, transition, genData) + ':= ' + getAddressAccessExpression(select.result, transition, possiblyCast(select.elseValue.value, transition, getVariableForAddress(select.result, transition, genData).type, genData), genData)
/]

[comment]======== AtomicRMW (exclusive min, umin, max and umax) ========[/comment]
[comment]Note that this block catches all AtmicRMW instructions, except for the min and max operators. 
Those ones have to be treated differently, as they change the control flow, while the other operators are simpler.[/comment]
[template public transformCOPTransition (copTransition : Transition, atomicRMW : AtomicRMW, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/]) [generateAtomicRMWCSAndMemPart(atomicRMW, copTransition, genData)/] [genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[query private generateAtomicRMWCSAndMemPart(atomicRMW : AtomicRMW, transition : Transition, genData : GeneratorData) : String = 
	'.' + addressToString(atomicRMW.result, transition, genData) + ':= ' 
		+ getAddressAccessExpression(atomicRMW.result, transition, 'cs.mem [' + castFromRef(atomicRMW.address.value, transition, genData) + '] .v', genData)	
		+ '\n' + generateAtomicRMWMEMPart(atomicRMW, transition, genData)
/]

[comment]Fallback template for unsupported atomic rmw types[/comment]
[query private generateAtomicRMWMEMPart(atomicRMW : AtomicRMW, transition : Transition, genData : GeneratorData) : String = 
 'unsupported operation'
/]

[query private generateAtomicRMWMEMPart(atomicRMWXchg : AtomicRmwXchg, transition : Transition, genData : GeneratorData) : String = 
 '.mem:= cs.mem[' + castFromRef(atomicRMWXchg.address.value, transition, genData) + ', ' + castToRef(atomicRMWXchg.argument.value, transition, genData) + ']'
/]

[query private generateAtomicRMWMEMPart(atomicRMWAdd : AtomicRmwAdd, transition : Transition, genData : GeneratorData) : String = 
 '.mem:= cs.mem[' + castFromRef(atomicRMWAdd.address.value, transition, genData) 
				  + ', ⌜(cs.mem[' + castFromRef(atomicRMWAdd.address.value, transition, genData) + '] .v) + ' 
				  + possiblyAddCS(atomicRMWAdd.argument.value, genData) +  atomicRMWAdd.argument.value.valueToString(transition, genData) 
		   		  + '⌝]'
/]

[query private generateAtomicRMWMEMPart(atomicRMWSub : AtomicRmwSub, transition : Transition, genData : GeneratorData) : String = 
 '.mem:= cs.mem[' + castFromRef(atomicRMWSub.address.value, transition, genData) 
				  + ', ⌜(cs.mem[' + castFromRef(atomicRMWSub.address.value, transition, genData) + '] .v) - ' 
				  + possiblyAddCS(atomicRMWSub.argument.value, genData) +  atomicRMWSub.argument.value.valueToString(transition, genData) 
				  + '⌝]'
/]

[comment]======== AtomicRMW (only min, umin, max and umax) ========[/comment]
[comment]This block offers special treatment for min and max operators of the AtmoricRMW instruction, as they change the control flow
and therefore need special handling. In particular, we need two KIV COP transitions for each of these instructions.[/comment]

[comment]== AtomicRmwUmin and AtomicRmwMin ==[/comment]
[template public transformCOPTransition (copTransition : Transition, atomicRMWUmin : AtomicRmwUmin, genData : GeneratorData) ]
;;	[copTransition.createComment()/] _ positive case
	[getPositiveLabelForTransition(copTransition)/] :
	⊦ COP(p, [getPositiveLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generatePositiveCSAndMemPartForAtomicRMWMin(atomicRMWUmin, copTransition, genData)/];
	used for : s, ls;

;;	[copTransition.createComment()/] _ negative case
	[getNegativeLabelForTransition(copTransition)/] :
	⊦ COP(p, [getNegativeLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generateNegativeCSAndMemPartForAtomicRMWMin(atomicRMWUmin, copTransition, genData)/];
	used for : s, ls;
[/template]

[template public transformCOPTransition (copTransition : Transition, atomicRMWmin : AtomicRmwMin, genData : GeneratorData) ]
;;	[copTransition.createComment()/] _ positive case
	[getPositiveLabelForTransition(copTransition)/]:
	⊦ COP(p, [getPositiveLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generatePositiveCSAndMemPartForAtomicRMWMin(atomicRMWmin, copTransition, genData)/];
	used for : s, ls;

;;	[copTransition.createComment()/] _ negative case
	[getNegativeLabelForTransition(copTransition)/] :
	⊦ COP(p, [getNegativeLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generateNegativeCSAndMemPartForAtomicRMWMin(atomicRMWmin, copTransition, genData)/];
	used for : s, ls;
[/template]

[query private generatePositiveCSAndMemPartForAtomicRMWMin(atomicRMW : AtomicRMW, transition : Transition, genData : GeneratorData) : String = 
 'cs.mem[' + castFromRef(atomicRMW.address.value, transition, genData) + '] .v < ' 
		+ castFromRef(atomicRMW.argument.value, transition, genData) 
		+ '∧ cs\' = cs .pc:= cs.pc(p; ' + generateNextPC(genData, transition) + ')' + genPhiInstruction(transition, genData)
/]

[query private generateNegativeCSAndMemPartForAtomicRMWMin(atomicRMW : AtomicRMW, transition : Transition, genData : GeneratorData) : String = 
 'cs.mem[' + castFromRef(atomicRMW.address.value, transition, genData) + '] .v ≥ ' 
		+ castFromRef(atomicRMW.argument.value, transition, genData) + '∧ cs\' = cs .pc:= cs.pc(p; ' 
		+ generateNextPC(genData, transition) + ')' + genPhiInstruction(transition, genData) 
		+ '.mem:= cs.mem[' + castFromRef(atomicRMW.address.value, transition, genData) + ', ' 
		+ castToRef(atomicRMW.argument.value, transition, genData) + ']'
/]

[comment]== AtomicRmwUmax and AtomicRmwMax ==[/comment]
[template public transformCOPTransition (copTransition : Transition, atomicRMWUmax : AtomicRmwUmax, genData : GeneratorData) ]
;;	[copTransition.createComment()/] _ positive case
	[getPositiveLabelForTransition(copTransition)/]:
	⊦ COP(p, [getPositiveLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generatePositiveCSAndMemPartForAtomicRMWMax(atomicRMWUmax, copTransition, genData)/];
	used for : s, ls;

;;	[copTransition.createComment()/] _ negative case
	[getNegativeLabelForTransition(copTransition)/] :
	⊦ COP(p, [getNegativeLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generateNegativeCSAndMemPartForAtomicRMWMax(atomicRMWUmax, copTransition, genData)/];
	used for : s, ls;
[/template]

[template public transformCOPTransition (copTransition : Transition, atomicRMWmax : AtomicRmwMax, genData : GeneratorData) ]
;;	[copTransition.createComment()/] _ positive case
	[getPositiveLabelForTransition(copTransition)/] :
	⊦ COP(p, [getPositiveLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generatePositiveCSAndMemPartForAtomicRMWMax(atomicRMWmax, copTransition, genData)/];
	used for : s, ls;
;;	[copTransition.createComment()/] _ negative case
	[getNegativeLabelForTransition(copTransition)/] :
	⊦ COP(p, [getNegativeLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generateNegativeCSAndMemPartForAtomicRMWMax(atomicRMWmax, copTransition, genData)/];
	used for : s, ls;
[/template]

[query private generatePositiveCSAndMemPartForAtomicRMWMax(atomicRMW : AtomicRMW, transition : Transition, genData : GeneratorData) : String = 
 'cs.mem[' + castFromRef(atomicRMW.address.value, transition, genData) + '] .v > ' 
		+ castFromRef(atomicRMW.argument.value, transition, genData) 
		+ '∧ cs\' = cs .pc:= cs.pc(p; ' + generateNextPC(genData, transition) + ')' + genPhiInstruction(transition, genData)
/]

[query private generateNegativeCSAndMemPartForAtomicRMWMax(atomicRMW : AtomicRMW, transition : Transition, genData : GeneratorData) : String = 
 'cs.mem[' + castFromRef(atomicRMW.address.value, transition, genData) + '] .v ≤ ' 
		+ castFromRef(atomicRMW.argument.value, transition, genData) + '∧ cs\' = cs .pc:= cs.pc(p; ' 
		+ generateNextPC(genData, transition) + ')' + genPhiInstruction(transition, genData) 
		+ '.mem:= cs.mem[' + castFromRef(atomicRMW.address.value, transition, genData) + ', ' 
		+ castToRef(atomicRMW.argument.value, transition, genData) + ']'
/]

[comment]======== Compare ========[/comment]
[template public transformCOPTransition (copTransition : Transition, compare : Compare, genData : GeneratorData) ]
;;	[copTransition.createComment()/] _ positive case
	[getPositiveLabelForTransition(copTransition)/] :
	⊦ COP(p, [getPositiveLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generatePositiveCompareCSPart(compare, copTransition, genData)/] [genPhiInstruction(copTransition, genData)/];
	used for : s, ls;

;;	[copTransition.createComment()/] _ negative case
	[getNegativeLabelForTransition(copTransition)/] :
	⊦ COP(p, [getNegativeLabelForTransition(copTransition)/])(cs, cs') ↔ cs .pc(p) = [genData.generatePrevPC(genData, copTransition)/] ∧ [generateNegativeCompareCSPart(compare, copTransition, genData)/] [genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[template private generatePositiveCompareCSPart(e : Compare, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)][let res : String = addressToString(e.result, t, genData)]
[if(e.cond.equalsIgnoreCase('eq'))]([compareTypecorrect(e.operand1, t, e.operand2, t, genData)/] ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/] [else]
[if(e.cond.equalsIgnoreCase('ne'))](¬([compareTypecorrect(e.operand1, t, e.operand2, t, genData)/]) ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/] [else]
[if(e.cond.equalsIgnoreCase('uge') or e.cond.equalsIgnoreCase('sge'))]([castFromRef(e.operand1, t, genData)/] ≥ [castFromRef(e.operand2, t, genData)/] ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/] [else]
[if(e.cond.equalsIgnoreCase('ugt') or e.cond.equalsIgnoreCase('sgt'))]([castFromRef(e.operand1, t, genData)/] > [castFromRef(e.operand2, t, genData)/] ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/] [else]
[if(e.cond.equalsIgnoreCase('ult') or e.cond.equalsIgnoreCase('slt'))]([castFromRef(e.operand1, t, genData)/] < [castFromRef(e.operand2, t, genData)/] ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/] [else]
[if(e.cond.equalsIgnoreCase('ule') or e.cond.equalsIgnoreCase('sle'))]([castFromRef(e.operand1, t, genData)/] ≤ [castFromRef(e.operand2, t, genData)/] ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/] [/if][/if][/if][/if][/if][/if]
[/let][/let]
[/template]

[template private generateNegativeCompareCSPart(e : Compare, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)][let res : String = addressToString(e.result, t, genData)]
[if(e.cond.equalsIgnoreCase('eq'))](¬([compareTypecorrect(e.operand1, t, e.operand2, t, genData)/]) ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ne'))]([compareTypecorrect(e.operand1, t, e.operand2, t, genData)/] ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('uge') or e.cond.equalsIgnoreCase('sge'))]([castFromRef(e.operand1, t, genData)/] < [castFromRef(e.operand2, t, genData)/] ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0', e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ugt') or e.cond.equalsIgnoreCase('sgt'))]([castFromRef(e.operand1, t, genData)/] ≤ [castFromRef(e.operand2, t, genData)/] ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1', e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ult') or e.cond.equalsIgnoreCase('slt'))]([castFromRef(e.operand1, t, genData)/] ≥ [castFromRef(e.operand2, t, genData)/] ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('1', e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ule') or e.cond.equalsIgnoreCase('sle'))]([castFromRef(e.operand1, t, genData)/] > [castFromRef(e.operand2, t, genData)/] ∧ cs' = cs .pc:= cs.pc(p; [pc/]) .[res/]:= [possiblyCastToRef('0', e.result, t, genData)/])[/if][/if][/if][/if][/if][/if]
[/let][/let]
[/template]

[comment]======== Store ========[/comment]
[template public transformCOPTransition (copTransition : Transition, store : Store, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/])[genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[comment]======== Invoke ========[/comment]
[template public transformCOPTransition (copTransition : Transition, invoke : Invoke, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/])[genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[comment]======== Call ========[/comment]
[template public transformCOPTransition (copTransition : Transition, call : Call, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/])[genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[comment]======== Fence ========[/comment]
[template public transformCOPTransition (copTransition : Transition, fence : Fence, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/])[genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[comment]======== Phi ========[/comment]
[template public transformCOPTransition (copTransition : Transition, phi : Phi, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(copTransition, genData)/][genData.generatePrevPC(genData, copTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, copTransition)/])[genPhiInstruction(copTransition, genData)/];
	used for : s, ls;
[/template]

[comment]TODO: FIX PROBLEM WITH ORIGINAL ADDRESSES - HOW TO FIND THE OLD ONE?[/comment]
[template private genPhiInstruction(t : Transition, genData : GeneratorData)]
[for(phiAssignment : PhiAssignment | t.phiAssignments)] .[phiAssignment.variable.newName/]:= [if(phiAssignment.variable.type.equalsIgnoreCase('ref'))][getAddressAccessExpression(phiAssignment.variable.originalAddresses->first(), t, castToRef(phiAssignment.value, t, genData), genData)/][else][getAddressAccessExpression(phiAssignment.variable.originalAddresses->first(), t, possiblyAddCS(phiAssignment.value , genData)+phiAssignment.value.valueToString(t, genData), genData)/][/if][/for]
[/template]


[comment]:::::::::::======== Special COP Transition Transformation ========:::::::::::[/comment]
[comment]======== Write Def Chain Transformation ========[/comment]
[template public transformCOPTransition (writeDefChainTransition : WriteDefChainTransition, store : Store, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(writeDefChainTransition, genData)/][generatePrevPC(genData, writeDefChainTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, writeDefChainTransition)/])[if(not writeDefChainTransition.copyAddress.oclIsUndefined())][transformCopyAddress(writeDefChainTransition, store, genData)/][/if][if(not writeDefChainTransition.copyValue.oclIsUndefined())][transformCopyValue(writeDefChainTransition, store, genData)/][/if];
	used for : s, ls;
[/template]

[template private transformCopyAddress(t : WriteDefChainTransition, store : Store,  genData : GeneratorData)]
 .[addressToString(t.copyAddress, t, genData)/]:= [getAddressAccessExpression(t.copyAddress, t, 'cs.' + valueToString(store.targetAddress.value, t, genData), genData)/]
[/template]

[template private transformCopyValue(t : WriteDefChainTransition, store : Store, genData : GeneratorData)]
 .[addressToString(t.copyValue, t, genData)/]:= [getAddressAccessExpression(t.copyValue, t, 'cs.' + valueToString(store.value.value, t, genData), genData)/]
[/template]

[comment]======== Early Read Transformation ========[/comment]
[template public transformCOPTransition (earlyReadTransition : EarlyReadTransition, load : Load, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(earlyReadTransition, genData)/][genData.generatePrevPC(genData, earlyReadTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, earlyReadTransition)/]) .[addressToString(earlyReadTransition.instruction.oclAsType(Load).result, earlyReadTransition, genData)/]:= [getAssignmentExpressionOfEarlyRead(earlyReadTransition, load, genData)/];
	used for : s, ls;
[/template]

[query private getAssignmentExpressionOfEarlyRead(earlyReadTransition : EarlyReadTransition, load : Load, genData : GeneratorData) : String = 
	getAddressAccessExpression(load.result, earlyReadTransition, possiblyCast(getParameterOfBufferEntryReadByEarlyRead(earlyReadTransition).value, earlyReadTransition, getVariableForAddress(load.result, earlyReadTransition, genData).type, genData), genData)
/]

[comment]======== Flush Transformation ========[/comment]
[template public transformCOPTransition (flushTransition : FlushTransition, genData : GeneratorData) ]
[generateTransitionCommentLabelAndDefaultBeginning(flushTransition, genData)/][genData.generatePrevPC(genData, flushTransition)/] ∧ cs' = cs .pc:= cs.pc(p ; [generateNextPC(genData, flushTransition)/]) .mem:= cs.mem['[ '/][castFromRef(flushTransition.flushedEntry.address.value, flushTransition, genData)/] ,[castToRef(flushTransition.flushedEntry.values->first().value, flushTransition, genData)/][']'/];
	used for : s, ls;
[/template]

[comment] Transition with a null instruction, which cannot be handled[/comment]
[template public transformCOPTransition (transition : Transition, genData : GeneratorData) ]
ERROR - DETECTED NORMAL TRANSITION WITH NULL INSTRUCTION
[/template]


[comment]======== Helper Methods ========[/comment]

[template private generateReturn(genData : GeneratorData, ret : Return, t : Transition)]
[if(ret.value.oclIsTypeOf(Parameter))] ∧ return = [if(getAllReturnVariables(genData)->first().type.equalsIgnoreCase('ref'))][castToRef(ret.value.oclAsType(Parameter).value, t, genData)/][else][possiblyAddCS(ret.value.oclAsType(Parameter).value, genData)/][ret.value.oclAsType(Parameter).value.valueToString(t, genData)/][/if][else]
[if(ret.value.oclAsType(PrimitiveValue).value.equalsIgnoreCase('void')._not())] ∧ return = [ret.value.oclAsType(PrimitiveValue).valueToString(t, genData)/][/if][/if]
[/template]

[template private generateFunctionParameters(cfg: ControlFlowDiagram, genData : GeneratorData)]
[for(variable : Variable | getParameterVariablesOfTypeExcludingReturnVariables(cfg, 'ref'))]
.[variable.newName/]:= cs.[variable.newName/](p ; inp[if(input(genData))] .[variable.type/][i/][/if])[/for]
[for(variable : Variable | getParameterVariablesOfTypeExcludingReturnVariables(cfg, basis(genData)))]
.[variable.newName/]:= cs.[variable.newName/](p ; inp[if(hasTransformationSpecificKey(genData, 'INPUT_REF') and not input(genData))] .v [/if][if(input(genData))] .[variable.type/][i/][/if])[/for]
[/template]

[query private possiblyAddCS(v : Value, genData: GeneratorData) : String = 
	if v.oclIsTypeOf(AddressUse) then 
		'cs .' 
	else 	
		'' 
	endif 
/]

[query private possiblyAddP(addressUse : AddressUse, transition : Transition, genData : GeneratorData): String = 
	if isVariableOfLocalAddress(getVariableForAddress(addressUse.address, transition, genData), genData) then
		'(p)'
	else
		''
	endif
/]

[comment]Returns the proper address access expression for the given address based on if it a local address or a global one.[/comment]
[query private getAddressAccessExpression(address : Address, transition : Transition, s : String, genData : GeneratorData) : String = 
	if isVariableOfLocalAddress(getVariableForAddress(address, transition, genData), genData) then 
		'cs.' + addressToString(address, transition, genData) + '(p ; ' + s + ')'
	else 
		s
	endif
/]

[comment]Checks whether the given variable is linked to a local or global address. Returns true if it is a local one.[/comment]
[query private isVariableOfLocalAddress(variable : Variable, genData : GeneratorData) : Boolean = 
	if genData.globalVariables->indexOf(variable)->oclIsUndefined() then 
		true 
	else 
		false 
	endif
/]

[comment]:::::::::::======== Casting and Type Comparison Operations ========:::::::::::[/comment]
[query private possiblyCastToRef(s : String, address : Address, t : Transition, genData : GeneratorData) : String = 
	if(getVariableForAddress(address, t, genData).type.equalsIgnoreCase('ref')) then
		getAddressAccessExpression(address, t, '⌜'+s+'⌝', genData)
	else
		getAddressAccessExpression(address, t, s, genData)
	endif
/]

[query private possiblyCast(value : Value, transition : Transition, resultType : String, genData : GeneratorData) : String = 
	if isAddressUse(value) then 
		let am : Variable = getVariableForAddress(value.oclAsType(AddressUse).address, transition, genData) in
			if resultType.equalsIgnoreCase(basis(genData)) and am.type.equalsIgnoreCase('ref') then
				castFromRef(value, transition, genData)
			else 
				if resultType.equalsIgnoreCase('ref') and am.type.equalsIgnoreCase(basis(genData)) then
					castToRef(value, transition, genData)
				else
					possiblyAddCS(value, genData) + valueToString(value, transition, genData)
				endif
			endif
	else
		if resultType.equalsIgnoreCase('ref') then
			castToRef(value, transition, genData)
		else
			possiblyAddCS(value, genData) + valueToString(value, transition, genData)
		endif	
	endif				
/]

[comment]TODO: FIX THIS[/comment]
[template private compareTypecorrect(v1 : Value, t1 : Transition, v2 : Value, t2 :Transition, genData : GeneratorData)]
[let cs1 : String = possiblyAddCS(v1, genData)][let cs2 : String = possiblyAddCS(v2, genData)]
[let s1 : String = cs1+valueToString(v1, t1, genData)][let s2 : String = cs2+valueToString(v2, t2, genData)]
[if(v1.oclIsTypeOf(AddressUse) or v2.oclIsTypeOf(AddressUse))]
	[if(v1.oclIsTypeOf(AddressUse))][let am1 : Variable = getVariableForAddress(v1.oclAsType(AddressUse).address, t1, genData)]
		[if(v2.oclIsTypeOf(AddressUse))][let am2 : Variable = getVariableForAddress(v2.oclAsType(AddressUse).address, t2, genData)]
			[if(am1.type.equalsIgnoreCase(genData.basis()) and am2.type.equalsIgnoreCase('ref'))]⌜[s1/]⌝ = [s2/][else]
			[if(am1.type.equalsIgnoreCase('ref') and am2.type.equalsIgnoreCase(genData.basis()))][s1/] = ⌜[s2/]⌝[else][s1/] = [s2/]
			[/if][/if][/let]
		[else]
			[if(v2.oclIsTypeOf(PrimitiveValue) and am1.type.equalsIgnoreCase('ref'))][s1/] = [if(v2.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[s2/]⌝[/if][else]
			[if(v2.oclIsKindOf(Constant) and am1.type.equalsIgnoreCase('ref'))][s1/] = ⌜[v2.oclAsType(Constant).getValueFromConstant()/]⌝[else][s1/] = [s2/]
			[/if][/if]
		[/if][/let]
	[elseif(v2.oclIsTypeOf(AddressUse))][let am2 : Variable = getVariableForAddress(v2.oclAsType(AddressUse).address, t2, genData)]
		[if(v1.oclIsTypeOf(PrimitiveValue) and am2.type.equalsIgnoreCase('ref'))][if(v1.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[s1/]⌝[/if] = [s2/][else]
		[if(v1.oclIsKindOf(Constant) and am2.type.equalsIgnoreCase('ref'))]⌜[v1.oclAsType(Constant).getValueFromConstant()/]⌝ = [s2/][else][s1/] = [s2/]
		[/if][/if][/let]
	[else][s1/] = [s2/][/if]
[else][s1/] = [s2/][/if]
[/let][/let][/let][/let]
[/template]
[comment]======== CastToRef Implementation ========[/comment]
[template private castToRef(value : Value, transition : Transition, genData : GeneratorData)]
//NOT SUPPORTED
[/template]

[template private castToRef(primitiveValue : PrimitiveValue, transition : Transition, genData : GeneratorData)]
[castPrimitiveValueToRef(primitiveValue, transition, genData)/]
[/template]

[query private castPrimitiveValueToRef(primitiveValue : PrimitiveValue, transition : Transition, genData : GeneratorData) : String = 
	if(primitiveValue.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null')) then 
		'null'
	else
		'⌜' + possiblyAddCS(primitiveValue, genData) + valueToString(primitiveValue, transition, genData) + '⌝'
	endif
/]

[template private castToRef(constant : Constant, transition : Transition, genData : GeneratorData)]
[castConstantToRef(constant, transition, genData)/]
[/template]

[query private castConstantToRef(v : Constant, t: Transition, genData : GeneratorData) : String = 
	'⌜' + v.oclAsType(Constant).getValueFromConstant() + '⌝'
/]

[template private castToRef(addressUse : AddressUse, transition : Transition, genData : GeneratorData)]
[castAddressUseToRef(addressUse, transition, genData)/]
[/template]

[query private castAddressUseToRef(addressUse : AddressUse, transition : Transition, genData : GeneratorData) : String = 
let variable : Variable = getVariableForAddress(addressUse.address, transition, genData) in 
	let addressName : String = possiblyAddCS(addressUse, genData) + variable.newName + possiblyAddP(addressUse, transition, genData) in
		if variable.type.equalsIgnoreCase(genData.basis()) then 
			'⌜' + addressName + '⌝'
		else
			addressName
		endif
/]

[template private castToRef(nestedGetElementPointer : NestedGetElementPtr, transition : Transition, genData : GeneratorData)]
[nestedGetElementPointerToString(nestedGetElementPointer, transition, genData)/]
[/template]

[query private nestedGetElementPointerToString(nestedGetElementPointer : NestedGetElementPtr, transition : Transition, genData : GeneratorData) : String = 
	'(' + castFromRef(nestedGetElementPointer.aggregate.value, transition, genData) + ' + '
		+ genPtrOffset(nestedGetElementPointer, 'cs.', '(p)', transition, genData) + ')'		
/]

[template private castToRef(nestedCast : NestedCast, transition : Transition, genData : GeneratorData)]
[nestedCastToString(nestedCast, transition, genData)/]
[/template]

[query private nestedCastToString(nestedCast : NestedCast, transition : Transition, genData : GeneratorData) : String = 
	if(extractType(nestedCast.from).contains('*')) then 
		possiblyCast(nestedCast.value, transition, 'ref', genData) 
	else
		possiblyCast(nestedCast.value, transition, genData.basis(), genData)
	endif
/]

[comment]======== CastFromRef Implementation ========[/comment]

[template private castFromRef(value : Value, transition : Transition, genData : GeneratorData)]
//NOT SUPPORTED
[/template]
[template private castFromRef(primitiveValue : PrimitiveValue, transition : Transition, genData : GeneratorData)]
[possiblyAddCS(primitiveValue, genData)/][primitiveValue.value.transformBooleanToNumber()/]
[/template]

[template private castFromRef(constant : Constant, transition : Transition, genData : GeneratorData)]
[getValueFromConstant(constant)/]
[/template]

[template private castFromRef(addressUse : AddressUse, transition : Transition, genData : GeneratorData)]
[castAddressUseFromRef(addressUse, transition, genData)/]
[/template]

[query private castAddressUseFromRef(addressUse : AddressUse, transition: Transition, genData : GeneratorData) : String = 
	let variable : Variable = getVariableForAddress(addressUse.address, transition, genData) in
		let addressName : String = possiblyAddCS(addressUse, genData) + variable.newName + possiblyAddP(addressUse, transition, genData) in
			if (variable.type.equalsIgnoreCase('ref')) then
				addressName + ' .v'
			else
				addressName
			endif
/]

[template private castFromRef(nestedGetElementPointer : NestedGetElementPtr, transition : Transition, genData : GeneratorData)]
[nestedGetElementPointerToString(nestedGetElementPointer, transition, genData)/]
[/template]

[template private castFromRef(nestedCast : NestedCast, transition : Transition, genData : GeneratorData)]
[nestedCastToString(nestedCast, transition, genData)/]
[/template]

[comment]Specialized value to string methods[/comment]

[query public valueToString(v : Value, t : Transition, genData: GeneratorData) : String = 
if v.oclIsTypeOf(PrimitiveValue) then 
	primitiveValueToString(v.oclAsType(PrimitiveValue), t, genData)
else if v.oclIsTypeOf(IntegerConstant) then 
	integerConstantToString(v.oclAsType(IntegerConstant), t, genData)
else if v.oclIsTypeOf(DecimalConstant) then 
	decimalConstantToString(v.oclAsType(DecimalConstant), t, genData)
else if v.oclIsTypeOf(AddressUse) then 
	addressUseToString(v.oclAsType(AddressUse), t, genData)
else if v.oclIsTypeOf(NestedGetElementPtr) then 
	nestedGetElementPointerToString(v.oclAsType(NestedGetElementPtr), t, genData)
else if v.oclIsTypeOf(NestedCast) then 
	nestedCastToString(v.oclAsType(NestedCast), t, genData)
else 
	'FIXME, THIS NEVER HAPPENED BEFORE'
endif
endif
endif
endif
endif
endif
 /]

[query public primitiveValueToString(v : PrimitiveValue, t: Transition, genData: GeneratorData): String = 
	'' + transformBooleanToNumber(v.value) 
/]

[query public integerConstantToString(v : IntegerConstant, t: Transition, genData: GeneratorData) : String = 
	'' + v.getValueFromConstant() 
/]

[query public decimalConstantToString(v : DecimalConstant, t : Transition, genData: GeneratorData) : String = 
	'' + v.getValueFromConstant() 
/]

[query public addressUseToString(addressUse : AddressUse, transition : Transition, genData: GeneratorData) : String = 
	getVariableForAddress(addressUse.address, transition, genData).newName + possiblyAddP(addressUse, transition, genData)
/]




