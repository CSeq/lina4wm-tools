[comment encoding = UTF-8 /]
[module GenerateCOPFile('http://www.upb.de/lina/cfg/controlflow', 'http://www.upb.de/lina/cfg/gendata', 'http://www.upb.de/llvm_parser/llvm', 'http://www.eclipse.org/emf/2002/Ecore')]
[import de::upb::lina::transformations::acceleo::TransformationCommon/]
[import de::upb::lina::transformations::acceleo::kiv::KivCommon/]

[template public generateCOPFile(genData: GeneratorData)]
[file ('specs/COP.utf8', false, 'UTF-8')]
enrich 	[basis(genData)/]ref-memory,
		localstate,
		cindex[if(input(genData))],
		input[/if] with 

	[generateGlobalConstants(genData)/]
	functions
		INVOP : IJ → [if(input(genData))]input[else][inputType(genData)/][/if] ×  memory ×  Localstate ×  memory ×  Localstate → bool;
		COP : CJ → memory × Localstate × memory × Localstate → bool;
[let returnTransitions : Sequence(Transition) = getAllReturnTransitions(genData)]
	[if(returnTransitions->size() > 0)]
		RETOP : RJ → memory × Localstate × memory × Localstate × [if(getAllReturnVariables(genData)->size()>0)][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if] → bool;
	[/if]
	predicates
		LSInit : Localstate × PID;
		GSInit : memory;
	variables
		invop : [if(input(genData))]input[else][inputType(genData)/][/if] × memory × Localstate × memory × Localstate → bool;
		cop : memory × Localstate × memory × Localstate → bool;
	[if(returnTransitions->size() > 0)]
		retop : memory × Localstate × memory × Localstate × [if(getAllReturnVariables(genData)->size()>0)][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if] → bool;
		[/if]
		mem' : memory;
[if(input(genData)._not())]
		inp : [inputType(genData)/];
[/if][if(returnTransitions->size() > 0)]
		return : [if(getAllReturnVariables(genData)->size() > 0)][getAllReturnVariables(genData)->first().type/][else][basis(genData)/][/if];
[/if][/let]
	axioms

	LSInit : ⊦ LSInit(ls, p) ↔ ls .pc = N ∧ ls .pid = p;
	used for : s, ls;

	[for (cfg : ControlFlowDiagram | genData.cfgs)] 
;; 	[generateCfgLabel(genData, cfg)/] reflects function [cfg.functionDefinition.address.name/]
	[generateCfgLabel(genData, cfg)/]ini :
	⊦ INVOP([generateCfgLabel(genData, cfg)/]ini)(inp, mem, ls, mem', ls') ↔ ls .pc = N [if(input(genData))][let params : OrderedSet(Variable) = cfg.parameterVariables->select(name.equalsIgnoreCase('returnvalue')._not())][if(params->size()>0)]∧ [for(variable : Variable | params->select(type.equalsIgnoreCase(genData.basis())))][variable.type/][/for][for(variable : Variable | params->select(type.equalsIgnoreCase('ref')))][variable.type/][/for]?(inp) [/if][/let][/if]∧ ls' = ls .pc:= [generateStartPC(genData, cfg)/] [generateFunctionParameter(cfg, genData)/]∧ mem' = mem; 
	used for : s, ls;

	[/for]
	[for (transition : Transition | getAllCopTransitions(genData))]
;;	[transition.createComment()/]
	[transition.label/] :
	⊦ COP([transition.label/])(mem, ls, mem', ls') ↔ ls .pc = [genData.generatePrevPC(genData, transition)/] ∧ [transition.transformTransition(genData)/];
	used for : s, ls;

	[/for]
	[for (transition : Transition | getAllReturnTransitions(genData))]
;;	[transition.createComment()/]
	[transition.label/]ret :
	⊦ RETOP([transition.label/]ret)(mem, ls, mem', ls', return) ↔ ls .pc = [genData.generatePrevPC(genData, transition)/] ∧ ls' = ls .pc:= N[generateReturn(genData, transition.instruction.oclAsType(Return), transition)/] ∧ mem' = mem;
	used for : s, ls;
	
	[/for]
end enrich
		
[/file]
[/template]

[template private generateGlobalConstants(genData : GeneratorData)]
[if(genData.globalVariables->size() > 0)]
constants
[for(variable : Variable | genData.globalVariables)]
	[variable.newName/] : [variable.type/];
[/for][/if]
[/template]

[template private generateFunctionParameter(cfg: ControlFlowDiagram, genData : GeneratorData)]
[for(variable : Variable | getParameterVariablesOfTypeExcludingReturnVariables(cfg, 'ref'))]
.[variable.newName/]:= inp [if(input(genData))].[variable.type/][i/] [/if][/for]
[for(variable : Variable | getParameterVariablesOfTypeExcludingReturnVariables(cfg, basis(genData)))]
.[variable.newName/]:= inp [if(hasTransformationSpecificKey(genData, 'INPUT_REF') and input(genData)._not())].v [/if][if(input(genData))].[variable.type/][i/] [/if][/for]
[/template]

[comment ============================= Transitions=============================================== /]
[template private transformTransition(t: Transition, genData: GeneratorData)]
[let pc : String = generateNextPC(genData, t)]
[if((t.instruction.oclIsUndefined() or t.instruction.oclIsKindOf(Select) or t.instruction.oclIsTypeOf(CompareInt) or t.instruction.oclIsTypeOf(CmpXchg))._not())]ls' = ls .pc:= [pc/][/if][if (not t.instruction.oclIsUndefined())][t.instruction.genLsPart(t,genData)/][/if][if(not t.instruction.oclIsTypeOf(CmpXchg))][t.genPhiInstruction(genData)/][/if][t.instruction.genMemPart(t,genData)/][/let]
[/template]

[comment === WriteDefChainTransition ====/]
[template private transformTransition(t : WriteDefChainTransition, genData : GeneratorData)]
ls' = ls .pc:= [generateNextPC(genData, t)/][if(t.copyAddress.oclIsUndefined()._not())][transformCopyAddress(t, genData)/][/if][if(t.copyValue.oclIsUndefined()._not())][transformCopyValue(t, genData)/][/if] ∧ mem' = mem
[/template]

[template private transformCopyAddress(t : WriteDefChainTransition, genData : GeneratorData)]
 .[t.copyAddress.addressToString(t, genData)/]:= ls.[valueToString(t.instruction.oclAsType(Store).targetAddress.value,t, genData)/]
[/template]

[template private transformCopyValue(t : WriteDefChainTransition, genData : GeneratorData)]
 .[t.copyValue.addressToString(t, genData)/]:= ls.[valueToString(t.instruction.oclAsType(Store).value.value,t, genData)/]
[/template]

[comment === FlushTransition ====/]
[template private transformTransition(t: FlushTransition, genData: GeneratorData)]
ls' = ls .pc:= [generateNextPC(genData, t)/] ∧ mem' = mem['[ '/][t.flushedEntry.address.value.castFromRef(t, genData)/] ,[t.flushedEntry.values->first().value.castToRef(t, genData)/][']'/]
[/template]

[comment === EarlyReadTransition ====/]
[template private transformTransition(t : EarlyReadTransition, genData: GeneratorData)]
ls' = ls .pc:= [generateNextPC(genData, t)/] .[t.instruction.oclAsType(Load).result.addressToString(t, genData)/]:= [findValueForEarlyReadExpression(t, genData)/] ∧ mem' = mem
[/template]

[template private findValueForEarlyReadExpression(t : EarlyReadTransition, genData : GeneratorData)]
[for (avp: AddressValuePair | t.source.buffer.addressValuePairs)]
[for(parameter : Parameter | avp.values)]
[let v : String = valueToString(parameter.value, t,genData)]
[let variable : Variable = getVariableForAddress(t.instruction.oclAsType(Load).result, t, genData)]
[if (parameter.value.oclIsKindOf(IntegerConstant))][let intParam : String = possiblyZeroBeforeMinus(parameter.value.oclAsType(IntegerConstant).value).toString()][if(intParam.equalsIgnoreCase(v))][possiblyCast(parameter.value, variable.type, t, genData)/][/if][/let][else]
[if(t.assignmentExpression.equalsIgnoreCase(v))][possiblyCast(parameter.value, variable.type, t, genData)/][/if][/if][/let][/let][/for][/for]
[/template]

[comment === Return ====/]
[template private generateReturn(genData : GeneratorData, ret : Return, t: Transition)]
[if(ret.value.oclIsTypeOf(Parameter))] ∧ return = [if(getAllReturnVariables(genData)->first().type.equalsIgnoreCase('ref'))][castToRef(ret.value.oclAsType(Parameter).value, t, genData)/][else][possiblyAddLS(ret.value.oclAsType(Parameter).value, t, genData)/][ret.value.oclAsType(Parameter).value.valueToString(t,genData)/][/if][else]
[if(not ret.value.oclAsType(PrimitiveValue).value.equalsIgnoreCase('void'))] ∧ return = [ret.value.oclAsType(PrimitiveValue).valueToString(t, genData)/][/if][/if]
[/template]

[comment ====== Instructions ======/]

[template private genMemPart(e : Instruction, t: Transition, genData : GeneratorData)]
 ∧ mem' = mem
[/template]

[template private genPhiInstruction(t : Transition, genData : GeneratorData)]
[for(phi : PhiAssignment | t.phiAssignments)] .[phi.variable.newName/]:= [if(phi.variable.type.equalsIgnoreCase('ref'))][castToRef(phi.value, t, genData)/][else][possiblyAddLS(phi.value, t, genData)/][transformBooleanToNumber(valueToString(phi.value,t,genData))/][/if][/for]
[/template]

[template private genLsPart(e : Instruction, t: Transition, genData : GeneratorData)]
[comment Abstract/]
[/template]

[comment ====== Arithmetic Operation ======/]
[template private genLsPart(e : ArithmeticOperation, t: Transition, genData : GeneratorData)]
[e.arithmeticInstr(e, t,genData)/]
[/template]

[comment ====== Load ======/]
[template private genLsPart(e : Load, t : Transition, genData : GeneratorData)]
 .[e.result.addressToString(t, genData)/]:= mem['['/][e.address.value.castFromRef(t, genData)/][']'/][if(not getVariableForAddress(e.result, t, genData).type.equalsIgnoreCase('ref'))] .v[/if]
[/template]

[comment ====== CompareInt ======/]
[template private genLsPart(e : CompareInt, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)][let res : String = e.result.addressToString(t, genData)]
[if(e.cond.equalsIgnoreCase('eq'))]([generateCastedAssignment(e.operand1, e.operand2, t, genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ne'))]([generateCastedAssignment(e.operand1, e.operand2, t, genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('uge')._or(e.cond.equalsIgnoreCase('sge')))]([e.operand1.castFromRef(t, genData)/] ≥ [e.operand2.castFromRef(t, genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ugt')._or(e.cond.equalsIgnoreCase('sgt')))]([e.operand1.castFromRef(t, genData)/] ≤ [e.operand2.castFromRef(t, genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ult')._or(e.cond.equalsIgnoreCase('slt')))]([e.operand1.castFromRef(t, genData)/] ≥ [e.operand2.castFromRef(t, genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/])[else]
[if(e.cond.equalsIgnoreCase('ule')._or(e.cond.equalsIgnoreCase('sle')))]([e.operand1.castFromRef(t, genData)/] ≤ [e.operand2.castFromRef(t, genData)/] ⊃ ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/] ; ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/])[/if][/if][/if][/if][/if][/if]
[/let][/let]
[/template]

[comment ====== Compare Exchange ======/]
[template private genLsPart(e : CmpXchg, t: Transition, genData : GeneratorData)]
[let res : String = e.result.addressToString(t, genData)][let adr : String = valueToString(e.address.value, t, genData)][let pc : String = generateNextPC(genData, t)]
( mem['['/][e.address.value.castFromRef(t, genData)/][']'/] = [e.value.value.castToRef(t, genData)/] ⊃ (ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('1',e.result, t, genData)/][genPhiInstruction(t, genData)/] ∧ mem' = mem['['/][e.address.value.castFromRef(t, genData)/], [e.newValue.value.castToRef(t, genData)/][']'/]) ; (ls' = ls .pc:= [pc/] .[res/]:= [possiblyCastToRef('0',e.result, t, genData)/][genPhiInstruction(t, genData)/] ∧ mem' = mem))[/let]
[/let][/let]
[/template]

[template private genMemPart(e : CmpXchg, t: Transition, genData: GeneratorData)]
[/template]

[comment ====== Atomic Read Modify Write ======/]
[template private genLsPart(e : AtomicRMW, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(t, genData)/]:= mem['['/][e.address.value.castFromRef(t, genData)/][']'/] .v
[/template]

[template private genMemPart(e: AtomicRMW, t: Transition, genData : GeneratorData)]
[let adr : String = e.address.value.castFromRef(t, genData)][let arg : String = valueToString(e.argument.value, t, genData)][let res : String = e.result.addressToString(t, genData)]
[if(e.operation.equalsIgnoreCase('xchg'))] ∧ mem' = mem['[ '/][adr/], [e.argument.value.castToRef(t, genData)/][']'/][else]
[if(e.operation.equalsIgnoreCase('add'))] ∧ mem' = mem['[ '/][adr/], ⌜(mem['['/][adr/][']'/] .v) + [possiblyAddLS(e.argument.value, t, genData)/][arg/]⌝[']'/][else]
[if(e.operation.equalsIgnoreCase('sub'))] ∧ mem' = mem['[ '/][adr/], ⌜(mem['['/][adr/][']'/] .v) - [possiblyAddLS(e.argument.value, t, genData)/][arg/]⌝[']'/][else]
[if(e.operation.equalsIgnoreCase('max')._or(e.operation.equalsIgnoreCase('umax')))] ∧ (mem['['/][adr/][']'/] > [e.argument.value.castToRef(t, genData)/] ⊃ mem' = mem ; mem' = mem['[ '/][adr/], [e.argument.value.castToRef(t, genData)/][']'/])[else]
[if(e.operation.equalsIgnoreCase('min')._or(e.operation.equalsIgnoreCase('umin')))] ∧ (mem['['/][adr/][']'/] < [e.argument.value.castFromRef(t, genData)/] ⊃ mem' = mem ; mem' = mem['[ '/][adr/], [e.argument.value.castToRef(t, genData)/][']'/])[else]
unsupported operation
[/if][/if][/if][/if][/if][/let][/let][/let]
[/template]

[comment ====== Branch ======/]
[template private genMemPart(e: Branch, t: Transition, genData : GeneratorData)]
[if(not e.condition.oclIsUndefined())] ∧ [possiblyAddLS(e.condition, t, genData)/][valueToString(e.condition, t, genData)/][if(not t.oclAsType(GuardedTransition).condition.contains('!'))] = 1[else] = 0[/if][/if]
[/template]

[comment ====== Get Element Pointer ======/]
[template private genLsPart(e : GetElementPtr, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(t, genData)/]:= [for(mm : MemorySizeMapping | genData.memorySizeMappings)][if(mm.instruction = e)][let offset : EString = mm.offset][possiblyCastToRef('('+ e.aggregate.value.castFromRef(t, genData) +' + '+ offset + ')', e.result, t,genData)/][/let][/if][/for]
[/template]

[comment ====== Cast ======/]
[template private genLsPart(e : Cast, t: Transition, genData: GeneratorData)]
 .[e.result.addressToString(t, genData)/]:= [e.value.possiblyCast(getVariableForAddress(e.result, t, genData).type, t, genData)/]
[/template]

[comment ====== Select ======/]
[template private genLsPart(e : Select, t : Transition, genData : GeneratorData)]
[let pc : String = generateNextPC(genData, t)]
([possiblyAddLS(e.condition.value, t, genData)/][valueToString(e.condition.value, t, genData)/] = 1 ⊃ ls' = ls .pc:= [pc/] .[e.result.addressToString(t, genData)/]:= [possiblyAddLS(e.trueValue.value, t, genData)/][valueToString(e.trueValue.value, t, genData)/] ; ls' = ls .pc:= [pc/] .[e.result.addressToString(t, genData)/]:= [possiblyAddLS(e.elseValue.value, t, genData)/][valueToString(e.elseValue.value, t, genData)/])
[/let]
[/template]

[comment ====== Switch ======/]
[template private genLsPart(e : Switch, t : Transition, genData : GeneratorData)]
 ∧[let cond : String = t.oclAsType(GuardedTransition).condition.substitute('[', '').substitute(']', '').trim()]
[for (case : SwitchCase | e.cases) separator (' ∧')] [possiblyAddLS(e.caseValue.value, t, genData)/][valueToString(e.caseValue.value, t, genData)/][if(valueToString(case.caseValue.value, t, genData).trim().equalsIgnoreCase(cond))] = [cond/][else] ≠ [valueToString(case.caseValue.value, t, genData).trim()/][/if][/for][/let]
[/template]

[template private genNestedCast(cast : NestedCast, t : Transition, genData : GeneratorData)]
[if(extractType(cast.from).contains('*'))][possiblyCast(cast.value, 'ref', t, genData)/][else][possiblyCast(cast.value, genData.basis(), t, genData)/][/if]
[/template]

[comment ====== General Calls ======/]

[query private arithmeticInstr(e : ArithmeticOperation, t: Transition, genData: GeneratorData) : String = 
' .' + e.result.addressToString(t, genData) + ':= ( ' 
+ possiblyAddLS(e.value1, t, genData)
+ valueToString(e.value1, t, genData)
+ ' '
+ e.operation.arithmeticOp() + ' ' 
+ possiblyAddLS(e.value2, t, genData) 
+ valueToString(e.value2, t, genData) 
+ ')'
/]

[template private possiblyCast(v: Value, resultType : String, t : Transition,  genData : GeneratorData)]
[if (v.oclIsTypeOf(AddressUse))][let variable : Variable = getVariableForAddress(v.oclAsType(AddressUse).address, t, genData)]
[if (resultType.equalsIgnoreCase(genData.basis()) and variable.type.equalsIgnoreCase('ref'))][v.castFromRef(t, genData)/][elseif(resultType.equalsIgnoreCase('ref') and variable.type.equalsIgnoreCase(genData.basis()))]
[v.castToRef(t, genData)/][else][possiblyAddLS(v, t, genData)/][valueToString(v, t, genData)/][/if][/let][elseif(resultType.equalsIgnoreCase('ref'))]
[v.castToRef(t, genData)/][else][possiblyAddLS(v, t, genData)/][valueToString(v, t, genData)/][/if]
[/template]

[query private possiblyCastToRef(s : String, address : Address, t : Transition, genData : GeneratorData) : String =
if (getVariableForAddress(address, t, genData).type.equalsIgnoreCase('ref')) then '⌜'+s+'⌝' else s endif/]

[query public valueToString(v : Value, t : Transition, genData: GeneratorData) : String = 
if v.oclIsTypeOf(PrimitiveValue) then 
	'' + transformBooleanToNumber(v.oclAsType(PrimitiveValue).value)
else if v.oclIsTypeOf(IntegerConstant) then 
	getValueFromConstant(v.oclAsType(IntegerConstant))
else if v.oclIsTypeOf(DecimalConstant) then 
	getValueFromConstant(v.oclAsType(DecimalConstant))
else if v.oclIsTypeOf(AddressUse) then 
	getVariableForAddress(v.oclAsType(AddressUse).address, t, genData).newName
else if v.oclIsTypeOf(NestedGetElementPtr) then 
	genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), t, genData)
else if v.oclIsTypeOf(NestedCast) then 
	genNestedCast(v.oclAsType(NestedCast), t, genData)
else 
	'FIXME, THIS NEVER HAPPENED BEFORE'
endif
endif
endif
endif
endif
endif
 /]

[template private possiblyAddLS(v : Value, t : Transition, genData: GeneratorData)]
[if(v.oclIsTypeOf(AddressUse))][if(not getVariableFromLocalAndParameterVariables(v.oclAsType(AddressUse).address, t, genData).oclIsUndefined())]ls .[/if][/if]
[/template]

[template public castToRef(v : Value, t : Transition, genData : GeneratorData)]
//NOT SUPPORTED
[/template]

[template public castToRef(v : PrimitiveValue, t: Transition, genData : GeneratorData)]
[if(v.oclAsType(PrimitiveValue).value.equalsIgnoreCase('null'))]null[else]⌜[possiblyAddLS(v, t, genData)/][valueToString(v, t, genData)/]⌝[/if]
[/template]

[template public castToRef(v : Constant, t: Transition, genData : GeneratorData)]
⌜[v.oclAsType(Constant).getValueFromConstant()/]⌝
[/template]

[template public castToRef(v : AddressUse, t: Transition, genData : GeneratorData)]
[let variable : Variable = getVariableForAddress(v.address, t, genData)]
[let addressName : String = possiblyAddLS(v, t, genData)+variable.newName.transformBooleanToNumber()]
[if (variable.type.equalsIgnoreCase(genData.basis()))]⌜[addressName/]⌝[else][addressName/][/if][/let][/let]
[/template]

[template public castToRef(v : NestedGetElementPtr, t: Transition, genData : GeneratorData)]
[genNestedGetElemPtr(v.oclAsType(NestedGetElementPtr), t, genData)/]
[/template]

[template public castToRef(v : NestedCast, t: Transition, genData : GeneratorData)]
[genNestedCast(v.oclAsType(NestedCast), t, genData)/]
[/template]

[template public castFromRef(v : Value, t: Transition, genData : GeneratorData)]
//NOT SUPPORTED
[/template]

[template public castFromRef(v : PrimitiveValue, t: Transition, genData : GeneratorData)]
[possiblyAddLS(v, t, genData)/][v.value.transformBooleanToNumber()/]
[/template]

[template public castFromRef(v : Constant, t: Transition, genData : GeneratorData)]
[v.getValueFromConstant()/]
[/template]

[template public castFromRef(v : AddressUse, t: Transition, genData : GeneratorData)]
[let variable : Variable = getVariableForAddress(v.address, t, genData)]
[let addressName : String = possiblyAddLS(v, t, genData)+variable.newName.transformBooleanToNumber()]
[if (variable.type.equalsIgnoreCase('ref'))][addressName/] .v[else][addressName/][/if][/let][/let]
[/template]

[template public castFromRef(v : NestedGetElementPtr, t: Transition, genData : GeneratorData)]
[genNestedGetElemPtr(v, t,  genData)/]
[/template]

[template public castFromRef(v : NestedCast, t: Transition, genData : GeneratorData)]
[genNestedCast(v, t, genData)/]
[/template]

[template public genNestedGetElemPtr(nestedPtr : NestedGetElementPtr, t : Transition, genData : GeneratorData)]
([nestedPtr.aggregate.value.castFromRef(t, genData)/][for(mm : MemorySizeMapping | genData.memorySizeMappings)][if(mm.instruction = nestedPtr)] + [mm.offset/][/if][/for])
[/template]

[template private generateCastedAssignment(targetValue : Value, sourceValue : Value, t : Transition, genData : GeneratorData)]
[createCastedAssignment(targetValue, sourceValue, t, genData)/]
[/template]

[query private createCastedAssignment(targetValue : Value, sourceValue : Value, t : Transition, genData : GeneratorData) : String =
if haveUnequalKivTypes(targetValue, sourceValue, t, genData) then 
	castToRef(targetValue, t, genData) + ' = ' + castToRef(sourceValue, t, genData)
else
	possiblyAddLS(targetValue, t, genData) + valueToString(targetValue, t, genData) + ' = ' + possiblyAddLS(sourceValue, t, genData) + valueToString(sourceValue, t, genData)
endif
/]

[query private haveUnequalKivTypes(targetValue : Value, sourceValue : Value, t : Transition, genData : GeneratorData) : Boolean =
	if targetValue.oclIsTypeOf(AddressUse) then
		if sourceValue.oclIsTypeOf(AddressUse) then
			not getVariableForAddress(targetValue.oclAsType(AddressUse).address, t, genData).type.equalsIgnoreCase(getVariableForAddress(sourceValue.oclAsType(AddressUse).address, t, genData).type)
		else 
			hasAddressTypeRef(targetValue.oclAsType(AddressUse).address, t, genData)
		endif 
	else 
		if sourceValue.oclIsTypeOf(AddressUse) then
			hasAddressTypeRef(sourceValue.oclAsType(AddressUse).address, t, genData)
		else
			false
		endif
	endif
/] 

[query private hasAddressTypeRef(address: Address, t: Transition, genData : GeneratorData) : Boolean = 
	getVariableForAddress(address, t, genData).type.equalsIgnoreCase('ref')
/]