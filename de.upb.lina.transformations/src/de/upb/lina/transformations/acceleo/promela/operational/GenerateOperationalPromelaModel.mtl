[comment encoding = UTF-8 /]
[module GenerateOperationalPromelaModel('http://www.upb.de/lina/cfg/controlflow', 'http://www.upb.de/lina/cfg/gendata', 'http://www.upb.de/llvm_parser/llvm', 'http://www.eclipse.org/emf/2002/Ecore')]
[import de::upb::lina::transformations::acceleo::TransformationCommon/]

[import de::upb::lina::transformations::acceleo::promela::PromelaCommon/]

[import de::upb::lina::transformations::acceleo::promela::operational::GeneratePSOFile/]
[import de::upb::lina::transformations::acceleo::promela::operational::GenerateTSOFile/]
[import de::upb::lina::transformations::acceleo::promela::operational::GenerateSCFile/]


[template public generateModel(genData : GeneratorData, fileName: String) post (trim())]   
[comment @main/]
[generateActualModel(genData, fileName)/]
[generateOperationalModelSC(genData)/]
[generateOperationalModelTSO(genData)/]
[generateOperationalModelPSO(genData)/]
[/template]

[template public generateActualModel(genData : GeneratorData, fileName: String) post (trim())]
[file ( fileName  , false, 'UTF-8')]
[genStartOfFile()/]
[genGlobalVars(genData)/]
[buildStandards(genData)/]
//------------- functions ------------------
[for (cfg: ControlFlowDiagram | genData.cfgs)]
[genFunctionHead(cfg, genData)/]
[genLocalVarDeclarations(cfg, genData)/]
[generateFunction(cfg, genData)/]
ret: skip;
}

[/for]

//------------- process template -------------
[genProcessTemplates(genData)/]
[/file]
[/template]


[template public generateFunction(cfg : ControlFlowDiagram, genData:  GeneratorData)]
[let b:  FunctionBody = cfg.functionDefinition._body]
[if (not( b.oclIsUndefined()))]
skip;
[for (block : BasicBlock | b.blocks)]
[generateBlock(block, cfg, genData)/]
[/for]
[/if]
[/let]
[/template]

[template public generateBlock(block: BasicBlock, cfg: ControlFlowDiagram, genData: GeneratorData)]
[escape(block.label)/]: 
[for (i : Instruction | block.instructions)]
 [genInstruction(i, getTransitionForInstruction(i, cfg), genData)/]
[/for]
[/template]

[query public escape(s : EString) : String = 
if s.substituteAll('.', '').substituteAll('%', '').equalsIgnoreCase('return') then
 'return1' 
else s.substituteAll('.', '').substituteAll('%', '')
endif
/]

[comment]THIS IS NOT RELIABLE FOR BRANCHES AS THERE ARE TWO TRANSITION FOR ONE INSTRUCTION [/comment]
[query private getTransitionForInstruction(i : Instruction, cfg: ControlFlowDiagram) : Transition = cfg.transitions->any(t | t.instruction = i) /]


[template public genStartOfFile(c: OclAny)]
#define MEM_SIZE 10	//size of memory
#define BUFF_SIZE 3 	//size of Buffer 
#define null 0
#define I32  1
#define PTR 1
short memUse = 1; 	//shows to the next free cell in memory

//#include "sc.pml"
#include "tso.pml"
//#include "pso.pml"

chan channelT1 = ['['/]0[']'/] of {mtype, short, short, short};
chan channelT2 = ['['/]0[']'/] of {mtype, short, short, short};
[/template]

[template public genProcessTemplates(genData: GeneratorData)]

//Stubs
proctype process1(chan ch){
	//TODO: empty stub
}

proctype process2(chan ch){
	//TODO: empty stub
}


init{
atomic{
	//initialize global variables or allocate memory space here, if necessary
	[genGlobalVariableAllocation(genData)/]
	run bufferProcess(channelT1); //obsolete for SC, remove line when SC is chosen
	run bufferProcess(channelT2); //obsolete for SC, remove line when SC is chosen
	run process1(channelT1);
	run process2(channelT2);
	}
}
[/template]




[template public buildStandards(genData: GeneratorData)]

[for(func: String | genData.transformationSpecificKeys)][if (func.equalsIgnoreCase('getelementptr'))]
//pointer computation 
inline getelementptr(type, instance, offset, targetRegister)
{
	atomic{
	//simplified version of what llvm does.
	//we don't need the type as long as we assume our memory to hold only values/pointers etc of equal length. 
	//In this case, the offset directly correspond to adding it to instance address. 
	assert(offset <= type); //offset shouldn't be greater than the type range
	targetRegister = instance + offset;
	}
}
[/if]
[/for]
//memory allocation
inline alloca(type, targetRegister)
{
	atomic{
	targetRegister = memUse;
	memUse = memUse + type;
	assert(memUse < MEM_SIZE);
	}
}

[if (genData.transformationSpecificKeys->select(s | s.equalsIgnoreCase('cas'))->notEmpty())]
//Note, CAS operations in LLVM return a tuple (i32, i1), the value read and a success bit.
//Sometimes the follow up code uses the succes bit but usually the read value. 
//Adjust CAS semantics, if necessary.
[/if]




[/template]



[comment SINGLE INSTRUCTION TRANSLATION /]


[template public genInstruction(e : Branch, t: Transition, genData: GeneratorData)]
[if (e.elseDestination.oclIsUndefined())]
[genPhiAssignments(t, genData)/]  goto [e.destination.escape()/];
[else]
if 
	:: [valueToString(e.condition, getTransitionForBranchCase(e, t, true), genData)/] -> [genPhiAssignments(getTransitionForBranchCase(e, t, true), genData)/] goto [escape(e.destination)/];
	:: ![valueToString(e.condition, getTransitionForBranchCase(e, t, false), genData)/] -> [genPhiAssignments(getTransitionForBranchCase(e, t, false), genData)/] goto [escape(e.elseDestination)/];
fi;
[/if]
[/template]

[query private getTransitionForBranchCase(i : Branch, t: Transition, trueCase: Boolean) : Transition =
if(trueCase)then
	t.diagram.transitions->filter(GuardedTransition)->any(gt | gt.instruction = i and not gt.condition.startsWith('!'))
else 
	t.diagram.transitions->filter(GuardedTransition)->any(gt | gt.instruction = i and gt.condition.startsWith('!'))
endif 
 /]



[template public genInstruction(e : CmpXchg, t: Transition, genData : GeneratorData)]
cas([valueToString(e.address.value, t, genData)/], [valueToString(e.value.value, t, genData)/], [valueToString(e.newValue.value, t, genData)/], [getVariableForAddress(e.result, t, genData).newName/]); 
[/template]

[comment]  NEED TO CREATE SPECIAL INLINE DEFINITIONS FOR THESE VARIANTS OF ATOMITC RMW OPERATIONS   [/comment]
[comment][template public genInstruction(e : AtomicRMW, genData : GeneratorData)]
atomic{[e.result.addressToString(genData)/] = [e.address.value.valueToString(genData)/]; [e.genAtomicRMWOperation(genData)/]} 
[/template][/comment]


[template public genInstruction(e : Load, t: Transition, genData : GeneratorData)]
read([valueToString(e.address.value, t, genData)/], [getVariableForAddress(e.result, t, genData).newName/]); 
[/template]

[template public genInstruction(e : Store,  t: Transition, genData : GeneratorData)]
write([valueToString(e.targetAddress.value, t, genData)/], [valueToString(e.value.value, t, genData)/]);
[/template]

[template public genInstruction(e : Fence,  t: Transition, genData : GeneratorData)]
mfence();
[/template]

[template public genInstruction(e : Return, t: Transition, genData: GeneratorData)]
[if (t.diagram.returnVariable.oclIsUndefined())]goto ret;[else][t.diagram.returnVariable.newName/] = [valueToString(e.value, t, genData)/]; ['\n'/]goto ret;[/if]
[/template]

