[comment encoding = UTF-8 /]
[module GenerateOperationalPromelaModel('http://www.upb.de/lina/cfg/controlflow', 'http://www.upb.de/lina/cfg/gendata', 'http://www.upb.de/llvm_parser/llvm', 'http://www.eclipse.org/emf/2002/Ecore')]
[import de::upb::lina::transformations::acceleo::TransformationCommon/]
[import de::upb::lina::transformations::acceleo::promela::PromelaCommon/]

[template public generateModel(genData : GeneratorData, fileName: String) post (trim())]   
[comment @main/]
[generateActualModel(genData, fileName)/]
[generateOperationalModelSC(genData)/]
[generateOperationalModelTSO(genData)/]
[generateOperationalModelPSO(genData)/]
[/template]

[template public generateActualModel(genData : GeneratorData, fileName: String) post (trim())]
[file ( fileName  , false, 'UTF-8')]
[genStartOfFile()/]
[genGlobalVars(genData)/]
[buildStandards(genData)/]
//------------- functions ------------------
[for (cfg: ControlFlowDiagram | genData.cfgs)]
[genFunctionHead(cfg, genData)/]
[genLocalVarDeclarations(cfg, genData)/]
[generateFunction(cfg, genData)/]
ret: skip;
}

[/for]

//------------- process template -------------
[genProcessTemplates(genData)/]
[/file]
[/template]


[template public generateFunction(cfg : ControlFlowDiagram, genData:  GeneratorData)]
[let b:  FunctionBody = cfg.functionDefinition._body]
[if (not( b.oclIsUndefined()))]
skip;
[for (block : BasicBlock | b.blocks)]
[generateBlock(block, cfg, genData)/]
[/for]
[/if]
[/let]
[/template]

[template public generateBlock(block: BasicBlock, cfg: ControlFlowDiagram, genData: GeneratorData)]
[escape(block.label)/]: 
[for (i : Instruction | block.instructions)]
 [genInstruction(i, getTransitionForInstruction(i, cfg), genData)/]
[/for]
[/template]

[query public escape(s : EString) : String = 
if s.substituteAll('.', '').substituteAll('%', '').equalsIgnoreCase('return') then
 'return1' 
else s.substituteAll('.', '').substituteAll('%', '')
endif
/]

[comment]THIS IS NOT RELIABLE FOR BRANCHES AS THERE ARE TWO TRANSITION FOR ONE INSTRUCTION [/comment]
[query private getTransitionForInstruction(i : Instruction, cfg: ControlFlowDiagram) : Transition = cfg.transitions->any(t | t.instruction = i) /]


[template public genStartOfFile(c: OclAny)]
#define MEM_SIZE 10	//size of memory
#define BUFF_SIZE 3 	//size of Buffer 
#define null 0
#define I32  1
#define PTR 1
short memUse = 1; 	//shows to the next free cell in memory

//#include "sc.pml"
#include "tso.pml"
//#include "pso.pml"

chan channelT1 = ['['/]0[']'/] of {mtype, short, short, short};
chan channelT2 = ['['/]0[']'/] of {mtype, short, short, short};
[/template]

[template public genProcessTemplates(genData: GeneratorData)]

//Stubs
proctype process1(chan ch){
	//TODO: empty stub
}

proctype process2(chan ch){
	//TODO: empty stub
}


init{
atomic{
	//initialize global variables or allocate memory space here, if necessary
	[genGlobalVariableAllocation(genData)/]
	run bufferProcess(channelT1); //obsolete for SC, remove line when SC is chosen
	run bufferProcess(channelT2); //obsolete for SC, remove line when SC is chosen
	run process1(channelT1);
	run process2(channelT2);
	}
}
[/template]




[template public buildStandards(genData: GeneratorData)]

[for(func: String | genData.transformationSpecificKeys)][if (func.equalsIgnoreCase('getelementptr'))]
//pointer computation 
inline getelementptr(type, instance, offset, targetRegister)
{
	atomic{
	//simplified version of what llvm does.
	//we don't need the type as long as we assume our memory to hold only values/pointers etc of equal length. 
	//In this case, the offset directly correspond to adding it to instance address. 
	assert(offset <= type); //offset shouldn't be greater than the type range
	targetRegister = instance + offset;
	}
}
[/if]
[/for]
//memory allocation
inline alloca(type, targetRegister)
{
	atomic{
	targetRegister = memUse;
	memUse = memUse + type;
	assert(memUse < MEM_SIZE);
	}
}

[if (genData.transformationSpecificKeys->select(s | s.equalsIgnoreCase('cas'))->notEmpty())]
//Note, CAS operations in LLVM return a tuple (i32, i1), the value read and a success bit.
//Sometimes the follow up code uses the succes bit but usually the read value. 
//Adjust CAS semantics, if necessary.
[/if]




[/template]



[comment SINGLE INSTRUCTION TRANSLATION /]


[template public genInstruction(e : Branch, t: Transition, genData: GeneratorData)]
[if (e.elseDestination.oclIsUndefined())]
[genPhiAssignments(t, genData)/]  goto [e.destination.escape()/];
[else]
if 
	:: [valueToString(e.condition, getTransitionForBranchCase(e, t, true), genData)/] -> [genPhiAssignments(getTransitionForBranchCase(e, t, true), genData)/] goto [escape(e.destination)/];
	:: ![valueToString(e.condition, getTransitionForBranchCase(e, t, false), genData)/] -> [genPhiAssignments(getTransitionForBranchCase(e, t, false), genData)/] goto [escape(e.elseDestination)/];
fi;
[/if]
[/template]

[query private getTransitionForBranchCase(i : Branch, t: Transition, trueCase: Boolean) : Transition =
if(trueCase)then
	t.diagram.transitions->filter(GuardedTransition)->any(gt | gt.instruction = i and not gt.condition.startsWith('!'))
else 
	t.diagram.transitions->filter(GuardedTransition)->any(gt | gt.instruction = i and gt.condition.startsWith('!'))
endif 
 /]



[template public genInstruction(e : CmpXchg, t: Transition, genData : GeneratorData)]
cas([valueToString(e.address.value, t, genData)/], [valueToString(e.value.value, t, genData)/], [valueToString(e.newValue.value, t, genData)/], [getVariableForAddress(e.result, t, genData).newName/]); 
[/template]

[comment]  NEED TO CREATE SPECIAL INLINE DEFINITIONS FOR THESE VARIANTS OF ATOMITC RMW OPERATIONS   [/comment]
[comment][template public genInstruction(e : AtomicRMW, genData : GeneratorData)]
atomic{[e.result.addressToString(genData)/] = [e.address.value.valueToString(genData)/]; [e.genAtomicRMWOperation(genData)/]} 
[/template][/comment]


[template public genInstruction(e : Load, t: Transition, genData : GeneratorData)]
read([valueToString(e.address.value, t, genData)/], [getVariableForAddress(e.result, t, genData).newName/]); 
[/template]

[template public genInstruction(e : Store,  t: Transition, genData : GeneratorData)]
write([valueToString(e.targetAddress.value, t, genData)/], [valueToString(e.value.value, t, genData)/]);
[/template]

[template public genInstruction(e : Fence,  genData : GeneratorData)]
mfence();
[/template]





[template public generateOperationalModelSC(genData: GeneratorData)]
[file ( 'sc.pml'  , false, 'UTF-8')]
// [protected ('operational SC model')]
// This code will not be regenerated, if you change it. Delete the file 
// or remove the first and last line of the file, if you want it to be regenerated.  
#define NULL 0

/*Speicher*/
short memory['['/]MEM_SIZE[']'/];


inline write(adr, value)
{
	memory['['/]adr[']'/] = value;
}
	
inline read(adr, target)
{
	target = memory['['/]adr[']'/];
}


inline flush() {
	skip;	// no action
}

inline mfence() {
	skip; //no action
}

//Note, LLVM returns a tuple (i32, i1), the value read and a success bit.
//Sometimes the follow up code uses the succes bit but usually the read value. 
//Adjust CAS semantics, if necessary. 
inline cas(adr, oldValue, newValue, returnValue) {
	atomic{
		returnValue = memory['['/]adr[']'/];
		if 	:: memory['['/]adr[']'/] == oldValue
				-> memory['['/]adr[']'/] = newValue;
			:: else -> skip;;
		fi;
	}
}

// [/protected]
[/file]
[/template]

[template public generateOperationalModelTSO(genData: GeneratorData)]
[file ( 'tso.pml'  , false, 'UTF-8')]
// [protected ('operational TSO model')]
// This code will not be regenerated, if you change it. Delete the file 
// or remove the first and last line of the file, if you want it to be regenerated.  
#define NULL 0

/*Buffer as a 2 dimensional array which represents the queue ['['/](nx2)-matrix[']'/]*/
typedef matrix{short line ['['/]2[']'/]}

mtype = {iWrite, iRead , iMfence, iCas};
/*memory*/
short memory['['/]MEM_SIZE[']'/];


inline write(adr, newValue)
{
	atomic{
	ch ! iWrite, adr, newValue, NULL;
	}
}

inline read(adr, target)
{
	atomic{
	ch ! iRead, adr, NULL, NULL;
	ch ? iRead, NULL, target, NULL;
	}
}

inline mfence()
{
	atomic{
	ch ! iMfence, NULL, NULL, NULL;
	ch ? iMfence, NULL, NULL, NULL;
	}
}	

inline cas(adr, oldValue, newValue, successBit) 
{
	// 2 steps for the executing process, but atomic on memory
	atomic{
	ch ! iCas, adr, oldValue, newValue;
	ch ? iCas, NULL, successBit, NULL; 
	}
}

inline writeB() {
		assert(address != 0);
		assert(tail < BUFF_SIZE);
		buffer['['/]tail[']'/].line['['/]0[']'/] = address;
		buffer['['/]tail[']'/].line['['/]1[']'/] = value;
		tail++;
		address = 0;
		value = 0;
}


inline readB() {
	assert(address != 0);
	i = tail-1;
	do
	:: i >= 0  -> 
			if
			/* if an address in the buffer is equivalent to the searched -> return value*/
			::buffer['['/]i[']'/].line['['/]0[']'/] == address 
				->  channel ! iRead,NULL,buffer['['/]i[']'/].line['['/]1[']'/],NULL;
					i = 0;
					break;
			::else -> i--;
			fi
			/*else: access to memory and return value of searched address*/
	::else ->
		channel ! iRead,NULL,memory['['/]address[']'/],NULL;
		i = 0;
		break;
	od
}


inline flushB() {
	if 
	:: (tail > 0) ->	{
		//write value in memory: memory['['/]address[']'/] = value
		memory['['/]buffer['['/]0[']'/].line['['/]0[']'/][']'/] = buffer['['/]0[']'/].line['['/]1[']'/];
		//move all content one step further
		
		for (i : 1 .. tail-1) {
			buffer['['/]i-1[']'/].line['['/]0[']'/] = buffer['['/]i[']'/].line['['/]0[']'/];
			buffer['['/]i-1[']'/].line['['/]1[']'/] = buffer['['/]i[']'/].line['['/]1[']'/];
		} 
		//remove duplicate tail
		buffer['['/]tail-1[']'/].line['['/]0[']'/] = 0;
		buffer['['/]tail-1[']'/].line['['/]1[']'/] = 0;
		tail--;
		i = 0;
		}
	:: else -> skip;
	fi;
}

inline mfenceB() {
	do
		::(tail<=0) -> break;	//tail > 0 iff buffer not empty
		:: else -> flushB(); 
	od;
}

inline fenceWithResponse() {
	mfenceB();
	channel ! iMfence, NULL, NULL, NULL;
}
	
inline casB() 
{
	mfenceB();	//buffer must be empty
	atomic{
	assert(address != 0);
	i = memory['['/]address[']'/]; 
	if 
		:: memory['['/]address[']'/] == value 
			-> 	memory['['/]address[']'/] = newValue;
		:: else -> skip;
	fi;
	channel ! iCas, NULL, i, NULL;
	i = 0;
	}
}

proctype bufferProcess(chan channel)
{		
	/*start resp. end of queue*/
	short tail = 0;
	short i = 0;
	short address = 0;
	short value = 0; 
	short newValue = 0;
	
	/*writebuffer*/
	matrix buffer ['['/]BUFF_SIZE[']'/];

	
end:	do 
		::	if
				//WRITE
				:: atomic{channel ? iWrite(address,value, NULL) -> writeB();
				//i = 0; address = 0; value = 0; newValue = 0; //can reduce state space, but not reliably
				}
				//READ
				:: atomic{channel ? iRead, address, NULL, NULL -> readB();
				//i = 0; address = 0; value = 0; newValue = 0; //can reduce state space, but not reliably
				}
				//FLUSH
				:: atomic{(tail > 0) -> flushB();  //tail > 0  iff not empty
				//i = 0; address = 0; value = 0; newValue = 0; //can reduce state space, but not reliably
				}
				//FENCE
				:: atomic{channel ? iMfence, NULL, NULL ,NULL -> fenceWithResponse();
				//i = 0; address = 0; value = 0; newValue = 0; //can reduce state space, but not reliably
				}
				//COMPARE AND SWAP
				:: atomic{channel ? iCas, address , value, newValue -> casB();
				//i = 0; address = 0; value = 0; newValue = 0; //can reduce state space, but not reliably
				}
			fi
		od
}
// [/protected]
[/file]
[/template]

[template public generateOperationalModelPSO(genData: GeneratorData)]
[file ( 'pso.pml'  , false, 'UTF-8')]
// [protected ('operational PSO model')]
// This code will not be regenerated, if you change it. Delete the file 
// or remove the first and last line of the file, if you want it to be regenerated.  
#define NULL 0

mtype = {iWrite, iRead , iMfence, iCas};
/*memory*/

//buffer for each address 
typedef SingleAdrBuffer {short entry ['['/]BUFF_SIZE[']'/]};

//the memory
short memory['['/]MEM_SIZE[']'/];

//------------------------------------------------------------
// interface to memory model that is used by program processes
inline write(adr, newValue)
{
	atomic{
	ch ! iWrite, adr, newValue, NULL;
	}
}

inline read(adr, target)
{
	atomic{
	ch ! iRead, adr, NULL, NULL;
	ch ? iRead, NULL, target, NULL;
	}
}

inline mfence()
{
	atomic{
	ch ! iMfence, NULL, NULL, NULL;
	ch ? iMfence, NULL, NULL, NULL;
	}
}	

inline cas(adr, oldValue, newValue, successBit) 
{
	// 2 steps for the executing process, but atomic on memory
	atomic{
		ch ! iCas, adr, oldValue, newValue;
		ch ? iCas, NULL, successBit, NULL; 
	}
}


//-------------------------------------------------------------
//the semantics for each instruction
inline writeB() {
	atomic{
	assert(address != 0);
	assert(address < MEM_SIZE);
	assert(tail['['/]address[']'/] < BUFF_SIZE);
	buffer['['/]address[']'/].entry['['/]tail['['/]address[']'/][']'/] = value;
	tail['['/]address[']'/]++;
	address = 0;
	value = 0;
	}
}


inline readB() {
	atomic{
	assert(address != 0);
	if	
		//entry in buffer exists
		:: ((tail['['/]address[']'/]) > 0) 
			-> channel ! iRead, NULL, buffer['['/]address[']'/].entry['['/](tail['['/]address[']'/] - 1)[']'/], NULL;
		//no entry in buffer, take it from memory
		:: else 
			-> channel ! iRead, NULL, memory['['/]address[']'/], NULL;
	fi;
	address = 0;
	value=0;
	}
}


inline flushB() {
atomic{
	//select all possible addresses to flush from (non-deterministically)
	//select(address : 1 .. (BUFF_SIZE - 1));
	flushAdr = 0;
	if 
		:: 1 < MEM_SIZE && tail['['/]1[']'/] > 0 -> flushAdr = 1;
		:: 2 < MEM_SIZE && tail['['/]2[']'/] > 0 -> flushAdr = 2;
		:: 3 < MEM_SIZE && tail['['/]3[']'/] > 0 -> flushAdr = 3;
		:: 4 < MEM_SIZE && tail['['/]4[']'/] > 0 -> flushAdr = 4;
		:: 5 < MEM_SIZE && tail['['/]5[']'/] > 0 -> flushAdr = 5;
		:: 6 < MEM_SIZE && tail['['/]6[']'/] > 0 -> flushAdr = 6;
		:: 7 < MEM_SIZE && tail['['/]7[']'/] > 0 -> flushAdr = 7;
		:: 8 < MEM_SIZE && tail['['/]8[']'/] > 0 -> flushAdr = 8;
		:: 9 < MEM_SIZE && tail['['/]9[']'/] > 0 -> flushAdr = 9;
		:: 10 < MEM_SIZE && tail['['/]10[']'/] > 0 -> flushAdr = 10;
		:: 11 < MEM_SIZE && tail['['/]11[']'/] > 0 -> flushAdr = 11;
		:: 12 < MEM_SIZE && tail['['/]12[']'/] > 0 -> flushAdr = 12;
		:: 13 < MEM_SIZE && tail['['/]13[']'/] > 0 -> flushAdr = 13;
		:: 14 < MEM_SIZE && tail['['/]14[']'/] > 0 -> flushAdr = 14;
		:: 15 < MEM_SIZE && tail['['/]15[']'/] > 0 -> flushAdr = 15;
		:: 16 < MEM_SIZE && tail['['/]16[']'/] > 0 -> flushAdr = 16;
		:: 17 < MEM_SIZE && tail['['/]17[']'/] > 0 -> flushAdr = 17;
		:: 18 < MEM_SIZE && tail['['/]18[']'/] > 0 -> flushAdr = 18;
		:: 19 < MEM_SIZE && tail['['/]19[']'/] > 0 -> flushAdr = 19;
		:: 20 < MEM_SIZE && tail['['/]20[']'/] > 0 -> flushAdr = 20;
		//...
		//extend if more memory is required
		//...
		:: else -> skip;
	fi;
	
	if 
	:: (flushAdr > 0) ->	{
		//write oldest value to memory
		memory['['/]flushAdr[']'/] = buffer['['/]flushAdr[']'/].entry['['/]0[']'/];
		
		//move all content one step further
		for (i : 1 .. (tail['['/]flushAdr[']'/]-1)) 
		{
			buffer['['/]flushAdr[']'/].entry['['/]i-1[']'/] = buffer['['/]flushAdr[']'/].entry['['/]i[']'/]
		} 
		//remove duplicate tail
		buffer['['/]flushAdr[']'/].entry['['/]tail['['/]flushAdr[']'/]-1[']'/] = 0; //i = tail-1
		tail['['/]flushAdr[']'/]--;	//tail--;
		flushAdr = 0;
		i = 0;
		}
	:: else -> skip;
	fi;
	}
}

inline mfenceB() {
	atomic{	
		do
		::
			if
			::(    (1 >= MEM_SIZE || tail['['/]1[']'/] <= 0) 
				&& (2 >= MEM_SIZE || tail['['/]2[']'/] <= 0)
				&& (3 >= MEM_SIZE || tail['['/]3[']'/] <= 0)
				&& (4 >= MEM_SIZE || tail['['/]4[']'/] <= 0)
				&& (5 >= MEM_SIZE || tail['['/]5[']'/] <= 0)
				&& (6 >= MEM_SIZE || tail['['/]6[']'/] <= 0)
				&& (7 >= MEM_SIZE || tail['['/]7[']'/] <= 0)
				&& (8 >= MEM_SIZE || tail['['/]8[']'/] <= 0)
				&& (9 >= MEM_SIZE || tail['['/]9[']'/] <= 0)
				&& (10 >= MEM_SIZE || tail['['/]10[']'/] <= 0)
				&& (11 >= MEM_SIZE || tail['['/]11[']'/] <= 0)
				&& (12 >= MEM_SIZE || tail['['/]12[']'/] <= 0)
				&& (13 >= MEM_SIZE || tail['['/]13[']'/] <= 0)
				&& (14 >= MEM_SIZE || tail['['/]14[']'/] <= 0)
				&& (15 >= MEM_SIZE || tail['['/]15[']'/] <= 0)
				&& (16 >= MEM_SIZE || tail['['/]16[']'/] <= 0)
				&& (17 >= MEM_SIZE || tail['['/]17[']'/] <= 0)
				&& (18 >= MEM_SIZE || tail['['/]18[']'/] <= 0)
				&& (19 >= MEM_SIZE || tail['['/]19[']'/] <= 0)
				&& (20 >= MEM_SIZE || tail['['/]20[']'/] <= 0)
				//...
				//extend if more memory is required
				//...
				) -> break;	//tail['['/]i[']'/] > 0 iff buffer not empty
			::else -> flushB(); 
			fi;
		od;
	}
}

inline fenceWithResponse() {
	mfenceB();
	channel ! iMfence, NULL, NULL, NULL;
}
	
inline casB() 
{
	mfenceB();	//buffer must be empty
	atomic{
	assert(address != 0);
	i = memory['['/]address[']'/];
	if 
		:: memory['['/]address[']'/] == value 
			-> 	memory['['/]address[']'/] = newValue;
		:: else -> skip;
	fi;
	channel ! iCas, NULL, i, NULL;
	address = 0;
	value = 0;
	newValue = 0;
	i = 0;
	}
}




proctype bufferProcess(chan channel)
{		
	/*start resp. end of queue*/
	short i = 0;
	short address = 0;
	short flushAdr = 0;
	short value = 0; 
	short newValue = 0;
	SingleAdrBuffer buffer ['['/]MEM_SIZE[']'/];
	short tail ['['/]MEM_SIZE[']'/];

	
end:	do 
		::	if
				//WRITE
				:: atomic{channel ? iWrite(address,value, NULL) -> writeB();
					//i = 0; address = 0; value = 0; newValue = 0; //can reduce state space, but not reliably
					}
				//READ
				:: atomic{channel ? iRead, address, NULL, NULL -> readB();
					//i = 0; address = 0; value = 0; newValue = 0; //can reduce state space, but not reliably
					}
				//FLUSH
				:: atomic{flushB();  
					//i = 0; address = 0; value = 0; newValue = 0; //can reduce state space, but not reliably
					}
				//FENCE
				:: atomic{channel ? iMfence, NULL, NULL, NULL -> fenceWithResponse();
					//i = 0; address = 0; value = 0; newValue = 0; //can reduce state space, but not reliably
					}
				//COMPARE AND SWAP
				:: atomic{channel ? iCas, address , value, newValue -> casB();
					//i = 0; address = 0; value = 0; newValue = 0; //can reduce state space, but not reliably
					};
			fi
		od
}
// [/protected]
[/file]
[/template]

