-- @path LLVM=/de.upb.llvm_parser/src-gen/de/upb/llvm_parser/LLVM.ecore
-- @path LLL=/de.upb.lina.lll/model/LLL.ecore


module lllbasis;
create lll: LLL from llvm: LLVM;

--****************************************--
--                                        --
--                 Helpers                --
--                                        --
--****************************************--
helper def: stringcut(input: String, char: String): String =
	if input.lastIndexOf(char) > -1 then
		input.substring(input.lastIndexOf(char) + 2, input.size())
	else
		input
	endif;

helper def: getValue(inValue: LLVM!Value): OclAny =
	if (inValue.oclIsTypeOf(LLVM!Constant)) then
		thisModule.createConstant(inValue)
	else
		if (inValue.oclIsTypeOf(LLVM!NonConstantValue)) then
			thisModule.createNonConstantValue(inValue)
		else
			thisModule.createValue(inValue)
		endif
	endif;

helper def: getType(inType: LLVM!TypeUse): OclAny =
	if (inType.oclIsUndefined()) then
		OclUndefined
	else
		if (inType.oclIsTypeOf(LLVM!Address)) then
			if inType.name.endsWith('*') then
				thisModule.createAddress__Pointer(inType)
			else
				thisModule.createAddress__ComplexType(inType)
			endif
		else
			if (inType.oclIsTypeOf(LLVM!Predefined)) and inType.type.startsWith('i') then
				thisModule.createPredefinedInteger(inType)
			else
				OclUndefined
			endif
		endif
	endif;

helper def: numberReg(input: String): String =
	if input.regexReplaceAll('[0-9]+', '').size()>0 then input else 'v'+input endif
;
--****************************************--
--                                        --
--                  Form                  --
--                                        --
--****************************************--
rule Program {
	from
		in_llvm: LLVM!LLVM
	using {
		lllfunctions: Set(LLVM!FunctionDefinition) = in_llvm.elements -> select(t | t.oclIsTypeOf(LLVM!FunctionDefinition));
	}
	to
		program: LLL!Program (
			functions <- lllfunctions -> collect(fun | thisModule.resolveTemp(fun, 'lllfunction'))
		)
}

rule functions {
	from
		inFunction: LLVM!FunctionDefinition
	using {
		fBody: LLVM!FunctionBody = inFunction.body;
		fBlocks: Sequence(LLVM!BasicBlock) = if fBody.oclIsUndefined() then
			OclUndefined
		else
			fBody.blocks -> collect(t | t) -> flatten()
		endif;
		inst: OrderedSet(LLVM!Instruction) = if fBlocks.oclIsUndefined() then
			OclUndefined
		else
			fBlocks -> collect(b | b.instructions.append(b.terminator)).flatten()
		endif;
	}
	to
		lllfunction: LLL!Function (
			name <- inFunction.address.name,
			instructions <- if inst.oclIsUndefined() then
					OclUndefined
				else
					inst -> collect(i | thisModule.resolveTemp(i, 'outI'))
				endif,
			labels <- if fBlocks.oclIsUndefined() then
					OclUndefined
				else
					fBlocks -> collect(b | thisModule.bindLabel(b, lllfunction))
				endif,
			localVariablesOrValues <- if fBlocks.oclIsUndefined() then
					OclUndefined
				else
					fBlocks -> collect(b | b.instructions -> collect(iu | if iu.oclIsTypeOf(LLVM!InstructionUse) then
									thisModule.resolveTemp(iu, 'intReg')
								else
									OclUndefined
								endif)).excluding(OclUndefined)
				endif
		)
}

rule bindLabel(block: LLVM!BasicBlock, lllfunction: LLL!Function) {
	to
		bbLabel: LLL!Label (
			function <- lllfunction,
			instruction <- thisModule.resolveTemp(block.instructions.first(), 'outI'),
			name <- block.label
		)
	do {
		bbLabel; 
	}
}

--****************************************--
--                                        --
--                 Values                 --
--                                        --
--****************************************--
lazy rule createConstant {
	from
		con: LLVM!Constant
	to
		outV: LLL!Constant (
			value <- con.value.toString()
		)
}

lazy rule createNonConstantValue {
	from
		ncv: LLVM!NonConstantValue
	to
		outV: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(ncv.name, '%'), '@'))
		)
}

lazy rule createValue {
	from
		value: LLVM!Value (
			not value.oclIsTypeOf(LLVM!Constant) and not value.oclIsTypeOf(LLVM!NonConstantValue) and not value.name.oclIsUndefined()
		)
	to
		outV: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(value.name, '%'), '@'))
		)
}

--****************************************--
--                                        --
--                  Type                  --
--                                        --
--****************************************--
lazy rule createPredefinedInteger {
	from
		predef: LLVM!Predefined (
			predef.type.startsWith('i')
		)
	to
		outT: LLL!SimpleType (
			type <- if predef.type.endsWith('*') then #pointer else if predef.type = 'i1' then #bool else #int endif endif
		)
}

lazy rule createAddress__ComplexType {
	from
		address: LLVM!Address (
			not address.name.endsWith('*')
		)
	to
		outT: LLL!ComplexType (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(address.name, '%'), '@'))
		)
}

lazy rule createAddress__Pointer {
	from
		address: LLVM!Address (
			address.name.endsWith('*')
		)
	to
		outT: LLL!SimpleType (
			type <-  #pointer
		)
}

--****************************************--
--                                        --
--              Instructions              --
--                                        --
--****************************************--
rule LoadUse {
	from
		insUse: LLVM!InstructionUse (
			insUse.instruction.oclIsTypeOf(LLVM!Load)
		)
	to
		outI: LLL!MemoryInstruction (
			instructionType <- #Load,
			parameters <- thisModule.getValue(insUse.instruction.adress).refSetValue('type', thisModule.getType(insUse.instruction.adresstype)),
			instructionResult <- intReg
		),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
}

rule AllocUse {
	from
		insUse: LLVM!InstructionUse (
			insUse.instruction.oclIsTypeOf(LLVM!Alloc)
		)
	to
		outI: LLL!MemoryInstruction (
			instructionType <- #Alloca,
			parameters <- if insUse.instruction.numelementsvalue.oclIsUndefined() then
					thisModule.createAllocaParam(insUse.instruction)
				else
					thisModule.getValue(insUse.instruction.numelementsvalue).refSetValue('type', thisModule.getType(insUse.instruction.type))
				endif,
			instructionResult <- intReg
		),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
}

rule PhiUse {
	from
		insUse: LLVM!InstructionUse (
			insUse.instruction.oclIsTypeOf(LLVM!Phi)
		)
	to
		outI: LLL!LocalComputation (
			parameters <- OrderedSet{thisModule.getValue(insUse.instruction.firstclass.first()).refSetValue('type', thisModule.getType(insUse.instruction.type)),
						thisModule.getValue(insUse.instruction.values.first()),
						thisModule.getValue(insUse.instruction.firstclass.at(2)),
						thisModule.getValue(insUse.instruction.values.at(2))},
			instructionResult <- intReg
		),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
}

--rule CompareUse {
--	from
--		insUse: LLVM!InstructionUse(insUse.instruction.oclIsTypeOf(LLVM!Compare))
--	to
--		cmpExpr :EXPR!(
--

--		)
--}

rule Store {
	from
		instruction: LLVM!Store
	to
		outI: LLL!MemoryInstruction (
			instructionType <- #Store,
			parameters <- OrderedSet{thisModule.getValue(instruction.newvalue).refSetValue('type', thisModule.getType(instruction.newtype)),
						thisModule.getValue(instruction.adress).refSetValue('type', thisModule.getType(instruction.adresstype))}
		)
}


lazy rule createAllocaParam {
	from
		instruction: LLVM!Alloc
	to
		intParam: LLL!Constant (
			type <- thisModule.getType(instruction.type),
			value <- OclUndefined
		)
}

rule Branch {
	from
		instruction: LLVM!Branch (
			instruction.destination.oclIsUndefined()
		)
	to
		outI: LLL!ConditionalBranch (
			elseTarget <- LLL!Label.allInstances() -> select(i | i.name = thisModule.stringcut(instruction.labelFalse.name, '%') and i.function.instructions.includes(thisModule.
					resolveTemp(instruction, 'outI'))),
			target <- LLL!Label.allInstances() -> select(i | i.name = thisModule.stringcut(instruction.labelTrue.name, '%') and
					i.function.instructions.includes(thisModule.resolveTemp(instruction, 'outI'))) 
--					,
--			condition <- thisModule.resolveTemp(, 'cmpExpr')
			
		)
}

rule Goto {
	from
		instruction: LLVM!Branch (
			not instruction.destination.oclIsUndefined()
		)
	to
		outI: LLL!Goto (
			target <- LLL!Label.allInstances() -> select(i | (i.name = thisModule.stringcut(instruction.destination.name, '%'))and i.function.instructions.includes(thisModule.
					resolveTemp(instruction, 'outI')))
		)
}

rule Return {
	from
		instruction: LLVM!Return
	to
		outI: LLL!LocalComputation (
			instructionResult <- return
		),
		return: LLL!Variable (
			name <- 'return ' + if instruction.returnvalue.oclIsUndefined() then
					''
				else
					instruction.returnvalue.name
				endif,
			type <- thisModule.getType(instruction.returntype)
		)
}
