-- @path LLVM=/de.upb.llvm_parser/src-gen/de/upb/llvm_parser/LLVM.ecore
-- @path LLL=/de.upb.lina.lll/model/LLL.ecore
-- @path EXPR=/de.upb.lina.lll.expressions/src-gen/de/upb/lina/lll/Expressions.ecore


module lllbasis;
create lll: LLL, expr:EXPR from llvm: LLVM;
--create lll: LLL,expr : EXPR from llvm: LLVM;

--****************************************--
--                                        --
--                 Helpers                --
--                                        --
--****************************************--
helper def: stringcut(input: String, char: String): String =
	if input.lastIndexOf(char) > -1 then
		input.substring(input.lastIndexOf(char) + 2, input.size())
	else
		input
	endif;

helper def: getValue(inValue: LLVM!Value): OclAny =
	if (inValue.oclIsTypeOf(LLVM!Constant)) then
		thisModule.createConstant(inValue)
	else
		if (inValue.oclIsTypeOf(LLVM!NonConstantValue)) then
			thisModule.createNonConstantValue(inValue)
		else
			thisModule.createValue(inValue)
		endif
	endif;

helper def: getType(inType: LLVM!TypeUse): OclAny =
	if (inType.oclIsUndefined()) then
		OclUndefined
	else
		if (inType.oclIsTypeOf(LLVM!Address)) then
			if inType.name.endsWith('*') then
				thisModule.createAddress__Pointer(inType)
			else
				thisModule.createAddress__ComplexType(inType)
			endif
		else
			if (inType.oclIsTypeOf(LLVM!Predefined)) and inType.type.startsWith('i') then
				thisModule.createPredefinedInteger(inType)
			else
				OclUndefined
			endif
		endif
	endif;

helper def: numberReg(input: String): String =
	if input.regexReplaceAll('[0-9]+', '').size()>0 then input else 'v' + input endif;

helper def: getVariable(input: String): LLL!Variable =
	LLL!Variable.allInstances() -> select(v | v.name = thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(input, '%'), '@'))) -> first();

helper def: getConstant(input: String): LLL!Constant =
	LLL!Constant.allInstances() -> select(c | c.value = thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(input, '%'), '@'))) -> first();


--****************************************--
--                                        --
--                  Form                  --
--                                        --
--****************************************--
rule Program {
	from
		in_llvm: LLVM!LLVM
	using {
		lllfunctions: Set(LLVM!FunctionDefinition) = in_llvm.elements -> select(t | t.oclIsTypeOf(LLVM!FunctionDefinition));
		globals : Set(LLVM!GlobalDefinition) = in_llvm.elements -> select(g | g.oclIsTypeOf(LLVM!GlobalDefinition));
	}
	to
		program: LLL!Program (
			functions <- lllfunctions -> collect(fun | thisModule.resolveTemp(fun, 'lllfunction')),
			globalVariables <- globals -> collect(g | thisModule.resolveTemp(g, 'outV'))
		)
}

rule functions {
	from
		inFunction: LLVM!FunctionDefinition
	using {
		fBody: LLVM!FunctionBody = inFunction.body;
		fBlocks: Sequence(LLVM!BasicBlock) = if fBody.oclIsUndefined() then
				OclUndefined
			else
				fBody.blocks -> collect(t | t) -> flatten()
			endif;
		inst: OrderedSet(LLVM!Instruction) = if fBlocks.oclIsUndefined() then
				OclUndefined
			else
				fBlocks -> collect(b | b.instructions.append(b.terminator)).flatten()
			endif;
	}
	to
		lllfunction: LLL!Function (
			name <- inFunction.address.name,
			instructions <- if inst.oclIsUndefined() then
					OclUndefined
				else
					inst -> collect(i | thisModule.resolveTemp(i, 'outI'))
				endif,
			labels <- if fBlocks.oclIsUndefined() then
					OclUndefined
				else
					fBlocks -> collect(b | thisModule.bindLabel(b, lllfunction))
				endif,
			localVariablesOrValues <- if fBlocks.oclIsUndefined() then
					OclUndefined
				else
					fBlocks -> collect(b | b.instructions -> collect(iu | if iu.oclIsTypeOf(LLVM!InstructionUse) then
									thisModule.resolveTemp(iu, 'intReg')
								else
									OclUndefined
								endif)).excluding(OclUndefined)
				endif,
			inputParameters <- if inFunction.pl.oclIsUndefined() then OclUndefined else inFunction.pl.variables -> collect(i | thisModule.getValue(i).refSetValue('type', thisModule.getType(inFunction.pl.types.at(inFunction.pl.variables.indexOf(i))))) endif
		)
}

rule GlobalDef{
	from global : LLVM!GlobalDefinition
	to outV : LLL!Variable (
		name <- thisModule.stringcut(thisModule.stringcut(global.adress.name, '%'), '@'),
		type <- if global.type.oclIsTypeOf(LLVM!Array) then OclUndefined else thisModule.getType(global.type) endif
	)
}

rule bindLabel(block: LLVM!BasicBlock, lllfunction: LLL!Function) {
	to
		bbLabel: LLL!Label (
			function <- lllfunction,
			instruction <- thisModule.resolveTemp(block.instructions.first(), 'outI'),
			name <- block.label
		)
	do {
		bbLabel; 
	}
}

--****************************************--
--                                        --
--                 Values                 --
--                                        --
--****************************************--
lazy rule createConstant {
	from
		con: LLVM!Constant
	to
		outV: LLL!Constant (
			value <- con.value.toString()
		)
}

lazy rule createNonConstantValue {
	from
		ncv: LLVM!NonConstantValue
	to
		outV: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(ncv.name, '%'), '@'))
		)
}

lazy rule createValue {
	from
		value: LLVM!Value (
			not value.oclIsTypeOf(LLVM!Constant) and not value.oclIsTypeOf(LLVM!NonConstantValue) and not value.name.oclIsUndefined()
		)
	to
		outV: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(value.name, '%'), '@'))
		)
}

--****************************************--
--                                        --
--                  Type                  --
--                                        --
--****************************************--
lazy rule createPredefinedInteger {
	from
		predef: LLVM!Predefined (
			predef.type.startsWith('i')
		)
	to
		outT: LLL!SimpleType (
			type <- if predef.type.endsWith('*') then #pointer else if predef.type = 'i1' then #bool else #int endif endif
		)
}

lazy rule createAddress__ComplexType {
	from
		address: LLVM!Address (
			not address.name.endsWith('*')
		)
	to
		outT: LLL!ComplexType (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(address.name, '%'), '@'))
		)
}

lazy rule createAddress__Pointer {
	from
		address: LLVM!Address (
			address.name.endsWith('*')
		)
	to
		outT: LLL!SimpleType (
			type <-  #pointer
		)
}

--****************************************--
--                                        --
--              Instructions              --
--                                        --
--****************************************--
rule LoadUse {
	from
		insUse: LLVM!InstructionUse (
			insUse.instruction.oclIsTypeOf(LLVM!Load)
		)
	to
		outI: LLL!MemoryInstruction (
			instructionType <- #Load,
			parameters <- thisModule.getValue(insUse.instruction.adress).refSetValue('type', thisModule.getType(insUse.instruction.adresstype)),
			instructionResult <- intReg
		),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
}

rule AllocUse {
	from
		insUse: LLVM!InstructionUse (
			insUse.instruction.oclIsTypeOf(LLVM!Alloc)
		)
	to
		outI: LLL!MemoryInstruction (
			instructionType <- #Alloca,
			parameters <- if insUse.instruction.numelementsvalue.oclIsUndefined() then
					thisModule.createAllocaParam(insUse.instruction)
				else
					thisModule.getValue(insUse.instruction.numelementsvalue).refSetValue('type', thisModule.getType(insUse.instruction.type))
				endif,
			instructionResult <- intReg
		),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
}

rule PhiUse {
	from
		insUse: LLVM!InstructionUse (
			insUse.instruction.oclIsTypeOf(LLVM!Phi)
		)
	to
		outI: LLL!LocalComputation (
			parameters <- OrderedSet{thisModule.getValue(insUse.instruction.firstclass.first()).refSetValue('type', thisModule.getType(insUse.instruction.type)),
						thisModule.getValue(insUse.instruction.values.first()),
						thisModule.getValue(insUse.instruction.firstclass.at(2)),
						thisModule.getValue(insUse.instruction.values.at(2))},
			instructionResult <- intReg
		),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
}

rule CompareUse {
	from
		insUse: LLVM!InstructionUse(insUse.instruction.oclIsTypeOf(LLVM!Compare))
	to
		outI :LLL!LocalComputation(
--			expression <- 
			instructionResult <- intReg

		),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
}

rule CompareAndChangeUse {
	from
		insUse: LLVM!InstructionUse(insUse.instruction.oclIsTypeOf(LLVM!CmpXchg))
	to
		outI :LLL!MemoryInstruction(
			instructionType <- #CompareAndSwap,
			parameters <- OrderedSet{thisModule.getValue(insUse.instruction.adress).refSetValue('type', thisModule.getType(insUse.instruction.adresstype)),
					thisModule.getValue(insUse.instruction.comparevalue).refSetValue('type', thisModule.getType(insUse.instruction.comparetype)),
					thisModule.getValue(insUse.instruction.newvalue).refSetValue('type', thisModule.getType(insUse.instruction.newtype))
			},
			instructionResult <- intReg

		),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
}

rule GetElementPtrUse {
	from
		insUse: LLVM!InstructionUse(insUse.instruction.oclIsTypeOf(LLVM!GetElementPtr) or insUse.instruction.oclIsTypeOf(LLVM!NestedGetElementPtr))
	to
		outI :LLL!MemoryInstruction(
			instructionType <- #GetElementPointer,
			parameters <- insUse.instruction.indizies -> collect(i | thisModule.getValue(i)).asOrderedSet().append(thisModule.getValue(insUse.instruction.aggregatename)),
			instructionResult <- intReg

		),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
}

rule CallUse{
	from
		insUse: LLVM!InstructionUse(insUse.instruction.oclIsTypeOf(LLVM!Call))
	to
		outI :LLL!FunctionCall(
			invokedFunction <- LLL!Function.allInstances() -> select(i | i.name = insUse.instruction.adress.name).first(),
			instructionResult <- intReg

		),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
}
rule ArithmeticUse{
	from insUse : LLVM!InstructionUse(insUse.instruction.oclIsTypeOf(LLVM!ArithmeticOperation))
	to outI : LLL!LocalComputation(
--		expression <- expr, 
		instructionResult <- intReg
	),
		intReg: LLL!Variable (
			name <- thisModule.numberReg(thisModule.stringcut(thisModule.stringcut(insUse.reg_or_var, '%'), '@'))
		)
--		,
--		expr : EXPR!AExpression()
}

rule Store {
	from
		instruction: LLVM!Store
	to
		outI: LLL!MemoryInstruction (
			instructionType <- #Store,
			parameters <- OrderedSet{thisModule.getValue(instruction.newvalue).refSetValue('type', thisModule.getType(instruction.newtype)),
						thisModule.getValue(instruction.adress).refSetValue('type', thisModule.getType(instruction.adresstype))}
		)
}

rule Fence {
	from
		instruction: LLVM!Fence
	to
		outI: LLL!MemoryInstruction(
			instructionType <- #Fence
		)
}

lazy rule createAllocaParam {
	from
		instruction: LLVM!Alloc
	to
		intParam: LLL!Constant (
			type <- thisModule.getType(instruction.type),
			value <- if instruction.numelementsvalue.oclIsUndefined() then '1' else thisModule.getValue(instruction.numelementsvalue) endif
		)
}

rule Branch {
	from
		instruction: LLVM!Branch (
			instruction.destination.oclIsUndefined()
		)
	to
		outI: LLL!ConditionalBranch (
			elseTarget <- LLL!Label.allInstances() -> select(i | i.name = thisModule.stringcut(instruction.labelFalse.name, '%') and i.function.instructions.includes(thisModule.
					resolveTemp(instruction, 'outI'))).first(),
			target <- LLL!Label.allInstances() -> select(i | i.name = thisModule.stringcut(instruction.labelTrue.name, '%') and
					i.function.instructions.includes(thisModule.resolveTemp(instruction, 'outI'))).first()
--					,
--			condition <- thisModule.resolveTemp(, 'cmpExpr')
			
		)
}

rule Goto {
	from
		instruction: LLVM!Branch (
			not instruction.destination.oclIsUndefined()
		)
	to
		outI: LLL!Goto (
			target <- LLL!Label.allInstances() -> select(i | (i.name = thisModule.stringcut(instruction.destination.name, '%'))and i.function.instructions.includes(thisModule.
					resolveTemp(instruction, 'outI'))).first()
		)
}

rule Return {
	from
		instruction: LLVM!Return (instruction.returnvalue.oclIsUndefined())
	to
		outI: LLL!Return (
		)
}
rule ReturnValue {
	from
		instruction: LLVM!Return (not instruction.returnvalue.oclIsUndefined())
	to
		outI: LLL!Return (
			parameters <- thisModule.getValue(instruction.returnvalue).refSetValue('type', thisModule.getType(instruction.returntype))
		)
}