/*
* generated by Xtext
*/

package de.upb.llvm_parser.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class LLVMGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class LLVMElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LLVM");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsAbstractElementParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		/// *
		//
		// * This Grammer is used to parse a llvm document.
		//
		// * The llvm project itself is located at http://llvm.org
		//
		// * For a language introduction see: http://llvm.org/docs/LangRef.html
		//
		// * A list of guides can be found on: http://llvm.org/docs/userguides.html
		//
		// * / LLVM:
		//
		//	elements+=AbstractElement*;
		public ParserRule getRule() { return rule; }

		//elements+=AbstractElement*
		public Assignment getElementsAssignment() { return cElementsAssignment; }

		//AbstractElement
		public RuleCall getElementsAbstractElementParserRuleCall_0() { return cElementsAbstractElementParserRuleCall_0; }
	}

	public class AbstractElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbstractElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cTopLevelEntityParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cSL_COMMENTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cMainLevelEntityParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cSL_COMMENTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		/// *
		//
		// * An Abstract Element is either a TopLevelEntity, used for the predefinitions of the llvm-code
		//
		// * or a MainLevelEntity, which are basically functiondefinitions. 
		//
		// * / AbstractElement:
		//
		//	TopLevelEntity SL_COMMENT? | MainLevelEntity SL_COMMENT?;
		public ParserRule getRule() { return rule; }

		//TopLevelEntity SL_COMMENT? | MainLevelEntity SL_COMMENT?
		public Alternatives getAlternatives() { return cAlternatives; }

		//TopLevelEntity SL_COMMENT?
		public Group getGroup_0() { return cGroup_0; }

		//TopLevelEntity
		public RuleCall getTopLevelEntityParserRuleCall_0_0() { return cTopLevelEntityParserRuleCall_0_0; }

		//SL_COMMENT?
		public RuleCall getSL_COMMENTTerminalRuleCall_0_1() { return cSL_COMMENTTerminalRuleCall_0_1; }

		//MainLevelEntity SL_COMMENT?
		public Group getGroup_1() { return cGroup_1; }

		//MainLevelEntity
		public RuleCall getMainLevelEntityParserRuleCall_1_0() { return cMainLevelEntityParserRuleCall_1_0; }

		//SL_COMMENT?
		public RuleCall getSL_COMMENTTerminalRuleCall_1_1() { return cSL_COMMENTTerminalRuleCall_1_1; }
	}

	public class TopLevelEntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TopLevelEntity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cModuleKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cAsmKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cModuleAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cModuleSTRINGTerminalRuleCall_0_2_0 = (RuleCall)cModuleAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cTargetKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cDatalayoutKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cTripleKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cTargetAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cTargetSTRINGTerminalRuleCall_1_3_0 = (RuleCall)cTargetAssignment_1_3.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cDeplibsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final RuleCall cARRAYLTerminalRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		private final Assignment cLibsAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cLibsSTRINGTerminalRuleCall_2_3_0 = (RuleCall)cLibsAssignment_2_3.eContents().get(0);
		private final Group cGroup_2_4 = (Group)cGroup_2.eContents().get(4);
		private final Keyword cCommaKeyword_2_4_0 = (Keyword)cGroup_2_4.eContents().get(0);
		private final Assignment cLibsAssignment_2_4_1 = (Assignment)cGroup_2_4.eContents().get(1);
		private final RuleCall cLibsSTRINGTerminalRuleCall_2_4_1_0 = (RuleCall)cLibsAssignment_2_4_1.eContents().get(0);
		private final RuleCall cARRAYRTerminalRuleCall_2_5 = (RuleCall)cGroup_2.eContents().get(5);
		
		/// *
		//
		// * Predefinitions of the llcm-code
		//
		// * / TopLevelEntity:
		//
		//	"module" "asm" module=STRING | "target" ("datalayout" | "triple") "=" target=STRING | "deplibs" "=" ARRAYL
		//
		//	libs+=STRING ("," libs+=STRING)* ARRAYR;
		public ParserRule getRule() { return rule; }

		//"module" "asm" module=STRING | "target" ("datalayout" | "triple") "=" target=STRING | "deplibs" "=" ARRAYL libs+=STRING
		//
		//("," libs+=STRING)* ARRAYR
		public Alternatives getAlternatives() { return cAlternatives; }

		//"module" "asm" module=STRING
		public Group getGroup_0() { return cGroup_0; }

		//"module"
		public Keyword getModuleKeyword_0_0() { return cModuleKeyword_0_0; }

		//"asm"
		public Keyword getAsmKeyword_0_1() { return cAsmKeyword_0_1; }

		//module=STRING
		public Assignment getModuleAssignment_0_2() { return cModuleAssignment_0_2; }

		//STRING
		public RuleCall getModuleSTRINGTerminalRuleCall_0_2_0() { return cModuleSTRINGTerminalRuleCall_0_2_0; }

		//"target" ("datalayout" | "triple") "=" target=STRING
		public Group getGroup_1() { return cGroup_1; }

		//"target"
		public Keyword getTargetKeyword_1_0() { return cTargetKeyword_1_0; }

		//"datalayout" | "triple"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"datalayout"
		public Keyword getDatalayoutKeyword_1_1_0() { return cDatalayoutKeyword_1_1_0; }

		//"triple"
		public Keyword getTripleKeyword_1_1_1() { return cTripleKeyword_1_1_1; }

		//"="
		public Keyword getEqualsSignKeyword_1_2() { return cEqualsSignKeyword_1_2; }

		//target=STRING
		public Assignment getTargetAssignment_1_3() { return cTargetAssignment_1_3; }

		//STRING
		public RuleCall getTargetSTRINGTerminalRuleCall_1_3_0() { return cTargetSTRINGTerminalRuleCall_1_3_0; }

		//"deplibs" "=" ARRAYL libs+=STRING ("," libs+=STRING)* ARRAYR
		public Group getGroup_2() { return cGroup_2; }

		//"deplibs"
		public Keyword getDeplibsKeyword_2_0() { return cDeplibsKeyword_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_1() { return cEqualsSignKeyword_2_1; }

		//ARRAYL
		public RuleCall getARRAYLTerminalRuleCall_2_2() { return cARRAYLTerminalRuleCall_2_2; }

		//libs+=STRING
		public Assignment getLibsAssignment_2_3() { return cLibsAssignment_2_3; }

		//STRING
		public RuleCall getLibsSTRINGTerminalRuleCall_2_3_0() { return cLibsSTRINGTerminalRuleCall_2_3_0; }

		//("," libs+=STRING)*
		public Group getGroup_2_4() { return cGroup_2_4; }

		//","
		public Keyword getCommaKeyword_2_4_0() { return cCommaKeyword_2_4_0; }

		//libs+=STRING
		public Assignment getLibsAssignment_2_4_1() { return cLibsAssignment_2_4_1; }

		//STRING
		public RuleCall getLibsSTRINGTerminalRuleCall_2_4_1_0() { return cLibsSTRINGTerminalRuleCall_2_4_1_0; }

		//ARRAYR
		public RuleCall getARRAYRTerminalRuleCall_2_5() { return cARRAYRTerminalRuleCall_2_5; }
	}

	public class MainLevelEntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MainLevelEntity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		//
		// * This rule is used to devide the Function Definitions form the Variable Definitions.
		//
		// * / //	| AliasDefinition
		//
		//MainLevelEntity:
		//
		//	TypeDefinition | FunctionDefinition;
		public ParserRule getRule() { return rule; }

		//TypeDefinition | FunctionDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//TypeDefinition
		public RuleCall getTypeDefinitionParserRuleCall_0() { return cTypeDefinitionParserRuleCall_0; }

		//FunctionDefinition
		public RuleCall getFunctionDefinitionParserRuleCall_1() { return cFunctionDefinitionParserRuleCall_1; }
	}

	public class TypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAddressAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAddressAddressParserRuleCall_0_0 = (RuleCall)cAddressAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cLINKAGEParserRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final Keyword cGlobalKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Keyword cUnnamed_addrKeyword_2_2 = (Keyword)cAlternatives_2.eContents().get(2);
		private final Keyword cConstantKeyword_2_3 = (Keyword)cAlternatives_2.eContents().get(3);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cTypeKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Alternatives cAlternatives_3_1 = (Alternatives)cGroup_3.eContents().get(1);
		private final Assignment cStructAssignment_3_1_0 = (Assignment)cAlternatives_3_1.eContents().get(0);
		private final RuleCall cStructStructureParserRuleCall_3_1_0_0 = (RuleCall)cStructAssignment_3_1_0.eContents().get(0);
		private final RuleCall cOpaqueParserRuleCall_3_1_1 = (RuleCall)cAlternatives_3_1.eContents().get(1);
		
		//TypeDefinition:
		//
		//	address=Address "=" (LINKAGE | "global" | "unnamed_addr" | "constant")* ("type" (struct=Structure | Opaque));
		public ParserRule getRule() { return rule; }

		//address=Address "=" (LINKAGE | "global" | "unnamed_addr" | "constant")* ("type" (struct=Structure | Opaque))
		public Group getGroup() { return cGroup; }

		//address=Address
		public Assignment getAddressAssignment_0() { return cAddressAssignment_0; }

		//Address
		public RuleCall getAddressAddressParserRuleCall_0_0() { return cAddressAddressParserRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//(LINKAGE | "global" | "unnamed_addr" | "constant")*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//LINKAGE
		public RuleCall getLINKAGEParserRuleCall_2_0() { return cLINKAGEParserRuleCall_2_0; }

		//"global"
		public Keyword getGlobalKeyword_2_1() { return cGlobalKeyword_2_1; }

		//"unnamed_addr"
		public Keyword getUnnamed_addrKeyword_2_2() { return cUnnamed_addrKeyword_2_2; }

		//"constant"
		public Keyword getConstantKeyword_2_3() { return cConstantKeyword_2_3; }

		//"type" (struct=Structure | Opaque)
		public Group getGroup_3() { return cGroup_3; }

		//"type"
		public Keyword getTypeKeyword_3_0() { return cTypeKeyword_3_0; }

		//struct=Structure | Opaque
		public Alternatives getAlternatives_3_1() { return cAlternatives_3_1; }

		//struct=Structure
		public Assignment getStructAssignment_3_1_0() { return cStructAssignment_3_1_0; }

		//Structure
		public RuleCall getStructStructureParserRuleCall_3_1_0_0() { return cStructStructureParserRuleCall_3_1_0_0; }

		//Opaque
		public RuleCall getOpaqueParserRuleCall_3_1_1() { return cOpaqueParserRuleCall_3_1_1; }
	}

	public class FunctionDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cDefineKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cLINKAGEParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cVISIBILITYParserRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final RuleCall cCallingConvParserRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_0_4 = (RuleCall)cGroup_0.eContents().get(4);
		private final Assignment cReturnTypeAssignment_0_5 = (Assignment)cGroup_0.eContents().get(5);
		private final RuleCall cReturnTypeTypeUseParserRuleCall_0_5_0 = (RuleCall)cReturnTypeAssignment_0_5.eContents().get(0);
		private final Assignment cAddressAssignment_0_6 = (Assignment)cGroup_0.eContents().get(6);
		private final RuleCall cAddressAddressParserRuleCall_0_6_0 = (RuleCall)cAddressAssignment_0_6.eContents().get(0);
		private final Assignment cPlAssignment_0_7 = (Assignment)cGroup_0.eContents().get(7);
		private final RuleCall cPlParameterListParserRuleCall_0_7_0 = (RuleCall)cPlAssignment_0_7.eContents().get(0);
		private final Keyword cUnnamed_addrKeyword_0_8 = (Keyword)cGroup_0.eContents().get(8);
		private final RuleCall cFUNCTION_ATTRIBUTESParserRuleCall_0_9 = (RuleCall)cGroup_0.eContents().get(9);
		private final Group cGroup_0_10 = (Group)cGroup_0.eContents().get(10);
		private final Keyword cSectionKeyword_0_10_0 = (Keyword)cGroup_0_10.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_0_10_1 = (RuleCall)cGroup_0_10.eContents().get(1);
		private final RuleCall cALIGNMENTParserRuleCall_0_11 = (RuleCall)cGroup_0.eContents().get(11);
		private final Assignment cBodyAssignment_0_12 = (Assignment)cGroup_0.eContents().get(12);
		private final RuleCall cBodyFunctionBodyParserRuleCall_0_12_0 = (RuleCall)cBodyAssignment_0_12.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cDeclareKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cLINKAGEParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cVISIBILITYParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final RuleCall cCallingConvParserRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		private final Assignment cReturnTypeAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cReturnTypeTypeUseParserRuleCall_1_5_0 = (RuleCall)cReturnTypeAssignment_1_5.eContents().get(0);
		private final Assignment cAddressAssignment_1_6 = (Assignment)cGroup_1.eContents().get(6);
		private final RuleCall cAddressAddressParserRuleCall_1_6_0 = (RuleCall)cAddressAssignment_1_6.eContents().get(0);
		private final Alternatives cAlternatives_1_7 = (Alternatives)cGroup_1.eContents().get(7);
		private final Assignment cTListAssignment_1_7_0 = (Assignment)cAlternatives_1_7.eContents().get(0);
		private final RuleCall cTListTypeListParserRuleCall_1_7_0_0 = (RuleCall)cTListAssignment_1_7_0.eContents().get(0);
		private final RuleCall cORESTTerminalRuleCall_1_7_1 = (RuleCall)cAlternatives_1_7.eContents().get(1);
		private final Keyword cUnnamed_addrKeyword_1_8 = (Keyword)cGroup_1.eContents().get(8);
		private final RuleCall cFUNCTION_ATTRIBUTESParserRuleCall_1_9 = (RuleCall)cGroup_1.eContents().get(9);
		private final Group cGroup_1_10 = (Group)cGroup_1.eContents().get(10);
		private final Keyword cSectionKeyword_1_10_0 = (Keyword)cGroup_1_10.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_1_10_1 = (RuleCall)cGroup_1_10.eContents().get(1);
		private final RuleCall cALIGNMENTParserRuleCall_1_11 = (RuleCall)cGroup_1.eContents().get(11);
		
		//FunctionDefinition:
		//
		//	"define" LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=TypeUse address=Address pl=ParameterList
		//
		//	"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT? body=FunctionBody | "declare" LINKAGE?
		//
		//	VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=TypeUse address=Address (tList=TypeList | OREST)
		//
		//	"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT?;
		public ParserRule getRule() { return rule; }

		//"define" LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=TypeUse address=Address pl=ParameterList
		//
		//"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT? body=FunctionBody | "declare" LINKAGE?
		//
		//VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=TypeUse address=Address (tList=TypeList | OREST)
		//
		//"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT?
		public Alternatives getAlternatives() { return cAlternatives; }

		//"define" LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=TypeUse address=Address pl=ParameterList
		//
		//"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT? body=FunctionBody
		public Group getGroup_0() { return cGroup_0; }

		//"define"
		public Keyword getDefineKeyword_0_0() { return cDefineKeyword_0_0; }

		//LINKAGE?
		public RuleCall getLINKAGEParserRuleCall_0_1() { return cLINKAGEParserRuleCall_0_1; }

		//VISIBILITY?
		public RuleCall getVISIBILITYParserRuleCall_0_2() { return cVISIBILITYParserRuleCall_0_2; }

		//CallingConv?
		public RuleCall getCallingConvParserRuleCall_0_3() { return cCallingConvParserRuleCall_0_3; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_0_4() { return cRETURN_ATTRIBUTESParserRuleCall_0_4; }

		//returnType=TypeUse
		public Assignment getReturnTypeAssignment_0_5() { return cReturnTypeAssignment_0_5; }

		//TypeUse
		public RuleCall getReturnTypeTypeUseParserRuleCall_0_5_0() { return cReturnTypeTypeUseParserRuleCall_0_5_0; }

		//address=Address
		public Assignment getAddressAssignment_0_6() { return cAddressAssignment_0_6; }

		//Address
		public RuleCall getAddressAddressParserRuleCall_0_6_0() { return cAddressAddressParserRuleCall_0_6_0; }

		//pl=ParameterList
		public Assignment getPlAssignment_0_7() { return cPlAssignment_0_7; }

		//ParameterList
		public RuleCall getPlParameterListParserRuleCall_0_7_0() { return cPlParameterListParserRuleCall_0_7_0; }

		//"unnamed_addr"?
		public Keyword getUnnamed_addrKeyword_0_8() { return cUnnamed_addrKeyword_0_8; }

		//FUNCTION_ATTRIBUTES*
		public RuleCall getFUNCTION_ATTRIBUTESParserRuleCall_0_9() { return cFUNCTION_ATTRIBUTESParserRuleCall_0_9; }

		//("section " STRING)?
		public Group getGroup_0_10() { return cGroup_0_10; }

		//"section "
		public Keyword getSectionKeyword_0_10_0() { return cSectionKeyword_0_10_0; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0_10_1() { return cSTRINGTerminalRuleCall_0_10_1; }

		//ALIGNMENT?
		public RuleCall getALIGNMENTParserRuleCall_0_11() { return cALIGNMENTParserRuleCall_0_11; }

		//body=FunctionBody
		public Assignment getBodyAssignment_0_12() { return cBodyAssignment_0_12; }

		//FunctionBody
		public RuleCall getBodyFunctionBodyParserRuleCall_0_12_0() { return cBodyFunctionBodyParserRuleCall_0_12_0; }

		//"declare" LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=TypeUse address=Address (tList=TypeList |
		//
		//OREST) "unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT?
		public Group getGroup_1() { return cGroup_1; }

		//"declare"
		public Keyword getDeclareKeyword_1_0() { return cDeclareKeyword_1_0; }

		//LINKAGE?
		public RuleCall getLINKAGEParserRuleCall_1_1() { return cLINKAGEParserRuleCall_1_1; }

		//VISIBILITY?
		public RuleCall getVISIBILITYParserRuleCall_1_2() { return cVISIBILITYParserRuleCall_1_2; }

		//CallingConv?
		public RuleCall getCallingConvParserRuleCall_1_3() { return cCallingConvParserRuleCall_1_3; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_1_4() { return cRETURN_ATTRIBUTESParserRuleCall_1_4; }

		//returnType=TypeUse
		public Assignment getReturnTypeAssignment_1_5() { return cReturnTypeAssignment_1_5; }

		//TypeUse
		public RuleCall getReturnTypeTypeUseParserRuleCall_1_5_0() { return cReturnTypeTypeUseParserRuleCall_1_5_0; }

		//address=Address
		public Assignment getAddressAssignment_1_6() { return cAddressAssignment_1_6; }

		//Address
		public RuleCall getAddressAddressParserRuleCall_1_6_0() { return cAddressAddressParserRuleCall_1_6_0; }

		//tList=TypeList | OREST
		public Alternatives getAlternatives_1_7() { return cAlternatives_1_7; }

		//tList=TypeList
		public Assignment getTListAssignment_1_7_0() { return cTListAssignment_1_7_0; }

		//TypeList
		public RuleCall getTListTypeListParserRuleCall_1_7_0_0() { return cTListTypeListParserRuleCall_1_7_0_0; }

		//OREST
		public RuleCall getORESTTerminalRuleCall_1_7_1() { return cORESTTerminalRuleCall_1_7_1; }

		//"unnamed_addr"?
		public Keyword getUnnamed_addrKeyword_1_8() { return cUnnamed_addrKeyword_1_8; }

		//FUNCTION_ATTRIBUTES*
		public RuleCall getFUNCTION_ATTRIBUTESParserRuleCall_1_9() { return cFUNCTION_ATTRIBUTESParserRuleCall_1_9; }

		//("section " STRING)?
		public Group getGroup_1_10() { return cGroup_1_10; }

		//"section "
		public Keyword getSectionKeyword_1_10_0() { return cSectionKeyword_1_10_0; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1_10_1() { return cSTRINGTerminalRuleCall_1_10_1; }

		//ALIGNMENT?
		public RuleCall getALIGNMENTParserRuleCall_1_11() { return cALIGNMENTParserRuleCall_1_11; }
	}

	public class AliasDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AliasDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAddressAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAddressAddressParserRuleCall_0_0 = (RuleCall)cAddressAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAliasKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cALIAS_LINKAGEParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final RuleCall cVISIBILITYParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final Assignment cAliastypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cAliastypeTypeUseParserRuleCall_5_0 = (RuleCall)cAliastypeAssignment_5.eContents().get(0);
		private final Assignment cAliasvalueAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cAliasvalueValueParserRuleCall_6_0 = (RuleCall)cAliasvalueAssignment_6.eContents().get(0);
		private final Assignment cAliaseeAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cAliaseeTypeUseParserRuleCall_7_0 = (RuleCall)cAliaseeAssignment_7.eContents().get(0);
		
		//AliasDefinition:
		//
		//	address=Address "=" "alias" ALIAS_LINKAGE? VISIBILITY? aliastype=TypeUse aliasvalue=Value aliasee=TypeUse;
		public ParserRule getRule() { return rule; }

		//address=Address "=" "alias" ALIAS_LINKAGE? VISIBILITY? aliastype=TypeUse aliasvalue=Value aliasee=TypeUse
		public Group getGroup() { return cGroup; }

		//address=Address
		public Assignment getAddressAssignment_0() { return cAddressAssignment_0; }

		//Address
		public RuleCall getAddressAddressParserRuleCall_0_0() { return cAddressAddressParserRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"alias"
		public Keyword getAliasKeyword_2() { return cAliasKeyword_2; }

		//ALIAS_LINKAGE?
		public RuleCall getALIAS_LINKAGEParserRuleCall_3() { return cALIAS_LINKAGEParserRuleCall_3; }

		//VISIBILITY?
		public RuleCall getVISIBILITYParserRuleCall_4() { return cVISIBILITYParserRuleCall_4; }

		//aliastype=TypeUse
		public Assignment getAliastypeAssignment_5() { return cAliastypeAssignment_5; }

		//TypeUse
		public RuleCall getAliastypeTypeUseParserRuleCall_5_0() { return cAliastypeTypeUseParserRuleCall_5_0; }

		//aliasvalue=Value
		public Assignment getAliasvalueAssignment_6() { return cAliasvalueAssignment_6; }

		//Value
		public RuleCall getAliasvalueValueParserRuleCall_6_0() { return cAliasvalueValueParserRuleCall_6_0; }

		//aliasee=TypeUse
		public Assignment getAliaseeAssignment_7() { return cAliaseeAssignment_7; }

		//TypeUse
		public RuleCall getAliaseeTypeUseParserRuleCall_7_0() { return cAliaseeTypeUseParserRuleCall_7_0; }
	}

	public class TypeUseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeUse");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPredefinedParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAddressUseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TypeUse:
		//
		//	Predefined | AddressUse;
		public ParserRule getRule() { return rule; }

		//Predefined | AddressUse
		public Alternatives getAlternatives() { return cAlternatives; }

		//Predefined
		public RuleCall getPredefinedParserRuleCall_0() { return cPredefinedParserRuleCall_0; }

		//AddressUse
		public RuleCall getAddressUseParserRuleCall_1() { return cAddressUseParserRuleCall_1; }
	}

	public class AddressUseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AddressUse");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAddressAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cAddressAddressCrossReference_0_0 = (CrossReference)cAddressAssignment_0.eContents().get(0);
		private final RuleCall cAddressAddressVALID_IDTerminalRuleCall_0_0_1 = (RuleCall)cAddressAddressCrossReference_0_0.eContents().get(1);
		private final Assignment cPointerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPointerPOINTERTerminalRuleCall_1_0 = (RuleCall)cPointerAssignment_1.eContents().get(0);
		
		//AddressUse:
		//
		//	address=[Address|VALID_ID] pointer=POINTER?;
		public ParserRule getRule() { return rule; }

		//address=[Address|VALID_ID] pointer=POINTER?
		public Group getGroup() { return cGroup; }

		//address=[Address|VALID_ID]
		public Assignment getAddressAssignment_0() { return cAddressAssignment_0; }

		//[Address|VALID_ID]
		public CrossReference getAddressAddressCrossReference_0_0() { return cAddressAddressCrossReference_0_0; }

		//VALID_ID
		public RuleCall getAddressAddressVALID_IDTerminalRuleCall_0_0_1() { return cAddressAddressVALID_IDTerminalRuleCall_0_0_1; }

		//pointer=POINTER?
		public Assignment getPointerAssignment_1() { return cPointerAssignment_1; }

		//POINTER
		public RuleCall getPointerPOINTERTerminalRuleCall_1_0() { return cPointerPOINTERTerminalRuleCall_1_0; }
	}

	public class AddressElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Address");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameVALID_IDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Address:
		//
		//	name=VALID_ID;
		public ParserRule getRule() { return rule; }

		//name=VALID_ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//VALID_ID
		public RuleCall getNameVALID_IDTerminalRuleCall_0() { return cNameVALID_IDTerminalRuleCall_0; }
	}

	public class PredefinedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Predefined");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypePredefined_TypesParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cPointerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPointerPOINTERTerminalRuleCall_1_0 = (RuleCall)cPointerAssignment_1.eContents().get(0);
		
		//Predefined:
		//
		//	type=Predefined_Types pointer=POINTER?;
		public ParserRule getRule() { return rule; }

		//type=Predefined_Types pointer=POINTER?
		public Group getGroup() { return cGroup; }

		//type=Predefined_Types
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//Predefined_Types
		public RuleCall getTypePredefined_TypesParserRuleCall_0_0() { return cTypePredefined_TypesParserRuleCall_0_0; }

		//pointer=POINTER?
		public Assignment getPointerAssignment_1() { return cPointerAssignment_1; }

		//POINTER
		public RuleCall getPointerPOINTERTerminalRuleCall_1_0() { return cPointerPOINTERTerminalRuleCall_1_0; }
	}

	public class Primitive_TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Primitive_Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cVoidKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLabelKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cUndefKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cTrueKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cFalseKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//Primitive_Type:
		//
		//	"void" | "null" | "label" | "undef" | "true" | "false";
		public ParserRule getRule() { return rule; }

		//"void" | "null" | "label" | "undef" | "true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"void"
		public Keyword getVoidKeyword_0() { return cVoidKeyword_0; }

		//"null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }

		//"label"
		public Keyword getLabelKeyword_2() { return cLabelKeyword_2; }

		//"undef"
		public Keyword getUndefKeyword_3() { return cUndefKeyword_3; }

		//"true"
		public Keyword getTrueKeyword_4() { return cTrueKeyword_4; }

		//"false"
		public Keyword getFalseKeyword_5() { return cFalseKeyword_5; }
	}

	public class FloatingPoint_TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FloatingPoint_Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHalfKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFloatKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDoubleKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cX86_fp80Keyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cFp128Keyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cPpc_fp128Keyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//FloatingPoint_Type:
		//
		//	"half" | "float" | "double" | "x86_fp80" | "fp128" | "ppc_fp128";
		public ParserRule getRule() { return rule; }

		//"half" | "float" | "double" | "x86_fp80" | "fp128" | "ppc_fp128"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"half"
		public Keyword getHalfKeyword_0() { return cHalfKeyword_0; }

		//"float"
		public Keyword getFloatKeyword_1() { return cFloatKeyword_1; }

		//"double"
		public Keyword getDoubleKeyword_2() { return cDoubleKeyword_2; }

		//"x86_fp80"
		public Keyword getX86_fp80Keyword_3() { return cX86_fp80Keyword_3; }

		//"fp128"
		public Keyword getFp128Keyword_4() { return cFp128Keyword_4; }

		//"ppc_fp128"
		public Keyword getPpc_fp128Keyword_5() { return cPpc_fp128Keyword_5; }
	}

	public class Predefined_TypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Predefined_Types");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitive_TypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cINT_TYPETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFloatingPoint_TypeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Predefined_Types:
		//
		//	Primitive_Type | INT_TYPE | FloatingPoint_Type;
		public ParserRule getRule() { return rule; }

		//Primitive_Type | INT_TYPE | FloatingPoint_Type
		public Alternatives getAlternatives() { return cAlternatives; }

		//Primitive_Type
		public RuleCall getPrimitive_TypeParserRuleCall_0() { return cPrimitive_TypeParserRuleCall_0; }

		//INT_TYPE
		public RuleCall getINT_TYPETerminalRuleCall_1() { return cINT_TYPETerminalRuleCall_1; }

		//FloatingPoint_Type
		public RuleCall getFloatingPoint_TypeParserRuleCall_2() { return cFloatingPoint_TypeParserRuleCall_2; }
	}

	public class VectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Vector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cXKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cTypeUseParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Vector:
		//
		//	"<" INT "x" TypeUse ">";
		public ParserRule getRule() { return rule; }

		//"<" INT "x" TypeUse ">"
		public Group getGroup() { return cGroup; }

		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }

		//"x"
		public Keyword getXKeyword_2() { return cXKeyword_2; }

		//TypeUse
		public RuleCall getTypeUseParserRuleCall_3() { return cTypeUseParserRuleCall_3; }

		//">"
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }
	}

	public class ArrayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Array");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cARRAYLTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cXKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cTypeUseParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final RuleCall cARRAYRTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//Array:
		//
		//	ARRAYL INT "x" TypeUse ARRAYR;
		public ParserRule getRule() { return rule; }

		//ARRAYL INT "x" TypeUse ARRAYR
		public Group getGroup() { return cGroup; }

		//ARRAYL
		public RuleCall getARRAYLTerminalRuleCall_0() { return cARRAYLTerminalRuleCall_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }

		//"x"
		public Keyword getXKeyword_2() { return cXKeyword_2; }

		//TypeUse
		public RuleCall getTypeUseParserRuleCall_3() { return cTypeUseParserRuleCall_3; }

		//ARRAYR
		public RuleCall getARRAYRTerminalRuleCall_4() { return cARRAYRTerminalRuleCall_4; }
	}

	public class EmptyArrayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EmptyArray");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cARRAYLTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cARRAYRTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//EmptyArray:
		//
		//	ARRAYL ARRAYR;
		public ParserRule getRule() { return rule; }

		//ARRAYL ARRAYR
		public Group getGroup() { return cGroup; }

		//ARRAYL
		public RuleCall getARRAYLTerminalRuleCall_0() { return cARRAYLTerminalRuleCall_0; }

		//ARRAYR
		public RuleCall getARRAYRTerminalRuleCall_1() { return cARRAYRTerminalRuleCall_1; }
	}

	public class Aggregate_TypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Aggregate_Types");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStructureParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArrayParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVectorParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Aggregate_Types:
		//
		//	Structure | Array | Vector;
		public ParserRule getRule() { return rule; }

		//Structure | Array | Vector
		public Alternatives getAlternatives() { return cAlternatives; }

		//Structure
		public RuleCall getStructureParserRuleCall_0() { return cStructureParserRuleCall_0; }

		//Array
		public RuleCall getArrayParserRuleCall_1() { return cArrayParserRuleCall_1; }

		//Vector
		public RuleCall getVectorParserRuleCall_2() { return cVectorParserRuleCall_2; }
	}

	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Constant");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Constant:
		//
		//	value=INT;
		public ParserRule getRule() { return rule; }

		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}

	public class NonConstantValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NonConstantValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameVALID_IDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cPointerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPointerPOINTERTerminalRuleCall_1_0 = (RuleCall)cPointerAssignment_1.eContents().get(0);
		
		//NonConstantValue:
		//
		//	name=VALID_ID pointer=POINTER?;
		public ParserRule getRule() { return rule; }

		//name=VALID_ID pointer=POINTER?
		public Group getGroup() { return cGroup; }

		//name=VALID_ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//VALID_ID
		public RuleCall getNameVALID_IDTerminalRuleCall_0_0() { return cNameVALID_IDTerminalRuleCall_0_0; }

		//pointer=POINTER?
		public Assignment getPointerAssignment_1() { return cPointerAssignment_1; }

		//POINTER
		public RuleCall getPointerPOINTERTerminalRuleCall_1_0() { return cPointerPOINTERTerminalRuleCall_1_0; }
	}

	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNonConstantValueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Value:
		//
		//	Constant | NonConstantValue;
		public ParserRule getRule() { return rule; }

		//Constant | NonConstantValue
		public Alternatives getAlternatives() { return cAlternatives; }

		//Constant
		public RuleCall getConstantParserRuleCall_0() { return cConstantParserRuleCall_0; }

		//NonConstantValue
		public RuleCall getNonConstantValueParserRuleCall_1() { return cNonConstantValueParserRuleCall_1; }
	}

	public class StructureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Structure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStructureAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cTypesAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cTypesTypeUseParserRuleCall_2_0_0 = (RuleCall)cTypesAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cTypesAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cTypesTypeUseParserRuleCall_2_1_1_0 = (RuleCall)cTypesAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cPOINTERTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		////ValueStruct:
		//
		////	'{' types+=TypeUse ('()*')? Value+=Value (',' types+=TypeUse ('()*')? Value+=Value) '}';
		//
		//Structure:
		//
		//	{Structure} "{" (types+=TypeUse ("," types+=TypeUse)*)? "}" POINTER?;
		public ParserRule getRule() { return rule; }

		//{Structure} "{" (types+=TypeUse ("," types+=TypeUse)*)? "}" POINTER?
		public Group getGroup() { return cGroup; }

		//{Structure}
		public Action getStructureAction_0() { return cStructureAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(types+=TypeUse ("," types+=TypeUse)*)?
		public Group getGroup_2() { return cGroup_2; }

		//types+=TypeUse
		public Assignment getTypesAssignment_2_0() { return cTypesAssignment_2_0; }

		//TypeUse
		public RuleCall getTypesTypeUseParserRuleCall_2_0_0() { return cTypesTypeUseParserRuleCall_2_0_0; }

		//("," types+=TypeUse)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//types+=TypeUse
		public Assignment getTypesAssignment_2_1_1() { return cTypesAssignment_2_1_1; }

		//TypeUse
		public RuleCall getTypesTypeUseParserRuleCall_2_1_1_0() { return cTypesTypeUseParserRuleCall_2_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }

		//POINTER?
		public RuleCall getPOINTERTerminalRuleCall_4() { return cPOINTERTerminalRuleCall_4; }
	}

	public class OpaqueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Opaque");
		private final Keyword cOpaqueKeyword = (Keyword)rule.eContents().get(1);
		
		/// *
		//
		// * Aliases act as "second name" for the aliasee value (which can be either function, 
		//
		// * global variable, another alias or bitcast of global value). 
		//
		// * Aliases may have an optional linkage type, and an optional visibility style
		//
		// * / //Alias:
		//
		////	'alias' ALIAS_LINKAGE? VISIBILITY? aliastype=Type aliasvalue=Value aliasee=Type;
		//
		//Opaque:
		//
		//	"opaque";
		public ParserRule getRule() { return rule; }

		//"opaque"
		public Keyword getOpaqueKeyword() { return cOpaqueKeyword; }
	}

	public class ParameterListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterListAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cTypesAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cTypesTypeUseParserRuleCall_2_0_0 = (RuleCall)cTypesAssignment_2_0.eContents().get(0);
		private final Assignment cListsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cListsTypeListParserRuleCall_2_1_0 = (RuleCall)cListsAssignment_2_1.eContents().get(0);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		private final Assignment cVariablesAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cVariablesValueParserRuleCall_2_3_0 = (RuleCall)cVariablesAssignment_2_3.eContents().get(0);
		private final Group cGroup_2_4 = (Group)cGroup_2.eContents().get(4);
		private final Keyword cCommaKeyword_2_4_0 = (Keyword)cGroup_2_4.eContents().get(0);
		private final Assignment cTypesAssignment_2_4_1 = (Assignment)cGroup_2_4.eContents().get(1);
		private final RuleCall cTypesTypeUseParserRuleCall_2_4_1_0 = (RuleCall)cTypesAssignment_2_4_1.eContents().get(0);
		private final Assignment cListsAssignment_2_4_2 = (Assignment)cGroup_2_4.eContents().get(2);
		private final RuleCall cListsTypeListParserRuleCall_2_4_2_0 = (RuleCall)cListsAssignment_2_4_2.eContents().get(0);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_2_4_3 = (RuleCall)cGroup_2_4.eContents().get(3);
		private final Assignment cVariablesAssignment_2_4_4 = (Assignment)cGroup_2_4.eContents().get(4);
		private final RuleCall cVariablesValueParserRuleCall_2_4_4_0 = (RuleCall)cVariablesAssignment_2_4_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////	/ *
		//
		//// * This rule creates a Parameterlist and saves also the TypeAndValue to each parameter
		//
		//// * Brackets are 
		//
		//// * /
		//
		//ParameterList:
		//
		//	{ParameterList} "(" (types+=TypeUse Lists+=TypeList? RETURN_ATTRIBUTES* variables+=Value ("," types+=TypeUse
		//
		//	Lists+=TypeList? RETURN_ATTRIBUTES* variables+=Value)*)? ")";
		public ParserRule getRule() { return rule; }

		//{ParameterList} "(" (types+=TypeUse Lists+=TypeList? RETURN_ATTRIBUTES* variables+=Value ("," types+=TypeUse
		//
		//Lists+=TypeList? RETURN_ATTRIBUTES* variables+=Value)*)? ")"
		public Group getGroup() { return cGroup; }

		//{ParameterList}
		public Action getParameterListAction_0() { return cParameterListAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(types+=TypeUse Lists+=TypeList? RETURN_ATTRIBUTES* variables+=Value ("," types+=TypeUse Lists+=TypeList?
		//
		//RETURN_ATTRIBUTES* variables+=Value)*)?
		public Group getGroup_2() { return cGroup_2; }

		//types+=TypeUse
		public Assignment getTypesAssignment_2_0() { return cTypesAssignment_2_0; }

		//TypeUse
		public RuleCall getTypesTypeUseParserRuleCall_2_0_0() { return cTypesTypeUseParserRuleCall_2_0_0; }

		//Lists+=TypeList?
		public Assignment getListsAssignment_2_1() { return cListsAssignment_2_1; }

		//TypeList
		public RuleCall getListsTypeListParserRuleCall_2_1_0() { return cListsTypeListParserRuleCall_2_1_0; }

		//RETURN_ATTRIBUTES*
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_2_2() { return cRETURN_ATTRIBUTESParserRuleCall_2_2; }

		//variables+=Value
		public Assignment getVariablesAssignment_2_3() { return cVariablesAssignment_2_3; }

		//Value
		public RuleCall getVariablesValueParserRuleCall_2_3_0() { return cVariablesValueParserRuleCall_2_3_0; }

		//("," types+=TypeUse Lists+=TypeList? RETURN_ATTRIBUTES* variables+=Value)*
		public Group getGroup_2_4() { return cGroup_2_4; }

		//","
		public Keyword getCommaKeyword_2_4_0() { return cCommaKeyword_2_4_0; }

		//types+=TypeUse
		public Assignment getTypesAssignment_2_4_1() { return cTypesAssignment_2_4_1; }

		//TypeUse
		public RuleCall getTypesTypeUseParserRuleCall_2_4_1_0() { return cTypesTypeUseParserRuleCall_2_4_1_0; }

		//Lists+=TypeList?
		public Assignment getListsAssignment_2_4_2() { return cListsAssignment_2_4_2; }

		//TypeList
		public RuleCall getListsTypeListParserRuleCall_2_4_2_0() { return cListsTypeListParserRuleCall_2_4_2_0; }

		//RETURN_ATTRIBUTES*
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_2_4_3() { return cRETURN_ATTRIBUTESParserRuleCall_2_4_3; }

		//variables+=Value
		public Assignment getVariablesAssignment_2_4_4() { return cVariablesAssignment_2_4_4; }

		//Value
		public RuleCall getVariablesValueParserRuleCall_2_4_4_0() { return cVariablesValueParserRuleCall_2_4_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class FunctionBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBlocksAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlocksBasicBlockParserRuleCall_1_0 = (RuleCall)cBlocksAssignment_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		////
		//
		////	/ * 
		//
		//// * This rule is the start of the function body and has to be right after de 'define' of a function.
		//
		//// * Every Functionbody contains at leaset one Basic Block. 
		//
		//// * /
		//
		////	meta+=MetadataValue*;
		//
		//FunctionBody: //	meta+=MetadataValue*
		//
		//	"{" blocks+=BasicBlock+ "}";
		public ParserRule getRule() { return rule; }

		////	meta+=MetadataValue*
		//
		//"{" blocks+=BasicBlock+ "}"
		public Group getGroup() { return cGroup; }

		////	meta+=MetadataValue*
		//
		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//blocks+=BasicBlock+
		public Assignment getBlocksAssignment_1() { return cBlocksAssignment_1; }

		//BasicBlock
		public RuleCall getBlocksBasicBlockParserRuleCall_1_0() { return cBlocksBasicBlockParserRuleCall_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class BasicBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelIDTerminalRuleCall_0_0 = (RuleCall)cLabelAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		////	/ *
		//
		//// * Every Basic Block is contained inside a Functionbody and has a label(eventually) and at least one instruction 
		//
		//// * /
		//
		////	instructions+=(TypeDefinition | Instruction)*
		//
		////	(retadr=VAR_TYPE '=' )?terminator=Ret_Instr;
		//
		//BasicBlock:
		//
		//	label=ID ":";
		public ParserRule getRule() { return rule; }

		//label=ID ":"
		public Group getGroup() { return cGroup; }

		//label=ID
		public Assignment getLabelAssignment_0() { return cLabelAssignment_0; }

		//ID
		public RuleCall getLabelIDTerminalRuleCall_0_0() { return cLabelIDTerminalRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
	}

	public class TypeListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTypeListAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisRightParenthesisKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Assignment cTypesAssignment_1_1_1_0 = (Assignment)cGroup_1_1_1.eContents().get(0);
		private final RuleCall cTypesTypeUseParserRuleCall_1_1_1_0_0 = (RuleCall)cTypesAssignment_1_1_1_0.eContents().get(0);
		private final Assignment cTypelistsAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cTypelistsTypeListParserRuleCall_1_1_1_1_0 = (RuleCall)cTypelistsAssignment_1_1_1_1.eContents().get(0);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_1_1_1_2 = (RuleCall)cGroup_1_1_1.eContents().get(2);
		private final Group cGroup_1_1_1_3 = (Group)cGroup_1_1_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_1_1_3_0 = (Keyword)cGroup_1_1_1_3.eContents().get(0);
		private final Assignment cTypesAssignment_1_1_1_3_1 = (Assignment)cGroup_1_1_1_3.eContents().get(1);
		private final RuleCall cTypesTypeUseParserRuleCall_1_1_1_3_1_0 = (RuleCall)cTypesAssignment_1_1_1_3_1.eContents().get(0);
		private final Assignment cTypelistsAssignment_1_1_1_3_2 = (Assignment)cGroup_1_1_1_3.eContents().get(2);
		private final RuleCall cTypelistsTypeListParserRuleCall_1_1_1_3_2_0 = (RuleCall)cTypelistsAssignment_1_1_1_3_2.eContents().get(0);
		private final RuleCall cRETURN_ATTRIBUTESParserRuleCall_1_1_1_3_3 = (RuleCall)cGroup_1_1_1_3.eContents().get(3);
		private final Alternatives cAlternatives_1_1_2 = (Alternatives)cGroup_1_1.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_1_1_2_0 = (Keyword)cAlternatives_1_1_2.eContents().get(0);
		private final Keyword cRightParenthesisAsteriskKeyword_1_1_2_1 = (Keyword)cAlternatives_1_1_2.eContents().get(1);
		private final Keyword cRightParenthesisAsteriskAsteriskKeyword_1_1_2_2 = (Keyword)cAlternatives_1_1_2.eContents().get(2);
		private final Keyword cRightParenthesisAsteriskAsteriskAsteriskKeyword_1_1_2_3 = (Keyword)cAlternatives_1_1_2.eContents().get(3);
		private final Keyword cRightParenthesisAsteriskAsteriskAsteriskAsteriskKeyword_1_1_2_4 = (Keyword)cAlternatives_1_1_2.eContents().get(4);
		private final Keyword cRightParenthesisAsteriskAsteriskAsteriskAsteriskAsteriskKeyword_1_1_2_5 = (Keyword)cAlternatives_1_1_2.eContents().get(5);
		
		////Ret_Instr:
		//
		////	Return | Branch | Switch | IndirectBranch | Invoke | Resume | Unreachable;
		//
		////
		//
		////	/ *
		//
		//// * If a function is declared, the parameterlist has to be set empty or contain a List of Types.
		//
		//// * /
		//
		//TypeList:
		//
		//	{TypeList} ("()" | "(" (types+=TypeUse typelists+=TypeList? RETURN_ATTRIBUTES? ("," types+=TypeUse
		//
		//	typelists+=TypeList? RETURN_ATTRIBUTES?)*)? (")" | ")*" | ")**" | ")***" | ")****" | ")*****"));
		public ParserRule getRule() { return rule; }

		//{TypeList} ("()" | "(" (types+=TypeUse typelists+=TypeList? RETURN_ATTRIBUTES? ("," types+=TypeUse typelists+=TypeList?
		//
		//RETURN_ATTRIBUTES?)*)? (")" | ")*" | ")**" | ")***" | ")****" | ")*****"))
		public Group getGroup() { return cGroup; }

		//{TypeList}
		public Action getTypeListAction_0() { return cTypeListAction_0; }

		//"()" | "(" (types+=TypeUse typelists+=TypeList? RETURN_ATTRIBUTES? ("," types+=TypeUse typelists+=TypeList?
		//
		//RETURN_ATTRIBUTES?)*)? (")" | ")*" | ")**" | ")***" | ")****" | ")*****")
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"()"
		public Keyword getLeftParenthesisRightParenthesisKeyword_1_0() { return cLeftParenthesisRightParenthesisKeyword_1_0; }

		//"(" (types+=TypeUse typelists+=TypeList? RETURN_ATTRIBUTES? ("," types+=TypeUse typelists+=TypeList?
		//
		//RETURN_ATTRIBUTES?)*)? (")" | ")*" | ")**" | ")***" | ")****" | ")*****")
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1_0() { return cLeftParenthesisKeyword_1_1_0; }

		//(types+=TypeUse typelists+=TypeList? RETURN_ATTRIBUTES? ("," types+=TypeUse typelists+=TypeList? RETURN_ATTRIBUTES?)*)?
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//types+=TypeUse
		public Assignment getTypesAssignment_1_1_1_0() { return cTypesAssignment_1_1_1_0; }

		//TypeUse
		public RuleCall getTypesTypeUseParserRuleCall_1_1_1_0_0() { return cTypesTypeUseParserRuleCall_1_1_1_0_0; }

		//typelists+=TypeList?
		public Assignment getTypelistsAssignment_1_1_1_1() { return cTypelistsAssignment_1_1_1_1; }

		//TypeList
		public RuleCall getTypelistsTypeListParserRuleCall_1_1_1_1_0() { return cTypelistsTypeListParserRuleCall_1_1_1_1_0; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_1_1_1_2() { return cRETURN_ATTRIBUTESParserRuleCall_1_1_1_2; }

		//("," types+=TypeUse typelists+=TypeList? RETURN_ATTRIBUTES?)*
		public Group getGroup_1_1_1_3() { return cGroup_1_1_1_3; }

		//","
		public Keyword getCommaKeyword_1_1_1_3_0() { return cCommaKeyword_1_1_1_3_0; }

		//types+=TypeUse
		public Assignment getTypesAssignment_1_1_1_3_1() { return cTypesAssignment_1_1_1_3_1; }

		//TypeUse
		public RuleCall getTypesTypeUseParserRuleCall_1_1_1_3_1_0() { return cTypesTypeUseParserRuleCall_1_1_1_3_1_0; }

		//typelists+=TypeList?
		public Assignment getTypelistsAssignment_1_1_1_3_2() { return cTypelistsAssignment_1_1_1_3_2; }

		//TypeList
		public RuleCall getTypelistsTypeListParserRuleCall_1_1_1_3_2_0() { return cTypelistsTypeListParserRuleCall_1_1_1_3_2_0; }

		//RETURN_ATTRIBUTES?
		public RuleCall getRETURN_ATTRIBUTESParserRuleCall_1_1_1_3_3() { return cRETURN_ATTRIBUTESParserRuleCall_1_1_1_3_3; }

		//")" | ")*" | ")**" | ")***" | ")****" | ")*****"
		public Alternatives getAlternatives_1_1_2() { return cAlternatives_1_1_2; }

		//")"
		public Keyword getRightParenthesisKeyword_1_1_2_0() { return cRightParenthesisKeyword_1_1_2_0; }

		//")*"
		public Keyword getRightParenthesisAsteriskKeyword_1_1_2_1() { return cRightParenthesisAsteriskKeyword_1_1_2_1; }

		//")**"
		public Keyword getRightParenthesisAsteriskAsteriskKeyword_1_1_2_2() { return cRightParenthesisAsteriskAsteriskKeyword_1_1_2_2; }

		//")***"
		public Keyword getRightParenthesisAsteriskAsteriskAsteriskKeyword_1_1_2_3() { return cRightParenthesisAsteriskAsteriskAsteriskKeyword_1_1_2_3; }

		//")****"
		public Keyword getRightParenthesisAsteriskAsteriskAsteriskAsteriskKeyword_1_1_2_4() { return cRightParenthesisAsteriskAsteriskAsteriskAsteriskKeyword_1_1_2_4; }

		//")*****"
		public Keyword getRightParenthesisAsteriskAsteriskAsteriskAsteriskAsteriskKeyword_1_1_2_5() { return cRightParenthesisAsteriskAsteriskAsteriskAsteriskAsteriskKeyword_1_1_2_5; }
	}

	public class RETURN_ATTRIBUTESElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RETURN_ATTRIBUTES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cZeroextKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSignextKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cInregKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cByvalKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cSretKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cNoaliasKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cNocaptureKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cNestKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		
		////
		//
		////	/ *
		//
		//// * An Aggregate is a tuple of types enclosed by curly brackets
		//
		//// * /
		//
		////
		//
		///// *
		//
		//// * A Local Variable definition needs a name, followed by an equalsign and either an Instruction, an Alias or a Type  
		//
		//// * /
		//
		////
		//
		///// *
		//
		//// * This is only to summarize all possible Instructions
		//
		//// * /
		//
		////Instruction:
		//
		////	('volatile'? Load) | ('volatile'? Store) | Fence | GetElementPtr | LOGICAL_OP | ARITHMETIC_OP | Compare |
		//
		////	Cast | ShuffleVector | InsertElement | ExtractElement | InsertValue | ExtractValue | Alloc |
		//
		////	CmpXchg | AtomicRMW | PHI | Select | Call | VA_Arg | LandingPad;
		//
		////
		//
		////	/ *
		//
		//// * This rule is used to bind a Type to a value.
		//
		//// * It is used for example on parameterlists, on instructions etc.
		//
		//// * /
		//
		//////TypeAndValue:
		//
		//////	(type=(VAR_TYPE | B_TYPE)RETURN_ATTRIBUTES? value=Type) | aggregate=Aggregate value=Type;
		//
		////
		//
		////
		//
		///// *
		//
		//// * The 'getelementptr' instruction is used to get the address of a subelement of an aggregate data structure. 
		//
		//// * It performs address calculation only and does not access memory.
		//
		//// * /
		//
		////GetElementPtr:
		//
		////	'getelementptr' 'inbounds'? '('? ((elementtype=Type (types=TypeList)? | elementarray=ARRAY) element=Value (',' indicetypes+=Type
		//
		////	indices+=Value)*);
		//
		////
		//
		////	/ * //Alias:
		//
		////	'alias' ALIAS_LINKAGE? VISIBILITY? aliastype=Type aliasvalue=Value aliasee=Type;
		//
		//// * The 'extractvalue' instruction extracts the value of a member field from an aggregate value.
		//
		//// * /
		//
		////ExtractValue:
		//
		////	'extractvalue' (array=ARRAY | struct=Structure) value=Value (',' index+=INT)+;
		//
		////
		//
		////	/ *
		//
		//// * The 'insertvalue' instruction inserts a value into a member field in an aggregate value.
		//
		//// * /
		//
		////InsertValue:
		//
		////	'insertvalue' struct=Structure value=Value ',' inserttype=Type insertvalue=Value(',' index+=INT)+;
		//
		////
		//
		////	/ *
		//
		//// * The 'fence' instruction is used to introduce happens-before edges between operations.
		//
		//// * /
		//
		////Fence:
		//
		////	'fence' 'singlethread'? ordering=ATOMIC_ORDERING;
		//
		////
		//
		////	/ *
		//
		//// * This is only a summarize of the possible atomic orderings
		//
		//// * /
		//
		////ATOMIC_ORDERING:
		//
		////	'unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst';
		//
		////
		//
		////	/ *
		//
		//// * The 'cmpxchg' instruction is used to atomically modify memory. It loads a value in memory and compares it to 
		//
		//// * a given value. If they are equal, it stores a new value into the memory.
		//
		//// * /
		//
		////CmpXchg:
		//
		////	'cmpxchg' 'volatile'? adresstype=Type adress=Value ',' comparetype=Type comparevalue=Value ',' newtype=Type
		//
		////	newvalue=Value 'singlethread'?
		//
		////	ordering=ATOMIC_ORDERING;
		//
		////
		//
		////	/ *
		//
		//// * The 'atomicrmw' instruction is used to atomically modify memory.
		//
		//// * /
		//
		////AtomicRMW:
		//
		////	'atomicrmw' 'volatile'? BIN_OP adresstype=Type adress=Value ',' optype=Type opvalue=Value'singlethread'?
		//
		////	ordering=ATOMIC_ORDERING;
		//
		////
		//
		////	/ *
		//
		//// * This is only to summarize the different Binary Operations
		//
		//// * /
		//
		////BIN_OP:
		//
		////	('xchg' | 'add' | 'sub' | 'and' | 'nand' | 'or' | 'xor' | 'max' | 'min' | 'umax' | 'umin');
		//
		////
		//
		////	/ *
		//
		//// * The 'load' instruction is used to read from memory.
		//
		//// * /
		//
		////Load:
		//
		////	'load' 'volatile'? adresstype=Type (types=TypeList)? adress=Value (',' ((ALIGNMENT) | (MetadataValue)+))* |
		//
		////	'load' 'atomic' 'volatile'? adresstype=Type adress=Value(types=TypeList)? 'singlethread'? ordering=ATOMIC_ORDERING (',' 'align'
		//
		////	index=INT)?;
		//
		////
		//
		////	/ *
		//
		//// * The 'store' instruction is used to write to memory.
		//
		//// * /
		//
		////Store:
		//
		////	'store' 'volatile'? newtype=(Type) (types+=TypeList)? (newvalue=Value|newelement=GetElementPtr ')') ',' adresstype=Type (types+=TypeList)? adress=Value (',' ((ALIGNMENT) |
		//
		////	(MetadataValue)+))* |
		//
		////	'store' 'atomic' 'volatile'? newtype=Type(types+=TypeList)? newvalue=Value ',' adresstype=Type (types+=TypeList)? adress=Value 'singlethread'?
		//
		////	ordering=ATOMIC_ORDERING (','
		//
		////	'align' index=INT)?;
		//
		////
		//
		////	/ *
		//
		//// * The 'call' instruction represents a simple function call.
		//
		//// * /
		//
		////Call:
		//
		////	'tail'? 'call' CallingConv? RETURN_ATTRIBUTES? adresstype=Type ((adress=Value)|'asm' 'sideeffect'? STRING ',' STRING) pList=ParameterList FUNCTION_ATTRIBUTES*(',' '!srcloc' '!'INT)*;
		//
		////
		//
		////	/ *
		//
		//// * This is to summarize the possible return attributes
		//
		//// * /
		//
		//RETURN_ATTRIBUTES:
		//
		//	"zeroext" | "signext" | "inreg" | "byval" | "sret" | "noalias" | "nocapture" | "nest";
		public ParserRule getRule() { return rule; }

		//"zeroext" | "signext" | "inreg" | "byval" | "sret" | "noalias" | "nocapture" | "nest"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"zeroext"
		public Keyword getZeroextKeyword_0() { return cZeroextKeyword_0; }

		//"signext"
		public Keyword getSignextKeyword_1() { return cSignextKeyword_1; }

		//"inreg"
		public Keyword getInregKeyword_2() { return cInregKeyword_2; }

		//"byval"
		public Keyword getByvalKeyword_3() { return cByvalKeyword_3; }

		//"sret"
		public Keyword getSretKeyword_4() { return cSretKeyword_4; }

		//"noalias"
		public Keyword getNoaliasKeyword_5() { return cNoaliasKeyword_5; }

		//"nocapture"
		public Keyword getNocaptureKeyword_6() { return cNocaptureKeyword_6; }

		//"nest"
		public Keyword getNestKeyword_7() { return cNestKeyword_7; }
	}

	public class CallingConvElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CallingConv");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCccKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFastccKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cColdccKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cX86_stdcallccKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cX86_fastcallccKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cX86_thiscallccKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cArm_apcsccKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cArm_aapcsccKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cArm_aapcs_vfpccKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cMsp430_intrccKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cPtx_kernelKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cPtx_deviceKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cSpir_funcKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cSpir_kernelKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Group cGroup_14 = (Group)cAlternatives.eContents().get(14);
		private final Keyword cCcKeyword_14_0 = (Keyword)cGroup_14.eContents().get(0);
		private final Keyword cLessThanSignKeyword_14_1 = (Keyword)cGroup_14.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_14_2 = (RuleCall)cGroup_14.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_14_3 = (Keyword)cGroup_14.eContents().get(3);
		private final RuleCall cINTTerminalRuleCall_14_4 = (RuleCall)cGroup_14.eContents().get(4);
		
		////
		//
		////Alloc:
		//
		////	'alloca' ((type=Type typelist=TypeList?)) (',' numelementstype=Type numelementsvalue=Value)? (',' ALIGNMENT)?;
		//
		////
		//
		////	/ *
		//
		//// * This is to summarize the possible Calling Conventions
		//
		//// * /
		//
		//CallingConv:
		//
		//	"ccc" | "fastcc" | "coldcc" | "x86_stdcallcc" | "x86_fastcallcc" | "x86_thiscallcc" | "arm_apcscc" | "arm_aapcscc" |
		//
		//	"arm_aapcs_vfpcc" | "msp430_intrcc" | "ptx_kernel" | "ptx_device" | "spir_func" | "spir_kernel" | "cc" "<" INT ">"
		//
		//	INT;
		public ParserRule getRule() { return rule; }

		//"ccc" | "fastcc" | "coldcc" | "x86_stdcallcc" | "x86_fastcallcc" | "x86_thiscallcc" | "arm_apcscc" | "arm_aapcscc" |
		//
		//"arm_aapcs_vfpcc" | "msp430_intrcc" | "ptx_kernel" | "ptx_device" | "spir_func" | "spir_kernel" | "cc" "<" INT ">" INT
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ccc"
		public Keyword getCccKeyword_0() { return cCccKeyword_0; }

		//"fastcc"
		public Keyword getFastccKeyword_1() { return cFastccKeyword_1; }

		//"coldcc"
		public Keyword getColdccKeyword_2() { return cColdccKeyword_2; }

		//"x86_stdcallcc"
		public Keyword getX86_stdcallccKeyword_3() { return cX86_stdcallccKeyword_3; }

		//"x86_fastcallcc"
		public Keyword getX86_fastcallccKeyword_4() { return cX86_fastcallccKeyword_4; }

		//"x86_thiscallcc"
		public Keyword getX86_thiscallccKeyword_5() { return cX86_thiscallccKeyword_5; }

		//"arm_apcscc"
		public Keyword getArm_apcsccKeyword_6() { return cArm_apcsccKeyword_6; }

		//"arm_aapcscc"
		public Keyword getArm_aapcsccKeyword_7() { return cArm_aapcsccKeyword_7; }

		//"arm_aapcs_vfpcc"
		public Keyword getArm_aapcs_vfpccKeyword_8() { return cArm_aapcs_vfpccKeyword_8; }

		//"msp430_intrcc"
		public Keyword getMsp430_intrccKeyword_9() { return cMsp430_intrccKeyword_9; }

		//"ptx_kernel"
		public Keyword getPtx_kernelKeyword_10() { return cPtx_kernelKeyword_10; }

		//"ptx_device"
		public Keyword getPtx_deviceKeyword_11() { return cPtx_deviceKeyword_11; }

		//"spir_func"
		public Keyword getSpir_funcKeyword_12() { return cSpir_funcKeyword_12; }

		//"spir_kernel"
		public Keyword getSpir_kernelKeyword_13() { return cSpir_kernelKeyword_13; }

		//"cc" "<" INT ">" INT
		public Group getGroup_14() { return cGroup_14; }

		//"cc"
		public Keyword getCcKeyword_14_0() { return cCcKeyword_14_0; }

		//"<"
		public Keyword getLessThanSignKeyword_14_1() { return cLessThanSignKeyword_14_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_14_2() { return cINTTerminalRuleCall_14_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_14_3() { return cGreaterThanSignKeyword_14_3; }

		//INT
		public RuleCall getINTTerminalRuleCall_14_4() { return cINTTerminalRuleCall_14_4; }
	}

	public class FUNCTION_ATTRIBUTESElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FUNCTION_ATTRIBUTES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAddress_safetyKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cAlignstackKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Keyword cGreaterThanSignKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cRightParenthesisKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Keyword cAlwaysinlineKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cNonlazybindKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cInlinehintKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cNakedKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cNoimplicitfloatKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cNoinlineKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cNoredzoneKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cNoreturnKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cNounwindKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cOptsizeKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cReadnoneKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cReadonlyKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cReturns_twiceKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cSspKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cSspreqKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cUwtableKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		
		////
		//
		////	/ *
		//
		//// * This is to summarize the possible function attributes
		//
		//// * /
		//
		//FUNCTION_ATTRIBUTES:
		//
		//	"address_safety" | "alignstack" "(" "<" INT ">" ")" | "alwaysinline" | "nonlazybind" | "inlinehint" | "naked" |
		//
		//	"noimplicitfloat" | "noinline" | "noredzone" | "noreturn" | "nounwind" | "optsize" | "readnone" | "readonly" |
		//
		//	"returns_twice" | "ssp" | "sspreq" | "uwtable";
		public ParserRule getRule() { return rule; }

		//"address_safety" | "alignstack" "(" "<" INT ">" ")" | "alwaysinline" | "nonlazybind" | "inlinehint" | "naked" |
		//
		//"noimplicitfloat" | "noinline" | "noredzone" | "noreturn" | "nounwind" | "optsize" | "readnone" | "readonly" |
		//
		//"returns_twice" | "ssp" | "sspreq" | "uwtable"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"address_safety"
		public Keyword getAddress_safetyKeyword_0() { return cAddress_safetyKeyword_0; }

		//"alignstack" "(" "<" INT ">" ")"
		public Group getGroup_1() { return cGroup_1; }

		//"alignstack"
		public Keyword getAlignstackKeyword_1_0() { return cAlignstackKeyword_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_2() { return cLessThanSignKeyword_1_2; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_3() { return cINTTerminalRuleCall_1_3; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_4() { return cGreaterThanSignKeyword_1_4; }

		//")"
		public Keyword getRightParenthesisKeyword_1_5() { return cRightParenthesisKeyword_1_5; }

		//"alwaysinline"
		public Keyword getAlwaysinlineKeyword_2() { return cAlwaysinlineKeyword_2; }

		//"nonlazybind"
		public Keyword getNonlazybindKeyword_3() { return cNonlazybindKeyword_3; }

		//"inlinehint"
		public Keyword getInlinehintKeyword_4() { return cInlinehintKeyword_4; }

		//"naked"
		public Keyword getNakedKeyword_5() { return cNakedKeyword_5; }

		//"noimplicitfloat"
		public Keyword getNoimplicitfloatKeyword_6() { return cNoimplicitfloatKeyword_6; }

		//"noinline"
		public Keyword getNoinlineKeyword_7() { return cNoinlineKeyword_7; }

		//"noredzone"
		public Keyword getNoredzoneKeyword_8() { return cNoredzoneKeyword_8; }

		//"noreturn"
		public Keyword getNoreturnKeyword_9() { return cNoreturnKeyword_9; }

		//"nounwind"
		public Keyword getNounwindKeyword_10() { return cNounwindKeyword_10; }

		//"optsize"
		public Keyword getOptsizeKeyword_11() { return cOptsizeKeyword_11; }

		//"readnone"
		public Keyword getReadnoneKeyword_12() { return cReadnoneKeyword_12; }

		//"readonly"
		public Keyword getReadonlyKeyword_13() { return cReadonlyKeyword_13; }

		//"returns_twice"
		public Keyword getReturns_twiceKeyword_14() { return cReturns_twiceKeyword_14; }

		//"ssp"
		public Keyword getSspKeyword_15() { return cSspKeyword_15; }

		//"sspreq"
		public Keyword getSspreqKeyword_16() { return cSspreqKeyword_16; }

		//"uwtable"
		public Keyword getUwtableKeyword_17() { return cUwtableKeyword_17; }
	}

	public class VISIBILITYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VISIBILITY");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDefaultKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHiddenKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cProtectedKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		////
		//
		////	/ *
		//
		//// * The 'phi' instruction is used to implement the φ node in the SSA graph representing the function.
		//
		//// * /
		//
		////PHI:
		//
		////	'phi' type=Type ARRAYL values+=ValuePair ARRAYR (',' ARRAYL values+=ValuePair ARRAYR)*;
		//
		////
		//
		////	/ *
		//
		//// * This rule is used to bring in more clarity in some instructions
		//
		//// * /
		//
		////ValuePair:
		//
		////	value1=Value ',' value2=Value;
		//
		////
		//
		////	/ *
		//
		//// * The 'landingpad' instruction is used by LLVM's exception handling system to specify that a basic 
		//
		//// * block is a landing pad — one where the exception lands, and corresponds to the code found in the 
		//
		//// * catch portion of a try/catch sequence. It defines values supplied by the personality function (pers_fn)
		//
		//// * upon re-entry to the function. The resultval has the type resultty.
		//
		//// * /
		//
		////LandingPad:
		//
		////	'landingpad' struct=Structure 'personality' personalitytype=Type
		//
		////	(personalityvalue=Value | personalityfunction=CAST_TYPE '(' value=Value OREST
		//
		////	VAR_TYPE 'to' castto=Type ')') ('cleanup' clause+=Clause* | clause+=Clause+);
		//
		////
		//
		////	/ *
		//
		//// * A clause begins with the clause type — catch or filter — and contains the global variable representing
		//
		//// * the "type" that may be caught or filtered respectively. Unlike the catch clause, the filter clause takes
		//
		//// * an array constant as its argument. Use "[0 x i8**] undef" for a filter which cannot throw. The 'landingpad'
		//
		//// * instruction must contain at least one clause or the cleanup flag.
		//
		//// * /
		//
		////Clause:
		//
		////	'catch' type=Type value=Value |
		//
		////	'filter' filterarray=ARRAY ((constant=Value)|'zeroinitializer');
		//
		////
		//
		////	/ *
		//
		//// * The 'select' instruction is used to choose one value based on a condition, without branching.
		//
		//// * /
		//
		////Select:
		//
		////	'select' conditiontype=Type conditionvalue=Value ',' val1type=Type val1value=Value ',' val2type=Type val2value=Value;
		//
		////
		//
		////	/ *
		//
		//// * The 'va_arg' instruction is used to access arguments passed through the "variable argument" area of a 
		//
		//// * function call. It is used to implement the va_arg macro in C.
		//
		//// * /
		//
		////VA_Arg:
		//
		////	'va_arg' listtype=Type listvalue=Value ',' argType=Type;
		//
		////
		//
		////	/ *
		//
		//// * The 'extractelement' instruction extracts a single scalar element from a vector at a specified index.
		//
		//// * /
		//
		////ExtractElement:
		//
		////	'extractelement' vectortype=Type vectorvalue=Value ',' indextype=Type index=Value;
		//
		////
		//
		////	/ *
		//
		//// * The 'insertelement' instruction inserts a scalar element into a vector at a specified index.
		//
		//// * /
		//
		////InsertElement:
		//
		////	'insertelement' vectortype=Type vectorvalue=Value ',' scalartype=Type scalarvalue=Value ',' indextype=Type index=Value;
		//
		////
		//
		////	/ *
		//
		//// * The 'shufflevector' instruction constructs a permutation of elements from two input vectors, 
		//
		//// * returning a vector with the same element type as the input and length that is the same as the shuffle mask.
		//
		//// * /
		//
		////ShuffleVector:
		//
		////	'shufflevector' val1type=Type val1value=Value ',' val2type=Type val2value=Value ',' masktype=Type maskvalue=Value;
		//
		////
		//
		////	/ *
		//
		//// * This rule is to provide a typecast. Nothing special
		//
		//// * Example
		//
		//// *  %X = trunc i32 257 to i8
		//
		//// *  %Z = fptosi float 1.04E+17 to i8
		//
		//// * /
		//
		////Cast:
		//
		////	CAST_TYPE '('? ((casttype=Type ('()*'|types+=TypeList)?) | caststruct=Structure) '('* (value=Value (',' dual=Value ')*')? |
		//
		////	op=GetElementPtr) global=Type? ')'* 'to'
		//
		////	(castto=(Type) (primitive=VAR_TYPE)? ('()*'|types+=TypeList)?);
		//
		////	//	CAST_TYPE ((castfrom=Type | caststruct=Structure)  (value=Type | op=GetElementPtr) global=Type? 'to' castto=Type) |
		//
		//////	'('+(castfrom=Type | caststruct=Structure) '('? (value=Type | op=GetElementPtr) global=Type? ')'* 'to' castto=Type ')'
		//
		////
		//
		///// *
		//
		//// * The instructions in this category are the conversion instructions (casting) which
		//
		//// * all take a single operand and a type. They perform various bit conversions on the operand.
		//
		//// * /
		//
		////CAST_TYPE:
		//
		////	'trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' | 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'
		//
		////	| 'bitcast';
		//
		////
		//
		////	/ *
		//
		//// * The 'icmp' instruction returns a boolean value or a vector of boolean values based on comparison of 
		//
		//// * 		its two integer, integer vector, pointer, or pointer vector operands.
		//
		//// * The 'fcmp' instruction returns a boolean value or vector of boolean values based on comparison of its operands.
		//
		//// * /
		//
		////Compare:
		//
		////	'icmp' I_PREDICATES comptype=Type value1=Value ',' value2=Value |
		//
		////	'fcmp' F_PREDICATES comptype=Type value1=Value ',' value2=Value;
		//
		////
		//
		////	/ *
		//
		//// * This is to summarize the possible Integer Predicates
		//
		//// * /
		//
		////I_PREDICATES:
		//
		////	'eq' | 'ne' | 'ugt' | 'uge' | 'ult' | 'ule' | 'sgt' | 'sge' | 'slt' | 'sle';
		//
		////
		//
		////	/ *
		//
		//// * This is to summarize the possible Floating Predicates
		//
		//// * /
		//
		////F_PREDICATES:
		//
		////	'false' | 'oeq' | 'ogt' | 'oge' | 'olt' | 'ole' | 'one' | 'ord' |
		//
		////	'ueq' | 'ugt' | 'uge' | 'ult' | 'ule' | 'une' | 'uno' | 'true';
		//
		////
		//
		////	/ *
		//
		//// * This is to summarize the possible Arithmetic Operations
		//
		//// * /
		//
		////ARITHMETIC_OP:
		//
		////	('add' | 'fadd' | 'sub' | 'fsub' | 'mul' | 'fmul' | 'udiv' | 'sdiv' | 'fdiv' | 'urem' | 'srem' | 'frem')  (('nsw'|'nuw')('nuw'|'nsw')?)?
		//
		////	optype=Type value1=Value ',' value2=Value;
		//
		////
		//
		////	/ *
		//
		//// * This is to summarize the possible Logical Operations
		//
		//// * /
		//
		////LOGICAL_OP:
		//
		////	('shl' | 'lshr' | 'ashr' | 'and' | 'or' | 'xor') optype=Type value1=Value ',' value2=Value;
		//
		////
		//
		////	/ *
		//
		//// * The 'indirectbr' instruction implements an indirect branch to a label within the current function, whose 
		//
		//// * address is specified by "address". Address must be derived from a blockaddress constant.
		//
		//// * /
		//
		////IndirectBranch:
		//
		////	'indirectbr' adresstype=Type adress=Value ',' ARRAYL (lList=LabelList)? ARRAYR;
		//
		////
		//
		////	/ *
		//
		//// * The Indirect Branch instruction needs a List of labels to jump to. 
		//
		//// * This List is created here an contains Pairs of Types and Values
		//
		//// * /
		//
		////LabelList:
		//
		////	(labeltype+=Type labels+=Value)+;
		//
		////
		//
		////	/ *
		//
		//// * The 'switch' instruction is used to transfer control flow to one of several different places. It is a generalization of 
		//
		//// * the 'br' instruction, allowing a branch to occur to one of many possible destinations.
		//
		//// * /
		//
		////Switch:
		//
		////	'switch' comptype=Type compvalue=Value ',' defaulttype=Type defaultvalue=Value ARRAYL (jTable=JumpTable)? ARRAYR;
		//
		////
		//
		////	/ *
		//
		//// * The Switch instruction needs a list of values and destination, that will be jumped in case of value occures
		//
		//// * /
		//
		////JumpTable:
		//
		////	(jtypes+=Type jvalues+=Value ',' destinationtypes+=Type destinations+=Value)+;
		//
		////
		//
		////	/ *
		//
		//// * The 'invoke' instruction causes control to transfer to a specified function, with the possibility of 
		//
		//// * control flow transfer to either the 'normal' label or the 'exception' label. If the callee function 
		//
		//// * returns with the "ret" instruction, control flow will return to the "normal" label. If the callee 
		//
		//// * (or any indirect callees) returns via the "resume" instruction or other exception handling mechanism, 
		//
		//// * control is interrupted and continued at the dynamically nearest "exception" label.
		//
		//// * 
		//
		//// * The 'exception' label is a landing pad for the exception. As such, 'exception' label is required to
		//
		//// *  have the "landingpad" instruction, which contains the information about the behavior of the program 
		//
		//// * after unwinding happens, as its first non-PHI instruction. The restrictions on the "landingpad" 
		//
		//// * instruction's tightly couples it to the "invoke" instruction, so that the important information contained 
		//
		//// * within the "landingpad" instruction can't be lost through normal code motion.
		//
		//// * /
		//
		////Invoke:
		//
		////	'invoke' CallingConv? RETURN_ATTRIBUTES? functiontype=Type name=Address pList=ParameterList
		//
		////	FUNCTION_ATTRIBUTES* 'to'
		//
		////	totype=Type tovalue=Value 'unwind' unwindtype=Type unwindvalue=Value;
		//
		////
		//
		////	/ *
		//
		//// * The 'resume' instruction is a terminator instruction that has no successors.
		//
		//// * /
		//
		////Resume:
		//
		////	'resume' resumestruct=Structure resumevalue=Value;
		//
		////	/ *
		//
		//// * The 'unreachable' instruction has no defined semantics. This instruction is used to inform the 
		//
		//// * optimizer that a particular portion of the code is not reachable. This can be used to indicate 
		//
		//// * that the code after a no-return function cannot be reached, and other facts.
		//
		//// * /
		//
		////Unreachable:
		//
		////	{Unreachable} 'unreachable';
		//
		////
		//
		////	/ *
		//
		//// * The 'ret' instruction is used to return control flow (and optionally a value) 
		//
		//// * from a function back to the caller.
		//
		//// * 
		//
		//// * There are two forms of the 'ret' instruction: one that returns a value and then 
		//
		//// * causes control flow, and one that just causes control flow to occur.
		//
		//// * /
		//
		////Return:
		//
		////	{Return} 'ret' 'void' (',' '!dbg' '!' INT)? | 'ret' returntype=Type returnvalue=Value (',' '!dbg' '!' INT)?;
		//
		////
		//
		////	/ *
		//
		//// * The 'br' instruction is used to cause control flow to transfer to a different basic block in 
		//
		//// * the current function. There are two forms of this instruction, corresponding to a conditional 
		//
		//// * branch and an unconditional branch.
		//
		//// * /
		//
		////Branch:
		//
		////	'br' destinationtype=Type destination=Value | 'br' condtype=Type condvalue=Value ',' labelTruetype=Type labelTrue=Value
		//
		////	',' labelFalsetype=Type labelFalse=Value;
		//
		////
		//
		////	/ *
		//
		//// * This is to summarize the possible visibilities
		//
		//// * /
		//
		//VISIBILITY:
		//
		//	"default" | "hidden" | "protected";
		public ParserRule getRule() { return rule; }

		//"default" | "hidden" | "protected"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"default"
		public Keyword getDefaultKeyword_0() { return cDefaultKeyword_0; }

		//"hidden"
		public Keyword getHiddenKeyword_1() { return cHiddenKeyword_1; }

		//"protected"
		public Keyword getProtectedKeyword_2() { return cProtectedKeyword_2; }
	}

	public class LINKAGEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LINKAGE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPrivateKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLinker_privateKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLinker_private_weakKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cAvailable_externallyKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLinkonceKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cCommonKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cAppendingKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cExtern_weakKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLinkonce_odrKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cLinkonce_odr_auto_hideKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cDllimportKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cDllexportKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final RuleCall cALIAS_LINKAGEParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		
		////	/ *
		//
		//// * This is to summarize the possible linkages
		//
		//// * /
		//
		//LINKAGE:
		//
		//	"private" | "linker_private" | "linker_private_weak" | "available_externally" | "linkonce" | "common" | "appending" |
		//
		//	"extern_weak" | "linkonce_odr" | "linkonce_odr_auto_hide" | "dllimport" | "dllexport" | ALIAS_LINKAGE;
		public ParserRule getRule() { return rule; }

		//"private" | "linker_private" | "linker_private_weak" | "available_externally" | "linkonce" | "common" | "appending" |
		//
		//"extern_weak" | "linkonce_odr" | "linkonce_odr_auto_hide" | "dllimport" | "dllexport" | ALIAS_LINKAGE
		public Alternatives getAlternatives() { return cAlternatives; }

		//"private"
		public Keyword getPrivateKeyword_0() { return cPrivateKeyword_0; }

		//"linker_private"
		public Keyword getLinker_privateKeyword_1() { return cLinker_privateKeyword_1; }

		//"linker_private_weak"
		public Keyword getLinker_private_weakKeyword_2() { return cLinker_private_weakKeyword_2; }

		//"available_externally"
		public Keyword getAvailable_externallyKeyword_3() { return cAvailable_externallyKeyword_3; }

		//"linkonce"
		public Keyword getLinkonceKeyword_4() { return cLinkonceKeyword_4; }

		//"common"
		public Keyword getCommonKeyword_5() { return cCommonKeyword_5; }

		//"appending"
		public Keyword getAppendingKeyword_6() { return cAppendingKeyword_6; }

		//"extern_weak"
		public Keyword getExtern_weakKeyword_7() { return cExtern_weakKeyword_7; }

		//"linkonce_odr"
		public Keyword getLinkonce_odrKeyword_8() { return cLinkonce_odrKeyword_8; }

		//"linkonce_odr_auto_hide"
		public Keyword getLinkonce_odr_auto_hideKeyword_9() { return cLinkonce_odr_auto_hideKeyword_9; }

		//"dllimport"
		public Keyword getDllimportKeyword_10() { return cDllimportKeyword_10; }

		//"dllexport"
		public Keyword getDllexportKeyword_11() { return cDllexportKeyword_11; }

		//ALIAS_LINKAGE
		public RuleCall getALIAS_LINKAGEParserRuleCall_12() { return cALIAS_LINKAGEParserRuleCall_12; }
	}

	public class ALIAS_LINKAGEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ALIAS_LINKAGE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cExternalKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cInternalKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cWeakKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cWeak_odrKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		////
		//
		////	/ *
		//
		//// * There are restriction on the Linkages of Aliasees. So...
		//
		//// * /
		//
		//ALIAS_LINKAGE:
		//
		//	"external" | "internal" | "weak" | "weak_odr";
		public ParserRule getRule() { return rule; }

		//"external" | "internal" | "weak" | "weak_odr"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"external"
		public Keyword getExternalKeyword_0() { return cExternalKeyword_0; }

		//"internal"
		public Keyword getInternalKeyword_1() { return cInternalKeyword_1; }

		//"weak"
		public Keyword getWeakKeyword_2() { return cWeakKeyword_2; }

		//"weak_odr"
		public Keyword getWeak_odrKeyword_3() { return cWeak_odrKeyword_3; }
	}

	public class ALIGNMENTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ALIGNMENT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAlignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		////
		//
		////	/ *
		//
		//// * This rule is needed to support Metadata
		//
		//// * Example:
		//
		//// *  ; Named metadata
		//
		//// *	!1 = metadata !{i32 42}
		//
		//// *	!foo = !{!1, null} 
		//
		//// *  !1 = metadata !{metadata !"omnipotent char", metadata !2}
		//
		//// * /
		//
		////MetadataValue:
		//
		////	(('!' INT) | ('!{' ID '}') | ('!' ID))
		//
		////	('='
		//
		////	(('!' INT) |
		//
		////	('!{' ID'}') |
		//
		////	('!' ID) |
		//
		////	'metadata' (('!' '{' | '!{') 'metadata' '!' STRING ',' ('metadata' '!' INT) '}')?))?;
		//
		////	/ *
		//
		//// * This rule is to define the alignment
		//
		//// * /
		//
		//ALIGNMENT:
		//
		//	"align" //must be a power of 2
		//
		//	INT;
		public ParserRule getRule() { return rule; }

		//"align" //must be a power of 2
		//
		//INT
		public Group getGroup() { return cGroup; }

		//"align"
		public Keyword getAlignKeyword_0() { return cAlignKeyword_0; }

		////must be a power of 2
		//
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	
	
	private LLVMElements pLLVM;
	private TerminalRule tINT;
	private TerminalRule tVALID_ID;
	private TerminalRule tINT_TYPE;
	private TerminalRule tSTRING;
	private TerminalRule tCSTRING;
	private TerminalRule tOREST;
	private TerminalRule tARRAYL;
	private TerminalRule tARRAYR;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tPOINTER;
	private AbstractElementElements pAbstractElement;
	private TopLevelEntityElements pTopLevelEntity;
	private MainLevelEntityElements pMainLevelEntity;
	private TypeDefinitionElements pTypeDefinition;
	private FunctionDefinitionElements pFunctionDefinition;
	private AliasDefinitionElements pAliasDefinition;
	private TypeUseElements pTypeUse;
	private AddressUseElements pAddressUse;
	private AddressElements pAddress;
	private PredefinedElements pPredefined;
	private Primitive_TypeElements pPrimitive_Type;
	private FloatingPoint_TypeElements pFloatingPoint_Type;
	private Predefined_TypesElements pPredefined_Types;
	private VectorElements pVector;
	private ArrayElements pArray;
	private EmptyArrayElements pEmptyArray;
	private Aggregate_TypesElements pAggregate_Types;
	private ConstantElements pConstant;
	private NonConstantValueElements pNonConstantValue;
	private ValueElements pValue;
	private StructureElements pStructure;
	private OpaqueElements pOpaque;
	private ParameterListElements pParameterList;
	private FunctionBodyElements pFunctionBody;
	private BasicBlockElements pBasicBlock;
	private TypeListElements pTypeList;
	private RETURN_ATTRIBUTESElements pRETURN_ATTRIBUTES;
	private CallingConvElements pCallingConv;
	private FUNCTION_ATTRIBUTESElements pFUNCTION_ATTRIBUTES;
	private VISIBILITYElements pVISIBILITY;
	private LINKAGEElements pLINKAGE;
	private ALIAS_LINKAGEElements pALIAS_LINKAGE;
	private ALIGNMENTElements pALIGNMENT;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public LLVMGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.upb.llvm_parser.LLVM".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/// *
	//
	// * This Grammer is used to parse a llvm document.
	//
	// * The llvm project itself is located at http://llvm.org
	//
	// * For a language introduction see: http://llvm.org/docs/LangRef.html
	//
	// * A list of guides can be found on: http://llvm.org/docs/userguides.html
	//
	// * / LLVM:
	//
	//	elements+=AbstractElement*;
	public LLVMElements getLLVMAccess() {
		return (pLLVM != null) ? pLLVM : (pLLVM = new LLVMElements());
	}
	
	public ParserRule getLLVMRule() {
		return getLLVMAccess().getRule();
	}

	/// *
	//
	// * Integer defintion: iN(*)*
	//
	// * Examples:
	//
	// * 	i32  			- 32 bit Integer
	//
	// *  i1   			- Single bit Integer
	//
	// *  i32 (i32*) *	- A pointer to a function that takes an i32*, returning an i32.
	//
	// * / //terminal VALID_ID:
	//
	////	(((('%' | '@') '.'*) (ID | '(' ID ')' | INT | STRING)) |
	//
	////	'(' VALID_ID POINTER? ')') ('.' ((ID) | '(' ID ')'))*;
	//
	//terminal INT returns ecore::EInt:
	//
	//	"-"? "0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//terminal VALID_ID:
	//
	//	(("%" | "@") "."* (("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")* | INT | STRING) | "(" VALID_ID
	//
	//	POINTER? ")") ("." (("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")* | "(" ("a".."z" | "A".."Z" |
	//
	//	"_") ("a".."z" | "A".."Z" | "_" | "0".."9")* POINTER? ")"))*;
	public TerminalRule getVALID_IDRule() {
		return (tVALID_ID != null) ? tVALID_ID : (tVALID_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "VALID_ID"));
	} 

	//terminal INT_TYPE:
	//
	//	"i" "0".."9"+ POINTER?;
	public TerminalRule getINT_TYPERule() {
		return (tINT_TYPE != null) ? tINT_TYPE : (tINT_TYPE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT_TYPE"));
	} 

	//terminal STRING:
	//
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "0" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" |
	//
	//	"t" | "n" | "f" | "r" | "u" | "0" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal CSTRING:
	//
	//	"c" STRING;
	public TerminalRule getCSTRINGRule() {
		return (tCSTRING != null) ? tCSTRING : (tCSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CSTRING"));
	} 

	//terminal OREST:
	//
	//	"(...)" POINTER?;
	public TerminalRule getORESTRule() {
		return (tOREST != null) ? tOREST : (tOREST = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OREST"));
	} 

	//terminal ARRAYL:
	//
	//	"[";
	public TerminalRule getARRAYLRule() {
		return (tARRAYL != null) ? tARRAYL : (tARRAYL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ARRAYL"));
	} 

	//terminal ARRAYR:
	//
	//	"]" POINTER?;
	public TerminalRule getARRAYRRule() {
		return (tARRAYR != null) ? tARRAYR : (tARRAYR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ARRAYR"));
	} 

	/// *
	//
	// * To distinguish the types here only Floating Types
	//
	// * / //terminal F_POINT:
	//
	////	'half' | 'float' | 'double' | 'x86_fp80' | 'fp128' | 'ppc_fp128';
	//
	/// *
	//
	// * Comments are delimited with a ';' and go until the end of line.
	//
	// * / terminal SL_COMMENT:
	//
	//	";" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	/// *
	//
	// * Initial Variable Definition
	//
	// * Every Variable starts with either '%' for local or '@' for global
	//
	// * the regualar expression for this identifiers is [%@][a-zA-Z$._][a-zA-Z$._0-9]*
	//
	// * 
	//
	// * Examples:
	//
	// *  %foo
	//
	// *  (%Stack.Node).Node.a.very.long.identifier 
	//
	// *  @_44bar.your.choice
	//
	// * / //terminal VAR_TYPE:
	//
	////	(((('%' | '@') '.'*) (NOBRACKET | '(' NOBRACKET ')' | INT | STRING) ) |
	//
	////	'('+ (('%' | '@') '.'*) (NOBRACKET | '(' NOBRACKET ')' | INT | STRING) '*'* ')'+);
	//
	////
	//
	////	/ *
	//
	//// * Inner Identifier Rule (no Brackets allowed)
	//
	//// * /
	//
	////terminal NOBRACKET:
	//
	////	(('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* POINT?);
	//
	////
	//
	////	/ *
	//
	//// * This rule is responsible for the dot
	//
	//// * /
	//
	////terminal POINT:
	//
	////	'.' ((NOBRACKET) | '(' NOBRACKET ')');
	//
	//terminal POINTER:
	//
	//	"*"+;
	public TerminalRule getPOINTERRule() {
		return (tPOINTER != null) ? tPOINTER : (tPOINTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "POINTER"));
	} 

	/// *
	//
	// * An Abstract Element is either a TopLevelEntity, used for the predefinitions of the llvm-code
	//
	// * or a MainLevelEntity, which are basically functiondefinitions. 
	//
	// * / AbstractElement:
	//
	//	TopLevelEntity SL_COMMENT? | MainLevelEntity SL_COMMENT?;
	public AbstractElementElements getAbstractElementAccess() {
		return (pAbstractElement != null) ? pAbstractElement : (pAbstractElement = new AbstractElementElements());
	}
	
	public ParserRule getAbstractElementRule() {
		return getAbstractElementAccess().getRule();
	}

	/// *
	//
	// * Predefinitions of the llcm-code
	//
	// * / TopLevelEntity:
	//
	//	"module" "asm" module=STRING | "target" ("datalayout" | "triple") "=" target=STRING | "deplibs" "=" ARRAYL
	//
	//	libs+=STRING ("," libs+=STRING)* ARRAYR;
	public TopLevelEntityElements getTopLevelEntityAccess() {
		return (pTopLevelEntity != null) ? pTopLevelEntity : (pTopLevelEntity = new TopLevelEntityElements());
	}
	
	public ParserRule getTopLevelEntityRule() {
		return getTopLevelEntityAccess().getRule();
	}

	/// *
	//
	// * This rule is used to devide the Function Definitions form the Variable Definitions.
	//
	// * / //	| AliasDefinition
	//
	//MainLevelEntity:
	//
	//	TypeDefinition | FunctionDefinition;
	public MainLevelEntityElements getMainLevelEntityAccess() {
		return (pMainLevelEntity != null) ? pMainLevelEntity : (pMainLevelEntity = new MainLevelEntityElements());
	}
	
	public ParserRule getMainLevelEntityRule() {
		return getMainLevelEntityAccess().getRule();
	}

	//TypeDefinition:
	//
	//	address=Address "=" (LINKAGE | "global" | "unnamed_addr" | "constant")* ("type" (struct=Structure | Opaque));
	public TypeDefinitionElements getTypeDefinitionAccess() {
		return (pTypeDefinition != null) ? pTypeDefinition : (pTypeDefinition = new TypeDefinitionElements());
	}
	
	public ParserRule getTypeDefinitionRule() {
		return getTypeDefinitionAccess().getRule();
	}

	//FunctionDefinition:
	//
	//	"define" LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=TypeUse address=Address pl=ParameterList
	//
	//	"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT? body=FunctionBody | "declare" LINKAGE?
	//
	//	VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=TypeUse address=Address (tList=TypeList | OREST)
	//
	//	"unnamed_addr"? FUNCTION_ATTRIBUTES* ("section " STRING)? ALIGNMENT?;
	public FunctionDefinitionElements getFunctionDefinitionAccess() {
		return (pFunctionDefinition != null) ? pFunctionDefinition : (pFunctionDefinition = new FunctionDefinitionElements());
	}
	
	public ParserRule getFunctionDefinitionRule() {
		return getFunctionDefinitionAccess().getRule();
	}

	//AliasDefinition:
	//
	//	address=Address "=" "alias" ALIAS_LINKAGE? VISIBILITY? aliastype=TypeUse aliasvalue=Value aliasee=TypeUse;
	public AliasDefinitionElements getAliasDefinitionAccess() {
		return (pAliasDefinition != null) ? pAliasDefinition : (pAliasDefinition = new AliasDefinitionElements());
	}
	
	public ParserRule getAliasDefinitionRule() {
		return getAliasDefinitionAccess().getRule();
	}

	//TypeUse:
	//
	//	Predefined | AddressUse;
	public TypeUseElements getTypeUseAccess() {
		return (pTypeUse != null) ? pTypeUse : (pTypeUse = new TypeUseElements());
	}
	
	public ParserRule getTypeUseRule() {
		return getTypeUseAccess().getRule();
	}

	//AddressUse:
	//
	//	address=[Address|VALID_ID] pointer=POINTER?;
	public AddressUseElements getAddressUseAccess() {
		return (pAddressUse != null) ? pAddressUse : (pAddressUse = new AddressUseElements());
	}
	
	public ParserRule getAddressUseRule() {
		return getAddressUseAccess().getRule();
	}

	//Address:
	//
	//	name=VALID_ID;
	public AddressElements getAddressAccess() {
		return (pAddress != null) ? pAddress : (pAddress = new AddressElements());
	}
	
	public ParserRule getAddressRule() {
		return getAddressAccess().getRule();
	}

	//Predefined:
	//
	//	type=Predefined_Types pointer=POINTER?;
	public PredefinedElements getPredefinedAccess() {
		return (pPredefined != null) ? pPredefined : (pPredefined = new PredefinedElements());
	}
	
	public ParserRule getPredefinedRule() {
		return getPredefinedAccess().getRule();
	}

	//Primitive_Type:
	//
	//	"void" | "null" | "label" | "undef" | "true" | "false";
	public Primitive_TypeElements getPrimitive_TypeAccess() {
		return (pPrimitive_Type != null) ? pPrimitive_Type : (pPrimitive_Type = new Primitive_TypeElements());
	}
	
	public ParserRule getPrimitive_TypeRule() {
		return getPrimitive_TypeAccess().getRule();
	}

	//FloatingPoint_Type:
	//
	//	"half" | "float" | "double" | "x86_fp80" | "fp128" | "ppc_fp128";
	public FloatingPoint_TypeElements getFloatingPoint_TypeAccess() {
		return (pFloatingPoint_Type != null) ? pFloatingPoint_Type : (pFloatingPoint_Type = new FloatingPoint_TypeElements());
	}
	
	public ParserRule getFloatingPoint_TypeRule() {
		return getFloatingPoint_TypeAccess().getRule();
	}

	//Predefined_Types:
	//
	//	Primitive_Type | INT_TYPE | FloatingPoint_Type;
	public Predefined_TypesElements getPredefined_TypesAccess() {
		return (pPredefined_Types != null) ? pPredefined_Types : (pPredefined_Types = new Predefined_TypesElements());
	}
	
	public ParserRule getPredefined_TypesRule() {
		return getPredefined_TypesAccess().getRule();
	}

	//Vector:
	//
	//	"<" INT "x" TypeUse ">";
	public VectorElements getVectorAccess() {
		return (pVector != null) ? pVector : (pVector = new VectorElements());
	}
	
	public ParserRule getVectorRule() {
		return getVectorAccess().getRule();
	}

	//Array:
	//
	//	ARRAYL INT "x" TypeUse ARRAYR;
	public ArrayElements getArrayAccess() {
		return (pArray != null) ? pArray : (pArray = new ArrayElements());
	}
	
	public ParserRule getArrayRule() {
		return getArrayAccess().getRule();
	}

	//EmptyArray:
	//
	//	ARRAYL ARRAYR;
	public EmptyArrayElements getEmptyArrayAccess() {
		return (pEmptyArray != null) ? pEmptyArray : (pEmptyArray = new EmptyArrayElements());
	}
	
	public ParserRule getEmptyArrayRule() {
		return getEmptyArrayAccess().getRule();
	}

	//Aggregate_Types:
	//
	//	Structure | Array | Vector;
	public Aggregate_TypesElements getAggregate_TypesAccess() {
		return (pAggregate_Types != null) ? pAggregate_Types : (pAggregate_Types = new Aggregate_TypesElements());
	}
	
	public ParserRule getAggregate_TypesRule() {
		return getAggregate_TypesAccess().getRule();
	}

	//Constant:
	//
	//	value=INT;
	public ConstantElements getConstantAccess() {
		return (pConstant != null) ? pConstant : (pConstant = new ConstantElements());
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}

	//NonConstantValue:
	//
	//	name=VALID_ID pointer=POINTER?;
	public NonConstantValueElements getNonConstantValueAccess() {
		return (pNonConstantValue != null) ? pNonConstantValue : (pNonConstantValue = new NonConstantValueElements());
	}
	
	public ParserRule getNonConstantValueRule() {
		return getNonConstantValueAccess().getRule();
	}

	//Value:
	//
	//	Constant | NonConstantValue;
	public ValueElements getValueAccess() {
		return (pValue != null) ? pValue : (pValue = new ValueElements());
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}

	////ValueStruct:
	//
	////	'{' types+=TypeUse ('()*')? Value+=Value (',' types+=TypeUse ('()*')? Value+=Value) '}';
	//
	//Structure:
	//
	//	{Structure} "{" (types+=TypeUse ("," types+=TypeUse)*)? "}" POINTER?;
	public StructureElements getStructureAccess() {
		return (pStructure != null) ? pStructure : (pStructure = new StructureElements());
	}
	
	public ParserRule getStructureRule() {
		return getStructureAccess().getRule();
	}

	/// *
	//
	// * Aliases act as "second name" for the aliasee value (which can be either function, 
	//
	// * global variable, another alias or bitcast of global value). 
	//
	// * Aliases may have an optional linkage type, and an optional visibility style
	//
	// * / //Alias:
	//
	////	'alias' ALIAS_LINKAGE? VISIBILITY? aliastype=Type aliasvalue=Value aliasee=Type;
	//
	//Opaque:
	//
	//	"opaque";
	public OpaqueElements getOpaqueAccess() {
		return (pOpaque != null) ? pOpaque : (pOpaque = new OpaqueElements());
	}
	
	public ParserRule getOpaqueRule() {
		return getOpaqueAccess().getRule();
	}

	////	/ *
	//
	//// * This rule creates a Parameterlist and saves also the TypeAndValue to each parameter
	//
	//// * Brackets are 
	//
	//// * /
	//
	//ParameterList:
	//
	//	{ParameterList} "(" (types+=TypeUse Lists+=TypeList? RETURN_ATTRIBUTES* variables+=Value ("," types+=TypeUse
	//
	//	Lists+=TypeList? RETURN_ATTRIBUTES* variables+=Value)*)? ")";
	public ParameterListElements getParameterListAccess() {
		return (pParameterList != null) ? pParameterList : (pParameterList = new ParameterListElements());
	}
	
	public ParserRule getParameterListRule() {
		return getParameterListAccess().getRule();
	}

	////
	//
	////	/ * 
	//
	//// * This rule is the start of the function body and has to be right after de 'define' of a function.
	//
	//// * Every Functionbody contains at leaset one Basic Block. 
	//
	//// * /
	//
	////	meta+=MetadataValue*;
	//
	//FunctionBody: //	meta+=MetadataValue*
	//
	//	"{" blocks+=BasicBlock+ "}";
	public FunctionBodyElements getFunctionBodyAccess() {
		return (pFunctionBody != null) ? pFunctionBody : (pFunctionBody = new FunctionBodyElements());
	}
	
	public ParserRule getFunctionBodyRule() {
		return getFunctionBodyAccess().getRule();
	}

	////	/ *
	//
	//// * Every Basic Block is contained inside a Functionbody and has a label(eventually) and at least one instruction 
	//
	//// * /
	//
	////	instructions+=(TypeDefinition | Instruction)*
	//
	////	(retadr=VAR_TYPE '=' )?terminator=Ret_Instr;
	//
	//BasicBlock:
	//
	//	label=ID ":";
	public BasicBlockElements getBasicBlockAccess() {
		return (pBasicBlock != null) ? pBasicBlock : (pBasicBlock = new BasicBlockElements());
	}
	
	public ParserRule getBasicBlockRule() {
		return getBasicBlockAccess().getRule();
	}

	////Ret_Instr:
	//
	////	Return | Branch | Switch | IndirectBranch | Invoke | Resume | Unreachable;
	//
	////
	//
	////	/ *
	//
	//// * If a function is declared, the parameterlist has to be set empty or contain a List of Types.
	//
	//// * /
	//
	//TypeList:
	//
	//	{TypeList} ("()" | "(" (types+=TypeUse typelists+=TypeList? RETURN_ATTRIBUTES? ("," types+=TypeUse
	//
	//	typelists+=TypeList? RETURN_ATTRIBUTES?)*)? (")" | ")*" | ")**" | ")***" | ")****" | ")*****"));
	public TypeListElements getTypeListAccess() {
		return (pTypeList != null) ? pTypeList : (pTypeList = new TypeListElements());
	}
	
	public ParserRule getTypeListRule() {
		return getTypeListAccess().getRule();
	}

	////
	//
	////	/ *
	//
	//// * An Aggregate is a tuple of types enclosed by curly brackets
	//
	//// * /
	//
	////
	//
	///// *
	//
	//// * A Local Variable definition needs a name, followed by an equalsign and either an Instruction, an Alias or a Type  
	//
	//// * /
	//
	////
	//
	///// *
	//
	//// * This is only to summarize all possible Instructions
	//
	//// * /
	//
	////Instruction:
	//
	////	('volatile'? Load) | ('volatile'? Store) | Fence | GetElementPtr | LOGICAL_OP | ARITHMETIC_OP | Compare |
	//
	////	Cast | ShuffleVector | InsertElement | ExtractElement | InsertValue | ExtractValue | Alloc |
	//
	////	CmpXchg | AtomicRMW | PHI | Select | Call | VA_Arg | LandingPad;
	//
	////
	//
	////	/ *
	//
	//// * This rule is used to bind a Type to a value.
	//
	//// * It is used for example on parameterlists, on instructions etc.
	//
	//// * /
	//
	//////TypeAndValue:
	//
	//////	(type=(VAR_TYPE | B_TYPE)RETURN_ATTRIBUTES? value=Type) | aggregate=Aggregate value=Type;
	//
	////
	//
	////
	//
	///// *
	//
	//// * The 'getelementptr' instruction is used to get the address of a subelement of an aggregate data structure. 
	//
	//// * It performs address calculation only and does not access memory.
	//
	//// * /
	//
	////GetElementPtr:
	//
	////	'getelementptr' 'inbounds'? '('? ((elementtype=Type (types=TypeList)? | elementarray=ARRAY) element=Value (',' indicetypes+=Type
	//
	////	indices+=Value)*);
	//
	////
	//
	////	/ * //Alias:
	//
	////	'alias' ALIAS_LINKAGE? VISIBILITY? aliastype=Type aliasvalue=Value aliasee=Type;
	//
	//// * The 'extractvalue' instruction extracts the value of a member field from an aggregate value.
	//
	//// * /
	//
	////ExtractValue:
	//
	////	'extractvalue' (array=ARRAY | struct=Structure) value=Value (',' index+=INT)+;
	//
	////
	//
	////	/ *
	//
	//// * The 'insertvalue' instruction inserts a value into a member field in an aggregate value.
	//
	//// * /
	//
	////InsertValue:
	//
	////	'insertvalue' struct=Structure value=Value ',' inserttype=Type insertvalue=Value(',' index+=INT)+;
	//
	////
	//
	////	/ *
	//
	//// * The 'fence' instruction is used to introduce happens-before edges between operations.
	//
	//// * /
	//
	////Fence:
	//
	////	'fence' 'singlethread'? ordering=ATOMIC_ORDERING;
	//
	////
	//
	////	/ *
	//
	//// * This is only a summarize of the possible atomic orderings
	//
	//// * /
	//
	////ATOMIC_ORDERING:
	//
	////	'unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst';
	//
	////
	//
	////	/ *
	//
	//// * The 'cmpxchg' instruction is used to atomically modify memory. It loads a value in memory and compares it to 
	//
	//// * a given value. If they are equal, it stores a new value into the memory.
	//
	//// * /
	//
	////CmpXchg:
	//
	////	'cmpxchg' 'volatile'? adresstype=Type adress=Value ',' comparetype=Type comparevalue=Value ',' newtype=Type
	//
	////	newvalue=Value 'singlethread'?
	//
	////	ordering=ATOMIC_ORDERING;
	//
	////
	//
	////	/ *
	//
	//// * The 'atomicrmw' instruction is used to atomically modify memory.
	//
	//// * /
	//
	////AtomicRMW:
	//
	////	'atomicrmw' 'volatile'? BIN_OP adresstype=Type adress=Value ',' optype=Type opvalue=Value'singlethread'?
	//
	////	ordering=ATOMIC_ORDERING;
	//
	////
	//
	////	/ *
	//
	//// * This is only to summarize the different Binary Operations
	//
	//// * /
	//
	////BIN_OP:
	//
	////	('xchg' | 'add' | 'sub' | 'and' | 'nand' | 'or' | 'xor' | 'max' | 'min' | 'umax' | 'umin');
	//
	////
	//
	////	/ *
	//
	//// * The 'load' instruction is used to read from memory.
	//
	//// * /
	//
	////Load:
	//
	////	'load' 'volatile'? adresstype=Type (types=TypeList)? adress=Value (',' ((ALIGNMENT) | (MetadataValue)+))* |
	//
	////	'load' 'atomic' 'volatile'? adresstype=Type adress=Value(types=TypeList)? 'singlethread'? ordering=ATOMIC_ORDERING (',' 'align'
	//
	////	index=INT)?;
	//
	////
	//
	////	/ *
	//
	//// * The 'store' instruction is used to write to memory.
	//
	//// * /
	//
	////Store:
	//
	////	'store' 'volatile'? newtype=(Type) (types+=TypeList)? (newvalue=Value|newelement=GetElementPtr ')') ',' adresstype=Type (types+=TypeList)? adress=Value (',' ((ALIGNMENT) |
	//
	////	(MetadataValue)+))* |
	//
	////	'store' 'atomic' 'volatile'? newtype=Type(types+=TypeList)? newvalue=Value ',' adresstype=Type (types+=TypeList)? adress=Value 'singlethread'?
	//
	////	ordering=ATOMIC_ORDERING (','
	//
	////	'align' index=INT)?;
	//
	////
	//
	////	/ *
	//
	//// * The 'call' instruction represents a simple function call.
	//
	//// * /
	//
	////Call:
	//
	////	'tail'? 'call' CallingConv? RETURN_ATTRIBUTES? adresstype=Type ((adress=Value)|'asm' 'sideeffect'? STRING ',' STRING) pList=ParameterList FUNCTION_ATTRIBUTES*(',' '!srcloc' '!'INT)*;
	//
	////
	//
	////	/ *
	//
	//// * This is to summarize the possible return attributes
	//
	//// * /
	//
	//RETURN_ATTRIBUTES:
	//
	//	"zeroext" | "signext" | "inreg" | "byval" | "sret" | "noalias" | "nocapture" | "nest";
	public RETURN_ATTRIBUTESElements getRETURN_ATTRIBUTESAccess() {
		return (pRETURN_ATTRIBUTES != null) ? pRETURN_ATTRIBUTES : (pRETURN_ATTRIBUTES = new RETURN_ATTRIBUTESElements());
	}
	
	public ParserRule getRETURN_ATTRIBUTESRule() {
		return getRETURN_ATTRIBUTESAccess().getRule();
	}

	////
	//
	////Alloc:
	//
	////	'alloca' ((type=Type typelist=TypeList?)) (',' numelementstype=Type numelementsvalue=Value)? (',' ALIGNMENT)?;
	//
	////
	//
	////	/ *
	//
	//// * This is to summarize the possible Calling Conventions
	//
	//// * /
	//
	//CallingConv:
	//
	//	"ccc" | "fastcc" | "coldcc" | "x86_stdcallcc" | "x86_fastcallcc" | "x86_thiscallcc" | "arm_apcscc" | "arm_aapcscc" |
	//
	//	"arm_aapcs_vfpcc" | "msp430_intrcc" | "ptx_kernel" | "ptx_device" | "spir_func" | "spir_kernel" | "cc" "<" INT ">"
	//
	//	INT;
	public CallingConvElements getCallingConvAccess() {
		return (pCallingConv != null) ? pCallingConv : (pCallingConv = new CallingConvElements());
	}
	
	public ParserRule getCallingConvRule() {
		return getCallingConvAccess().getRule();
	}

	////
	//
	////	/ *
	//
	//// * This is to summarize the possible function attributes
	//
	//// * /
	//
	//FUNCTION_ATTRIBUTES:
	//
	//	"address_safety" | "alignstack" "(" "<" INT ">" ")" | "alwaysinline" | "nonlazybind" | "inlinehint" | "naked" |
	//
	//	"noimplicitfloat" | "noinline" | "noredzone" | "noreturn" | "nounwind" | "optsize" | "readnone" | "readonly" |
	//
	//	"returns_twice" | "ssp" | "sspreq" | "uwtable";
	public FUNCTION_ATTRIBUTESElements getFUNCTION_ATTRIBUTESAccess() {
		return (pFUNCTION_ATTRIBUTES != null) ? pFUNCTION_ATTRIBUTES : (pFUNCTION_ATTRIBUTES = new FUNCTION_ATTRIBUTESElements());
	}
	
	public ParserRule getFUNCTION_ATTRIBUTESRule() {
		return getFUNCTION_ATTRIBUTESAccess().getRule();
	}

	////
	//
	////	/ *
	//
	//// * The 'phi' instruction is used to implement the φ node in the SSA graph representing the function.
	//
	//// * /
	//
	////PHI:
	//
	////	'phi' type=Type ARRAYL values+=ValuePair ARRAYR (',' ARRAYL values+=ValuePair ARRAYR)*;
	//
	////
	//
	////	/ *
	//
	//// * This rule is used to bring in more clarity in some instructions
	//
	//// * /
	//
	////ValuePair:
	//
	////	value1=Value ',' value2=Value;
	//
	////
	//
	////	/ *
	//
	//// * The 'landingpad' instruction is used by LLVM's exception handling system to specify that a basic 
	//
	//// * block is a landing pad — one where the exception lands, and corresponds to the code found in the 
	//
	//// * catch portion of a try/catch sequence. It defines values supplied by the personality function (pers_fn)
	//
	//// * upon re-entry to the function. The resultval has the type resultty.
	//
	//// * /
	//
	////LandingPad:
	//
	////	'landingpad' struct=Structure 'personality' personalitytype=Type
	//
	////	(personalityvalue=Value | personalityfunction=CAST_TYPE '(' value=Value OREST
	//
	////	VAR_TYPE 'to' castto=Type ')') ('cleanup' clause+=Clause* | clause+=Clause+);
	//
	////
	//
	////	/ *
	//
	//// * A clause begins with the clause type — catch or filter — and contains the global variable representing
	//
	//// * the "type" that may be caught or filtered respectively. Unlike the catch clause, the filter clause takes
	//
	//// * an array constant as its argument. Use "[0 x i8**] undef" for a filter which cannot throw. The 'landingpad'
	//
	//// * instruction must contain at least one clause or the cleanup flag.
	//
	//// * /
	//
	////Clause:
	//
	////	'catch' type=Type value=Value |
	//
	////	'filter' filterarray=ARRAY ((constant=Value)|'zeroinitializer');
	//
	////
	//
	////	/ *
	//
	//// * The 'select' instruction is used to choose one value based on a condition, without branching.
	//
	//// * /
	//
	////Select:
	//
	////	'select' conditiontype=Type conditionvalue=Value ',' val1type=Type val1value=Value ',' val2type=Type val2value=Value;
	//
	////
	//
	////	/ *
	//
	//// * The 'va_arg' instruction is used to access arguments passed through the "variable argument" area of a 
	//
	//// * function call. It is used to implement the va_arg macro in C.
	//
	//// * /
	//
	////VA_Arg:
	//
	////	'va_arg' listtype=Type listvalue=Value ',' argType=Type;
	//
	////
	//
	////	/ *
	//
	//// * The 'extractelement' instruction extracts a single scalar element from a vector at a specified index.
	//
	//// * /
	//
	////ExtractElement:
	//
	////	'extractelement' vectortype=Type vectorvalue=Value ',' indextype=Type index=Value;
	//
	////
	//
	////	/ *
	//
	//// * The 'insertelement' instruction inserts a scalar element into a vector at a specified index.
	//
	//// * /
	//
	////InsertElement:
	//
	////	'insertelement' vectortype=Type vectorvalue=Value ',' scalartype=Type scalarvalue=Value ',' indextype=Type index=Value;
	//
	////
	//
	////	/ *
	//
	//// * The 'shufflevector' instruction constructs a permutation of elements from two input vectors, 
	//
	//// * returning a vector with the same element type as the input and length that is the same as the shuffle mask.
	//
	//// * /
	//
	////ShuffleVector:
	//
	////	'shufflevector' val1type=Type val1value=Value ',' val2type=Type val2value=Value ',' masktype=Type maskvalue=Value;
	//
	////
	//
	////	/ *
	//
	//// * This rule is to provide a typecast. Nothing special
	//
	//// * Example
	//
	//// *  %X = trunc i32 257 to i8
	//
	//// *  %Z = fptosi float 1.04E+17 to i8
	//
	//// * /
	//
	////Cast:
	//
	////	CAST_TYPE '('? ((casttype=Type ('()*'|types+=TypeList)?) | caststruct=Structure) '('* (value=Value (',' dual=Value ')*')? |
	//
	////	op=GetElementPtr) global=Type? ')'* 'to'
	//
	////	(castto=(Type) (primitive=VAR_TYPE)? ('()*'|types+=TypeList)?);
	//
	////	//	CAST_TYPE ((castfrom=Type | caststruct=Structure)  (value=Type | op=GetElementPtr) global=Type? 'to' castto=Type) |
	//
	//////	'('+(castfrom=Type | caststruct=Structure) '('? (value=Type | op=GetElementPtr) global=Type? ')'* 'to' castto=Type ')'
	//
	////
	//
	///// *
	//
	//// * The instructions in this category are the conversion instructions (casting) which
	//
	//// * all take a single operand and a type. They perform various bit conversions on the operand.
	//
	//// * /
	//
	////CAST_TYPE:
	//
	////	'trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' | 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'
	//
	////	| 'bitcast';
	//
	////
	//
	////	/ *
	//
	//// * The 'icmp' instruction returns a boolean value or a vector of boolean values based on comparison of 
	//
	//// * 		its two integer, integer vector, pointer, or pointer vector operands.
	//
	//// * The 'fcmp' instruction returns a boolean value or vector of boolean values based on comparison of its operands.
	//
	//// * /
	//
	////Compare:
	//
	////	'icmp' I_PREDICATES comptype=Type value1=Value ',' value2=Value |
	//
	////	'fcmp' F_PREDICATES comptype=Type value1=Value ',' value2=Value;
	//
	////
	//
	////	/ *
	//
	//// * This is to summarize the possible Integer Predicates
	//
	//// * /
	//
	////I_PREDICATES:
	//
	////	'eq' | 'ne' | 'ugt' | 'uge' | 'ult' | 'ule' | 'sgt' | 'sge' | 'slt' | 'sle';
	//
	////
	//
	////	/ *
	//
	//// * This is to summarize the possible Floating Predicates
	//
	//// * /
	//
	////F_PREDICATES:
	//
	////	'false' | 'oeq' | 'ogt' | 'oge' | 'olt' | 'ole' | 'one' | 'ord' |
	//
	////	'ueq' | 'ugt' | 'uge' | 'ult' | 'ule' | 'une' | 'uno' | 'true';
	//
	////
	//
	////	/ *
	//
	//// * This is to summarize the possible Arithmetic Operations
	//
	//// * /
	//
	////ARITHMETIC_OP:
	//
	////	('add' | 'fadd' | 'sub' | 'fsub' | 'mul' | 'fmul' | 'udiv' | 'sdiv' | 'fdiv' | 'urem' | 'srem' | 'frem')  (('nsw'|'nuw')('nuw'|'nsw')?)?
	//
	////	optype=Type value1=Value ',' value2=Value;
	//
	////
	//
	////	/ *
	//
	//// * This is to summarize the possible Logical Operations
	//
	//// * /
	//
	////LOGICAL_OP:
	//
	////	('shl' | 'lshr' | 'ashr' | 'and' | 'or' | 'xor') optype=Type value1=Value ',' value2=Value;
	//
	////
	//
	////	/ *
	//
	//// * The 'indirectbr' instruction implements an indirect branch to a label within the current function, whose 
	//
	//// * address is specified by "address". Address must be derived from a blockaddress constant.
	//
	//// * /
	//
	////IndirectBranch:
	//
	////	'indirectbr' adresstype=Type adress=Value ',' ARRAYL (lList=LabelList)? ARRAYR;
	//
	////
	//
	////	/ *
	//
	//// * The Indirect Branch instruction needs a List of labels to jump to. 
	//
	//// * This List is created here an contains Pairs of Types and Values
	//
	//// * /
	//
	////LabelList:
	//
	////	(labeltype+=Type labels+=Value)+;
	//
	////
	//
	////	/ *
	//
	//// * The 'switch' instruction is used to transfer control flow to one of several different places. It is a generalization of 
	//
	//// * the 'br' instruction, allowing a branch to occur to one of many possible destinations.
	//
	//// * /
	//
	////Switch:
	//
	////	'switch' comptype=Type compvalue=Value ',' defaulttype=Type defaultvalue=Value ARRAYL (jTable=JumpTable)? ARRAYR;
	//
	////
	//
	////	/ *
	//
	//// * The Switch instruction needs a list of values and destination, that will be jumped in case of value occures
	//
	//// * /
	//
	////JumpTable:
	//
	////	(jtypes+=Type jvalues+=Value ',' destinationtypes+=Type destinations+=Value)+;
	//
	////
	//
	////	/ *
	//
	//// * The 'invoke' instruction causes control to transfer to a specified function, with the possibility of 
	//
	//// * control flow transfer to either the 'normal' label or the 'exception' label. If the callee function 
	//
	//// * returns with the "ret" instruction, control flow will return to the "normal" label. If the callee 
	//
	//// * (or any indirect callees) returns via the "resume" instruction or other exception handling mechanism, 
	//
	//// * control is interrupted and continued at the dynamically nearest "exception" label.
	//
	//// * 
	//
	//// * The 'exception' label is a landing pad for the exception. As such, 'exception' label is required to
	//
	//// *  have the "landingpad" instruction, which contains the information about the behavior of the program 
	//
	//// * after unwinding happens, as its first non-PHI instruction. The restrictions on the "landingpad" 
	//
	//// * instruction's tightly couples it to the "invoke" instruction, so that the important information contained 
	//
	//// * within the "landingpad" instruction can't be lost through normal code motion.
	//
	//// * /
	//
	////Invoke:
	//
	////	'invoke' CallingConv? RETURN_ATTRIBUTES? functiontype=Type name=Address pList=ParameterList
	//
	////	FUNCTION_ATTRIBUTES* 'to'
	//
	////	totype=Type tovalue=Value 'unwind' unwindtype=Type unwindvalue=Value;
	//
	////
	//
	////	/ *
	//
	//// * The 'resume' instruction is a terminator instruction that has no successors.
	//
	//// * /
	//
	////Resume:
	//
	////	'resume' resumestruct=Structure resumevalue=Value;
	//
	////	/ *
	//
	//// * The 'unreachable' instruction has no defined semantics. This instruction is used to inform the 
	//
	//// * optimizer that a particular portion of the code is not reachable. This can be used to indicate 
	//
	//// * that the code after a no-return function cannot be reached, and other facts.
	//
	//// * /
	//
	////Unreachable:
	//
	////	{Unreachable} 'unreachable';
	//
	////
	//
	////	/ *
	//
	//// * The 'ret' instruction is used to return control flow (and optionally a value) 
	//
	//// * from a function back to the caller.
	//
	//// * 
	//
	//// * There are two forms of the 'ret' instruction: one that returns a value and then 
	//
	//// * causes control flow, and one that just causes control flow to occur.
	//
	//// * /
	//
	////Return:
	//
	////	{Return} 'ret' 'void' (',' '!dbg' '!' INT)? | 'ret' returntype=Type returnvalue=Value (',' '!dbg' '!' INT)?;
	//
	////
	//
	////	/ *
	//
	//// * The 'br' instruction is used to cause control flow to transfer to a different basic block in 
	//
	//// * the current function. There are two forms of this instruction, corresponding to a conditional 
	//
	//// * branch and an unconditional branch.
	//
	//// * /
	//
	////Branch:
	//
	////	'br' destinationtype=Type destination=Value | 'br' condtype=Type condvalue=Value ',' labelTruetype=Type labelTrue=Value
	//
	////	',' labelFalsetype=Type labelFalse=Value;
	//
	////
	//
	////	/ *
	//
	//// * This is to summarize the possible visibilities
	//
	//// * /
	//
	//VISIBILITY:
	//
	//	"default" | "hidden" | "protected";
	public VISIBILITYElements getVISIBILITYAccess() {
		return (pVISIBILITY != null) ? pVISIBILITY : (pVISIBILITY = new VISIBILITYElements());
	}
	
	public ParserRule getVISIBILITYRule() {
		return getVISIBILITYAccess().getRule();
	}

	////	/ *
	//
	//// * This is to summarize the possible linkages
	//
	//// * /
	//
	//LINKAGE:
	//
	//	"private" | "linker_private" | "linker_private_weak" | "available_externally" | "linkonce" | "common" | "appending" |
	//
	//	"extern_weak" | "linkonce_odr" | "linkonce_odr_auto_hide" | "dllimport" | "dllexport" | ALIAS_LINKAGE;
	public LINKAGEElements getLINKAGEAccess() {
		return (pLINKAGE != null) ? pLINKAGE : (pLINKAGE = new LINKAGEElements());
	}
	
	public ParserRule getLINKAGERule() {
		return getLINKAGEAccess().getRule();
	}

	////
	//
	////	/ *
	//
	//// * There are restriction on the Linkages of Aliasees. So...
	//
	//// * /
	//
	//ALIAS_LINKAGE:
	//
	//	"external" | "internal" | "weak" | "weak_odr";
	public ALIAS_LINKAGEElements getALIAS_LINKAGEAccess() {
		return (pALIAS_LINKAGE != null) ? pALIAS_LINKAGE : (pALIAS_LINKAGE = new ALIAS_LINKAGEElements());
	}
	
	public ParserRule getALIAS_LINKAGERule() {
		return getALIAS_LINKAGEAccess().getRule();
	}

	////
	//
	////	/ *
	//
	//// * This rule is needed to support Metadata
	//
	//// * Example:
	//
	//// *  ; Named metadata
	//
	//// *	!1 = metadata !{i32 42}
	//
	//// *	!foo = !{!1, null} 
	//
	//// *  !1 = metadata !{metadata !"omnipotent char", metadata !2}
	//
	//// * /
	//
	////MetadataValue:
	//
	////	(('!' INT) | ('!{' ID '}') | ('!' ID))
	//
	////	('='
	//
	////	(('!' INT) |
	//
	////	('!{' ID'}') |
	//
	////	('!' ID) |
	//
	////	'metadata' (('!' '{' | '!{') 'metadata' '!' STRING ',' ('metadata' '!' INT) '}')?))?;
	//
	////	/ *
	//
	//// * This rule is to define the alignment
	//
	//// * /
	//
	//ALIGNMENT:
	//
	//	"align" //must be a power of 2
	//
	//	INT;
	public ALIGNMENTElements getALIGNMENTAccess() {
		return (pALIGNMENT != null) ? pALIGNMENT : (pALIGNMENT = new ALIGNMENTElements());
	}
	
	public ParserRule getALIGNMENTRule() {
		return getALIGNMENTAccess().getRule();
	}

	//terminal ID:
	//
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal ML_COMMENT:
	//
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal WS:
	//
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
