grammar de.upb.llvm_parser.LLVM with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate llvm "http://www.upb.de/llvm_parser/llvm"

/*
 * This Grammer is used to parse a llvm document.
 * The llvm project itself is located at http://llvm.org
 * For a language introduction see: http://llvm.org/docs/LangRef.html
 * A list of guides can be found on: http://llvm.org/docs/userguides.html
 */
LLVM:
	elements+=AbstractElement*;

	/*
 * Integer defintion: iN(*)*
 * Examples:
 * 	i32  			- 32 bit Integer
 *  i1   			- Single bit Integer
 *  i32 (i32*) *	- A pointer to a function that takes an i32*, returning an i32.
 */
//terminal VALID_ID:
//	(((('%' | '@') '.'*) (ID | '(' ID ')' | INT | STRING)) |
//	'(' VALID_ID POINTER? ')') ('.' ((ID) | '(' ID ')'))*;
terminal INT returns ecore::EInt:
	'-'? ('0'..'9')+;

terminal VALID_ID:
	((('%' | '@') '.'*
	((('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*) |
	INT | STRING)) |
	('(' VALID_ID POINTER? ')'))
	('.'
	((('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*) |
	('(' ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* POINTER? ')')))*;
	
	
terminal INT_TYPE:
	'i' ('0'..'9')+ POINTER?;

terminal STRING:
	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '0' | '"' | "'" | '\\') | !('\\' | '"'))* '"' |
	"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '0' | '"' | "'" | '\\') | !('\\' | "'"))* "'";

terminal CSTRING:
	'c' STRING;

terminal OREST:
	'(...)' POINTER?;

terminal ARRAYL:
	'[';

terminal ARRAYR:
	']' POINTER?;
	/*
 * To distinguish the types here only Floating Types
 */
//terminal F_POINT:
//	'half' | 'float' | 'double' | 'x86_fp80' | 'fp128' | 'ppc_fp128';

/*
 * Comments are delimited with a ';' and go until the end of line.
 */
terminal SL_COMMENT:
	';' !('\n' | '\r')* ('\r'? '\n')?;

	/*
 * Initial Variable Definition
 * Every Variable starts with either '%' for local or '@' for global
 * the regualar expression for this identifiers is [%@][a-zA-Z$._][a-zA-Z$._0-9]*
 * 
 * Examples:
 *  %foo
 *  (%Stack.Node).Node.a.very.long.identifier 
 *  @_44bar.your.choice
 */
//terminal VAR_TYPE:
//	(((('%' | '@') '.'*) (NOBRACKET | '(' NOBRACKET ')' | INT | STRING) ) |
//	'('+ (('%' | '@') '.'*) (NOBRACKET | '(' NOBRACKET ')' | INT | STRING) '*'* ')'+);

//
//	/*
// * Inner Identifier Rule (no Brackets allowed)
// */
//terminal NOBRACKET:
//	(('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* POINT?);
//
//	/*
// * This rule is responsible for the dot
// */
//terminal POINT:
//	'.' ((NOBRACKET) | '(' NOBRACKET ')');
terminal POINTER:
	'*'+;
	/*
 * An Abstract Element is either a TopLevelEntity, used for the predefinitions of the llvm-code
 * or a MainLevelEntity, which are basically functiondefinitions. 
 */
AbstractElement:
	TopLevelEntity SL_COMMENT? |
	MainLevelEntity SL_COMMENT?;

	/*
 * Predefinitions of the llcm-code
 */
TopLevelEntity:
	'module' 'asm' module=STRING |
	'target' ('datalayout' | 'triple') '=' target=STRING |
	'deplibs' '=' ARRAYL libs+=STRING (',' libs+=STRING)* ARRAYR;

	/*
 * This rule is used to devide the Function Definitions form the Variable Definitions.
 */
MainLevelEntity:
	TypeDefinition
	| FunctionDefinition 
//	| AliasDefinition
;

TypeDefinition:
	(address = Address '=' (LINKAGE | 'global' | 'unnamed_addr' | 'constant')* (('type' (struct=Structure | Opaque))));

FunctionDefinition:
	('define' LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=(TypeUse)
	address = Address pl=ParameterList 'unnamed_addr'? FUNCTION_ATTRIBUTES* ('section ' STRING)? ALIGNMENT?
	body=FunctionBody) |(
	'declare' LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=(TypeUse)
	address = Address (tList=TypeList | OREST) 'unnamed_addr'? FUNCTION_ATTRIBUTES* ('section ' STRING)? ALIGNMENT?);

AliasDefinition:
	address = Address '=' 'alias' ALIAS_LINKAGE? VISIBILITY? aliastype=TypeUse aliasvalue=Value aliasee=(TypeUse);

TypeUse:
	Predefined | AddressUse;
	
AddressUse:
	address=[Address|VALID_ID] (pointer=POINTER)?
;

Address:
	name = VALID_ID
;

Predefined:
	type=Predefined_Types (pointer=POINTER)?;

Primitive_Type:
	'void' | 'null' | 'label' | 'undef' | 'true' | 'false';

FloatingPoint_Type:
	'half' | 'float' | 'double' | 'x86_fp80' | 'fp128' | 'ppc_fp128';

Predefined_Types:
	Primitive_Type | INT_TYPE | FloatingPoint_Type;
Vector:
	'<' INT 'x' TypeUse '>'
 ;
Array:
	ARRAYL INT 'x' TypeUse ARRAYR
;
	
EmptyArray:
	ARRAYL ARRAYR
;

 Aggregate_Types:
	Structure | Array | Vector
;
Constant:
	value=INT;

NonConstantValue:
	name=VALID_ID (pointer=POINTER)?;

Value:
	Constant | NonConstantValue;

	//ValueStruct:
//	'{' types+=TypeUse ('()*')? Value+=Value (',' types+=TypeUse ('()*')? Value+=Value) '}';
Structure:
	{Structure} '{' (types+=TypeUse (',' types+=TypeUse)*)? '}' POINTER?;
	/*
 * Aliases act as "second name" for the aliasee value (which can be either function, 
 * global variable, another alias or bitcast of global value). 
 * Aliases may have an optional linkage type, and an optional visibility style
 */
//Alias:
//	'alias' ALIAS_LINKAGE? VISIBILITY? aliastype=Type aliasvalue=Value aliasee=Type;
Opaque:
	'opaque';

	//	/*
// * This rule creates a Parameterlist and saves also the TypeAndValue to each parameter
// * Brackets are 
// */
ParameterList:
	{ParameterList} '('
	(types+=TypeUse (Lists+=TypeList)? RETURN_ATTRIBUTES* variables+=Value
	(',' types+=TypeUse (Lists+=TypeList)? RETURN_ATTRIBUTES* variables+=Value)*)?
	')';

	//
//	/* 
// * This rule is the start of the function body and has to be right after de 'define' of a function.
// * Every Functionbody contains at leaset one Basic Block. 
// */
FunctionBody:
//	meta+=MetadataValue*
	'{' blocks+=BasicBlock+ '}'
	//	meta+=MetadataValue*;
;
//	/*
// * Every Basic Block is contained inside a Functionbody and has a label(eventually) and at least one instruction 
// */
BasicBlock:
	(label=ID ':')
	//	instructions+=(TypeDefinition | Instruction)*
	//	(retadr=VAR_TYPE '=' )?terminator=Ret_Instr;
;
//Ret_Instr:
//	Return | Branch | Switch | IndirectBranch | Invoke | Resume | Unreachable;
//
//	/*
// * If a function is declared, the parameterlist has to be set empty or contain a List of Types.
// */
TypeList:
	{TypeList} ('()' | ('(' (types+=TypeUse (typelists+=TypeList)? RETURN_ATTRIBUTES? (',' types+=TypeUse
	(typelists+=TypeList)? RETURN_ATTRIBUTES?)*)? (')' | ')*' | ')**' | ')***' | ')****' | ')*****')));
	//
//	/*
// * An Aggregate is a tuple of types enclosed by curly brackets
// */
//
///*
// * A Local Variable definition needs a name, followed by an equalsign and either an Instruction, an Alias or a Type  
// */
//
///*
// * This is only to summarize all possible Instructions
// */
//Instruction:
//	('volatile'? Load) | ('volatile'? Store) | Fence | GetElementPtr | LOGICAL_OP | ARITHMETIC_OP | Compare |
//	Cast | ShuffleVector | InsertElement | ExtractElement | InsertValue | ExtractValue | Alloc |
//	CmpXchg | AtomicRMW | PHI | Select | Call | VA_Arg | LandingPad;
//
//	/*
// * This rule is used to bind a Type to a value.
// * It is used for example on parameterlists, on instructions etc.
// */
////TypeAndValue:
////	(type=(VAR_TYPE | B_TYPE)RETURN_ATTRIBUTES? value=Type) | aggregate=Aggregate value=Type;
//
//
///*
// * The 'getelementptr' instruction is used to get the address of a subelement of an aggregate data structure. 
// * It performs address calculation only and does not access memory.
// */
//GetElementPtr:
//	'getelementptr' 'inbounds'? '('? ((elementtype=Type (types=TypeList)? | elementarray=ARRAY) element=Value (',' indicetypes+=Type
//	indices+=Value)*);
//
//	/*//Alias:
//	'alias' ALIAS_LINKAGE? VISIBILITY? aliastype=Type aliasvalue=Value aliasee=Type;
// * The 'extractvalue' instruction extracts the value of a member field from an aggregate value.
// */
//ExtractValue:
//	'extractvalue' (array=ARRAY | struct=Structure) value=Value (',' index+=INT)+;
//
//	/*
// * The 'insertvalue' instruction inserts a value into a member field in an aggregate value.
// */
//InsertValue:
//	'insertvalue' struct=Structure value=Value ',' inserttype=Type insertvalue=Value(',' index+=INT)+;
//
//	/*
// * The 'fence' instruction is used to introduce happens-before edges between operations.
// */
//Fence:
//	'fence' 'singlethread'? ordering=ATOMIC_ORDERING;
//
//	/*
// * This is only a summarize of the possible atomic orderings
// */
//ATOMIC_ORDERING:
//	'unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst';
//
//	/*
// * The 'cmpxchg' instruction is used to atomically modify memory. It loads a value in memory and compares it to 
// * a given value. If they are equal, it stores a new value into the memory.
// */
//CmpXchg:
//	'cmpxchg' 'volatile'? adresstype=Type adress=Value ',' comparetype=Type comparevalue=Value ',' newtype=Type
//	newvalue=Value 'singlethread'?
//	ordering=ATOMIC_ORDERING;
//
//	/*
// * The 'atomicrmw' instruction is used to atomically modify memory.
// */
//AtomicRMW:
//	'atomicrmw' 'volatile'? BIN_OP adresstype=Type adress=Value ',' optype=Type opvalue=Value'singlethread'?
//	ordering=ATOMIC_ORDERING;
//
//	/*
// * This is only to summarize the different Binary Operations
// */
//BIN_OP:
//	('xchg' | 'add' | 'sub' | 'and' | 'nand' | 'or' | 'xor' | 'max' | 'min' | 'umax' | 'umin');
//
//	/*
// * The 'load' instruction is used to read from memory.
// */
//Load:
//	'load' 'volatile'? adresstype=Type (types=TypeList)? adress=Value (',' ((ALIGNMENT) | (MetadataValue)+))* |
//	'load' 'atomic' 'volatile'? adresstype=Type adress=Value(types=TypeList)? 'singlethread'? ordering=ATOMIC_ORDERING (',' 'align'
//	index=INT)?;
//
//	/*
// * The 'store' instruction is used to write to memory.
// */
//Store:
//	'store' 'volatile'? newtype=(Type) (types+=TypeList)? (newvalue=Value|newelement=GetElementPtr ')') ',' adresstype=Type (types+=TypeList)? adress=Value (',' ((ALIGNMENT) |
//	(MetadataValue)+))* |
//	'store' 'atomic' 'volatile'? newtype=Type(types+=TypeList)? newvalue=Value ',' adresstype=Type (types+=TypeList)? adress=Value 'singlethread'?
//	ordering=ATOMIC_ORDERING (','
//	'align' index=INT)?;
//
//	/*
// * The 'call' instruction represents a simple function call.
// */
//Call:
//	'tail'? 'call' CallingConv? RETURN_ATTRIBUTES? adresstype=Type ((adress=Value)|'asm' 'sideeffect'? STRING ',' STRING) pList=ParameterList FUNCTION_ATTRIBUTES*(',' '!srcloc' '!'INT)*;
//
//	/*
// * This is to summarize the possible return attributes
// */
RETURN_ATTRIBUTES:
	'zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest';
	//
//Alloc:
//	'alloca' ((type=Type typelist=TypeList?)) (',' numelementstype=Type numelementsvalue=Value)? (',' ALIGNMENT)?;
//
//	/*
// * This is to summarize the possible Calling Conventions
// */
CallingConv:
	'ccc' | 'fastcc' | 'coldcc' | 'x86_stdcallcc' | 'x86_fastcallcc' | 'x86_thiscallcc' | 'arm_apcscc' | 'arm_aapcscc' |
	'arm_aapcs_vfpcc' | 'msp430_intrcc' | 'ptx_kernel' | 'ptx_device' | 'spir_func' | 'spir_kernel' | 'cc' '<' INT '>'
	INT;
	//
//	/*
// * This is to summarize the possible function attributes
// */
FUNCTION_ATTRIBUTES:
	'address_safety' | 'alignstack' '(' '<' INT '>' ')' | 'alwaysinline' | 'nonlazybind' | 'inlinehint' | 'naked' |
	'noimplicitfloat' | 'noinline' | 'noredzone' | 'noreturn' | 'nounwind' | 'optsize' | 'readnone' | 'readonly' |
	'returns_twice' | 'ssp' | 'sspreq' | 'uwtable';
	//
//	/*
// * The 'phi' instruction is used to implement the φ node in the SSA graph representing the function.
// */
//PHI:
//	'phi' type=Type ARRAYL values+=ValuePair ARRAYR (',' ARRAYL values+=ValuePair ARRAYR)*;
//
//	/*
// * This rule is used to bring in more clarity in some instructions
// */
//ValuePair:
//	value1=Value ',' value2=Value;
//
//	/*
// * The 'landingpad' instruction is used by LLVM's exception handling system to specify that a basic 
// * block is a landing pad — one where the exception lands, and corresponds to the code found in the 
// * catch portion of a try/catch sequence. It defines values supplied by the personality function (pers_fn)
// * upon re-entry to the function. The resultval has the type resultty.
// */
//LandingPad:
//	'landingpad' struct=Structure 'personality' personalitytype=Type
//	(personalityvalue=Value | personalityfunction=CAST_TYPE '(' value=Value OREST
//	VAR_TYPE 'to' castto=Type ')') ('cleanup' clause+=Clause* | clause+=Clause+);
//
//	/*
// * A clause begins with the clause type — catch or filter — and contains the global variable representing
// * the "type" that may be caught or filtered respectively. Unlike the catch clause, the filter clause takes
// * an array constant as its argument. Use "[0 x i8**] undef" for a filter which cannot throw. The 'landingpad'
// * instruction must contain at least one clause or the cleanup flag.
// */
//Clause:
//	'catch' type=Type value=Value |
//	'filter' filterarray=ARRAY ((constant=Value)|'zeroinitializer');
//
//	/*
// * The 'select' instruction is used to choose one value based on a condition, without branching.
// */
//Select:
//	'select' conditiontype=Type conditionvalue=Value ',' val1type=Type val1value=Value ',' val2type=Type val2value=Value;
//
//	/*
// * The 'va_arg' instruction is used to access arguments passed through the "variable argument" area of a 
// * function call. It is used to implement the va_arg macro in C.
// */
//VA_Arg:
//	'va_arg' listtype=Type listvalue=Value ',' argType=Type;
//
//	/*
// * The 'extractelement' instruction extracts a single scalar element from a vector at a specified index.
// */
//ExtractElement:
//	'extractelement' vectortype=Type vectorvalue=Value ',' indextype=Type index=Value;
//
//	/*
// * The 'insertelement' instruction inserts a scalar element into a vector at a specified index.
// */
//InsertElement:
//	'insertelement' vectortype=Type vectorvalue=Value ',' scalartype=Type scalarvalue=Value ',' indextype=Type index=Value;
//
//	/*
// * The 'shufflevector' instruction constructs a permutation of elements from two input vectors, 
// * returning a vector with the same element type as the input and length that is the same as the shuffle mask.
// */
//ShuffleVector:
//	'shufflevector' val1type=Type val1value=Value ',' val2type=Type val2value=Value ',' masktype=Type maskvalue=Value;
//
//	/*
// * This rule is to provide a typecast. Nothing special
// * Example
// *  %X = trunc i32 257 to i8
// *  %Z = fptosi float 1.04E+17 to i8
// */
//Cast:
//	CAST_TYPE '('? ((casttype=Type ('()*'|types+=TypeList)?) | caststruct=Structure) '('* (value=Value (',' dual=Value ')*')? |
//	op=GetElementPtr) global=Type? ')'* 'to'
//	(castto=(Type) (primitive=VAR_TYPE)? ('()*'|types+=TypeList)?);
//	//	CAST_TYPE ((castfrom=Type | caststruct=Structure)  (value=Type | op=GetElementPtr) global=Type? 'to' castto=Type) |
////	'('+(castfrom=Type | caststruct=Structure) '('? (value=Type | op=GetElementPtr) global=Type? ')'* 'to' castto=Type ')'
//
///*
// * The instructions in this category are the conversion instructions (casting) which
// * all take a single operand and a type. They perform various bit conversions on the operand.
// */
//CAST_TYPE:
//	'trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' | 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'
//	| 'bitcast';
//
//	/*
// * The 'icmp' instruction returns a boolean value or a vector of boolean values based on comparison of 
// * 		its two integer, integer vector, pointer, or pointer vector operands.
// * The 'fcmp' instruction returns a boolean value or vector of boolean values based on comparison of its operands.
// */
//Compare:
//	'icmp' I_PREDICATES comptype=Type value1=Value ',' value2=Value |
//	'fcmp' F_PREDICATES comptype=Type value1=Value ',' value2=Value;
//
//	/*
// * This is to summarize the possible Integer Predicates
// */
//I_PREDICATES:
//	'eq' | 'ne' | 'ugt' | 'uge' | 'ult' | 'ule' | 'sgt' | 'sge' | 'slt' | 'sle';
//
//	/*
// * This is to summarize the possible Floating Predicates
// */
//F_PREDICATES:
//	'false' | 'oeq' | 'ogt' | 'oge' | 'olt' | 'ole' | 'one' | 'ord' |
//	'ueq' | 'ugt' | 'uge' | 'ult' | 'ule' | 'une' | 'uno' | 'true';
//
//	/*
// * This is to summarize the possible Arithmetic Operations
// */
//ARITHMETIC_OP:
//	('add' | 'fadd' | 'sub' | 'fsub' | 'mul' | 'fmul' | 'udiv' | 'sdiv' | 'fdiv' | 'urem' | 'srem' | 'frem')  (('nsw'|'nuw')('nuw'|'nsw')?)?
//	optype=Type value1=Value ',' value2=Value;
//
//	/*
// * This is to summarize the possible Logical Operations
// */
//LOGICAL_OP:
//	('shl' | 'lshr' | 'ashr' | 'and' | 'or' | 'xor') optype=Type value1=Value ',' value2=Value;
//
//	/*
// * The 'indirectbr' instruction implements an indirect branch to a label within the current function, whose 
// * address is specified by "address". Address must be derived from a blockaddress constant.
// */
//IndirectBranch:
//	'indirectbr' adresstype=Type adress=Value ',' ARRAYL (lList=LabelList)? ARRAYR;
//
//	/*
// * The Indirect Branch instruction needs a List of labels to jump to. 
// * This List is created here an contains Pairs of Types and Values
// */
//LabelList:
//	(labeltype+=Type labels+=Value)+;
//
//	/*
// * The 'switch' instruction is used to transfer control flow to one of several different places. It is a generalization of 
// * the 'br' instruction, allowing a branch to occur to one of many possible destinations.
// */
//Switch:
//	'switch' comptype=Type compvalue=Value ',' defaulttype=Type defaultvalue=Value ARRAYL (jTable=JumpTable)? ARRAYR;
//
//	/*
// * The Switch instruction needs a list of values and destination, that will be jumped in case of value occures
// */
//JumpTable:
//	(jtypes+=Type jvalues+=Value ',' destinationtypes+=Type destinations+=Value)+;
//
//	/*
// * The 'invoke' instruction causes control to transfer to a specified function, with the possibility of 
// * control flow transfer to either the 'normal' label or the 'exception' label. If the callee function 
// * returns with the "ret" instruction, control flow will return to the "normal" label. If the callee 
// * (or any indirect callees) returns via the "resume" instruction or other exception handling mechanism, 
// * control is interrupted and continued at the dynamically nearest "exception" label.
// * 
// * The 'exception' label is a landing pad for the exception. As such, 'exception' label is required to
// *  have the "landingpad" instruction, which contains the information about the behavior of the program 
// * after unwinding happens, as its first non-PHI instruction. The restrictions on the "landingpad" 
// * instruction's tightly couples it to the "invoke" instruction, so that the important information contained 
// * within the "landingpad" instruction can't be lost through normal code motion.
// */
//Invoke:
//	'invoke' CallingConv? RETURN_ATTRIBUTES? functiontype=Type name=Address pList=ParameterList
//	FUNCTION_ATTRIBUTES* 'to'
//	totype=Type tovalue=Value 'unwind' unwindtype=Type unwindvalue=Value;
//
//	/*
// * The 'resume' instruction is a terminator instruction that has no successors.
// */
//Resume:
//	'resume' resumestruct=Structure resumevalue=Value;
//	/*
// * The 'unreachable' instruction has no defined semantics. This instruction is used to inform the 
// * optimizer that a particular portion of the code is not reachable. This can be used to indicate 
// * that the code after a no-return function cannot be reached, and other facts.
// */
//Unreachable:
//	{Unreachable} 'unreachable';
//
//	/*
// * The 'ret' instruction is used to return control flow (and optionally a value) 
// * from a function back to the caller.
// * 
// * There are two forms of the 'ret' instruction: one that returns a value and then 
// * causes control flow, and one that just causes control flow to occur.
// */
//Return:
//	{Return} 'ret' 'void' (',' '!dbg' '!' INT)? | 'ret' returntype=Type returnvalue=Value (',' '!dbg' '!' INT)?;
//
//	/*
// * The 'br' instruction is used to cause control flow to transfer to a different basic block in 
// * the current function. There are two forms of this instruction, corresponding to a conditional 
// * branch and an unconditional branch.
// */
//Branch:
//	'br' destinationtype=Type destination=Value | 'br' condtype=Type condvalue=Value ',' labelTruetype=Type labelTrue=Value
//	',' labelFalsetype=Type labelFalse=Value;
//
//	/*
// * This is to summarize the possible visibilities
// */
VISIBILITY:
	'default' | 'hidden' | 'protected';

	//	/*
// * This is to summarize the possible linkages
// */
LINKAGE:
	'private' | 'linker_private' | 'linker_private_weak' | 'available_externally' | 'linkonce' | 'common' | 'appending' |
	'extern_weak' | 'linkonce_odr' | 'linkonce_odr_auto_hide' | 'dllimport' | 'dllexport' | ALIAS_LINKAGE;
	//
//	/*
// * There are restriction on the Linkages of Aliasees. So...
// */
ALIAS_LINKAGE:
	'external' | 'internal' | 'weak' | 'weak_odr';
	//
//	/*
// * This rule is needed to support Metadata
// * Example:
// *  ; Named metadata
// *	!1 = metadata !{i32 42}
// *	!foo = !{!1, null} 
// *  !1 = metadata !{metadata !"omnipotent char", metadata !2}
// */
//MetadataValue:
//	(('!' INT) | ('!{' ID '}') | ('!' ID))
//	('='
//	(('!' INT) |
//	('!{' ID'}') |
//	('!' ID) |
//	'metadata' (('!' '{' | '!{') 'metadata' '!' STRING ',' ('metadata' '!' INT) '}')?))?;

//	/*
// * This rule is to define the alignment
// */
ALIGNMENT:
	'align' INT //must be a power of 2
;