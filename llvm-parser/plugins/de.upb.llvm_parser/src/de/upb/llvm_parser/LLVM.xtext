grammar de.upb.llvm_parser.LLVM with org.eclipse.xtext.common.Terminals

generate llvm "http://www.upb.de/llvm_parser/llvm"

/*
 * This Grammer is used to parse a llvm document.
 * The llvm project itself is located at http://llvm.org
 * For a language introduction see: http://llvm.org/docs/LangRef.html
 * A list of guides can be found on: http://llvm.org/docs/userguides.html
 */
LLVM:
	elements+=AbstractElement*;

/*
 * Integer defintion: iN(*)*
 * Examples:
 * 	i32  			- 32 bit Integer
 *  i1   			- Single bit Integer
 *  i32 (i32*) *	- A pointer to a function that takes an i32*, returning an i32.
 */
terminal INTEGER:
	'i' ('0'..'9')+ '*'*;
terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'0'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
			"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'0'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
		;
terminal CSTRING:
	'c'STRING
;
terminal OREST:
	'(...)' '*'*
;
terminal ARRAY:
	'['' '?('0'..'9')+' '?'x'' '?(INTEGER|F_POINT|VAR_TYPE)' '?']''*'*
;
/*
 * To distinguish the types here only Floating Types
 */
terminal F_POINT:
	'half' | 'float' | 'double' | 'x86_fp80' | 'fp128' | 'ppc_fp128';

/*
 * Comments are delimited with a ';' and go until the end of line.
 */
terminal SL_COMMENT:
	';' !('\n' | '\r')* ('\r'? '\n')?;

/*
 * Initial Variable Definition
 * Every Variable starts with either '%' for local or '@' for global
 * the regualar expression for this identifiers is [%@][a-zA-Z$._][a-zA-Z$._0-9]*
 * 
 * Examples:
 *  %foo
 *  (%Stack.Node).Node.a.very.long.identifier 
 *  @_44bar.your.choice
 */
terminal VAR_TYPE:
	(((('%' | '@')'.'*) (NOBRACKET | '(' NOBRACKET ')' | INT | STRING) '*'*) | '('+ (('%' | '@')'.'*) (NOBRACKET | '(' NOBRACKET ')' | '%'
	INT) '*'* ')'+ '*'*);

/*
 * Inner Identifier Rule (no Brackets allowed)
 */
terminal NOBRACKET:
	(('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* POINT?);
	
/*
 * This rule is responsible for the dot
 */
terminal POINT:
	'.' ((NOBRACKET) | '(' NOBRACKET ')');

/*
 * An Abstract Element is either a TopLevelEntity, used for the predefinitions of the llvm-code
 * or a MainLevelEntity, which are basically functiondefinitions. 
 */
AbstractElement:
	TopLevelEntity SL_COMMENT? |
	MainLevelEntity SL_COMMENT?;
	
/*
 * Predefinitions of the llcm-code
 */
TopLevelEntity:
	'module' 'asm' module=STRING |
	'target' ('datalayout' | 'triple') '=' target=STRING |
	'deplibs' '=' '[' libs+=STRING (',' libs+=STRING)* ']';

/*
 * This rule is used to devide the Function Definitions form the Variable Definitions.
 */
MainLevelEntity:
	FunctionHeader |
	NamedType
;

NamedType:
	(name=Type '=' (LINKAGE| 'global'|'unnamed_addr'|'constant')*(('type' (struct = Structure|Opaque)) | instr=Instruction | (ARRAY|struct=Structure) CSTRING ('zeroinitializer'|'null')* (','ALIGNMENT)? | alias=Alias | type=Type ('zeroinitializer'|'null')* (('0 ,'|'0,'|',')ALIGNMENT)?))
;
Type:
	VAR_TYPE|INT|INTEGER|Primitive
;
Structure:
	{Structure}'{' ((types+=Type|ARRAY)OREST? (Lists+=TypeList)? (',' (types+=Type|ARRAY)OREST? (Lists+=TypeList)?)*)? '}' |
	{Structure}'<' '{' ((types+=Type|ARRAY)OREST?(Lists+=TypeList)? (','(types+=Type|ARRAY)OREST?(Lists+=TypeList)?)*)? '}' '>'
;
/*
 * Aliases act as "second name" for the aliasee value (which can be either function, 
 * global variable, another alias or bitcast of global value). 
 * Aliases may have an optional linkage type, and an optional visibility style
 */
Alias:
	'alias' ALIAS_LINKAGE? VISIBILITY? aliastype=Type aliasvalue=Type aliasee=Type
;

Primitive:
	'void' | 'null' | 'label' | 'undef' | 'true' | 'false'
;

Opaque:
	'opaque'
;


/*
 * A Function Header has to be defined or declared.
 * If a function is declared, there will be no function body, and also the parameterlist needn't to be defined
 * Example: 
 *  declare i32 @__gxx_personality_v0(...)
 * If a function is defined, there are multiple optional parameters such as visibility or return attributes.
 * Example:
 *  define linkonce_odr void @_ZN4NodeC1Ev(%class.Node* %this) unnamed_addr align 2 { ... }
 */
FunctionHeader:
	'define' LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=(Type)
	name=VAR_TYPE pl=ParameterList 'unnamed_addr'? FUNCTION_ATTRIBUTES* ('section ' STRING)? ALIGNMENT?
	body=FunctionBody |
	'declare' LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=(Type)
	name=VAR_TYPE (tList=TypeList | OREST) 'unnamed_addr'? FUNCTION_ATTRIBUTES* ('section ' STRING)? ALIGNMENT?;

/*
 * This rule creates a Parameterlist and saves also the TypeAndValue to each parameter
 * Brackets are 
 */
ParameterList:
	{ParameterList}'('(types+=Type variables+=Type(','types+=Type variables+=Type)*)?')'
	
;

/* 
 * This rule is the start of the function body and has to be right after de 'define' of a function.
 * Every Functionbody contains at leaset one Basic Block. 
 */
FunctionBody:
	meta+=MetadataValue*
	'{' blocks+=BasicBlock+ '}'
	meta+=MetadataValue*
	;

/*
 * Every Basic Block is contained inside a Functionbody and has a label(eventually) and at least one instruction 
 */
BasicBlock:
	(label = NOBRACKET ':')?
	instructions+=(NamedType|Instruction)*
	terminator = Ret_Instr
;

Ret_Instr:
	Return |Branch| Switch|IndirectBranch|Invoke|Resume|Unreachable
;



/*
 * If a function is declared, the parameterlist has to be set empty or contain a List of Types.
 */
TypeList:
	{TypeList} '(' ((types+=Type (',' types+=Type)*))? ')''*'*;

/*
 * An Aggregate is a tuple of types enclosed by curly brackets
 */

/*
 * A Local Variable definition needs a name, followed by an equalsign and either an Instruction, an Alias or a Type  
 */


/*
 * This is only to summarize all possible Instructions
 */
Instruction:
	('volatile'? Load) | ('volatile'? Store) | Fence | GetElementPtr | LOGICAL_OP | ARITHMETIC_OP | Compare |
	Cast | ShuffleVector | InsertElement | ExtractElement   | InsertValue | ExtractValue | Alloc |
	CmpXchg | AtomicRMW | PHI | Select | Call | VA_Arg | LandingPad;


/*
 * This rule is used to bind a Type to a value.
 * It is used for example on parameterlists, on instructions etc.
 */
//TypeAndValue:
//	(type=(VAR_TYPE | B_TYPE)RETURN_ATTRIBUTES? value=Type) | aggregate=Aggregate value=Type;


/*
 * The 'getelementptr' instruction is used to get the address of a subelement of an aggregate data structure. 
 * It performs address calculation only and does not access memory.
 */
GetElementPtr:
	'getelementptr' 'inbounds'? elementtype=Type element=Type (',' indicetypes+=Type indices+=Type )*;

/*
 * The 'extractvalue' instruction extracts the value of a member field from an aggregate value.
 */
ExtractValue:
	'extractvalue' (array=ARRAY|struct=Structure) type=Type (',' index+=INT)+;

/*
 * The 'insertvalue' instruction inserts a value into a member field in an aggregate value.
 */
InsertValue:
	'insertvalue' struct=Structure value=Type ',' inserttype=Type insertvalue=Type (',' index+=INT)+;

/*
 * The 'fence' instruction is used to introduce happens-before edges between operations.
 */
Fence:
	'fence' 'singlethread'? ordering=ATOMIC_ORDERING;

/*
 * This is only a summarize of the possible atomic orderings
 */
ATOMIC_ORDERING:
	'unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst';

/*
 * The 'cmpxchg' instruction is used to atomically modify memory. It loads a value in memory and compares it to 
 * a given value. If they are equal, it stores a new value into the memory.
 */
CmpXchg:
	'cmpxchg' 'volatile'? adresstype=Type adress=Type ','comparetype=Type comparevalue=Type ',' newtype=Type newvalue=Type 'singlethread'?
	ordering=ATOMIC_ORDERING;

/*
 * The 'atomicrmw' instruction is used to atomically modify memory.
 */
AtomicRMW:
	'atomicrmw' 'volatile'? BIN_OP adresstype=Type adress=Type ',' optype=Type opvalue=Type 'singlethread'? ordering=ATOMIC_ORDERING;

/*
 * This is only to summarize the different Binary Operations
 */
BIN_OP:
	'xchg' | 'add' | 'sub' | 'and' | 'nand' | 'or' | 'xor' | 'max' | 'min' | 'umax' | 'umin';

/*
 * The 'load' instruction is used to read from memory.
 */
Load:
	'load' 'volatile'? adresstype=Type adress=Type (',' ((ALIGNMENT)|(MetadataValue)+))* |
	'load' 'atomic' 'volatile'? adresstype=Type adress=Type 'singlethread'? ordering=ATOMIC_ORDERING (',' 'align' index=INT)?;

/*
 * The 'store' instruction is used to write to memory.
 */
Store:
	'store'  'volatile'? newtype=Type newvalue=Type ',' adresstype=Type adress=Type (',' ((ALIGNMENT)|(MetadataValue)+))* |
	'store' 'atomic' 'volatile'? newtype=Type newvalue=Type ',' adresstype=Type adress=Type 'singlethread'? ordering=ATOMIC_ORDERING (','
	'align' index=INT)?;

/*
 * The 'call' instruction represents a simple function call.
 */
Call:
	'tail'? 'call' CallingConv? RETURN_ATTRIBUTES? adresstype=Type adress=Type pList=ParameterList FUNCTION_ATTRIBUTES*;

/*
 * This is to summarize the possible return attributes
 */
RETURN_ATTRIBUTES:
	'zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest';

Alloc:
	'alloca' type=Type (',' numelementstype=Type numelementsvalue=Type)? (',' ALIGNMENT)?;


/*
 * This is to summarize the possible Calling Conventions
 */
CallingConv:
	'ccc' | 'fastcc' | 'coldcc' | 'x86_stdcallcc' | 'x86_fastcallcc' | 'x86_thiscallcc' | 'arm_apcscc' |
	'arm_aapcscc' | 'arm_aapcs_vfpcc' | 'msp430_intrcc' | 'ptx_kernel' | 'ptx_device' | 'spir_func' | 'spir_kernel' |
	'cc' '<' INT '>' INT;

/*
 * This is to summarize the possible function attributes
 */
FUNCTION_ATTRIBUTES:
	'address_safety' | 'alignstack' '(' '<' INT '>' ')' | 'alwaysinline' | 'nonlazybind' | 'inlinehint' | 'naked' |
	'noimplicitfloat' |
	'noinline' |
	'noredzone' | 'noreturn' | 'nounwind' | 'optsize' | 'readnone' | 'readonly' | 'returns_twice' | 'ssp' | 'sspreq' |
	'uwtable';


/*
 * The 'phi' instruction is used to implement the φ node in the SSA graph representing the function.
 */
PHI:
	'phi' Type '[' values+=ValuePair ']' (',' '[' values+=ValuePair ']')*;

/*
 * This rule is used to bring in more clarity in some instructions
 */
ValuePair:
	value1=Type ',' value2=Type;

/*
 * The 'landingpad' instruction is used by LLVM's exception handling system to specify that a basic 
 * block is a landing pad — one where the exception lands, and corresponds to the code found in the 
 * catch portion of a try/catch sequence. It defines values supplied by the personality function (pers_fn)
 * upon re-entry to the function. The resultval has the type resultty.
 */
LandingPad:
	'landingpad' struct=Structure 'personality' personalitytype=Type personalityvalue=Type ('cleanup' clause+=Clause* | clause+=Clause+) |
	'landingpad' struct=Structure 'personality' personalitytype=Type personalityfunction=CAST_TYPE '(' value=Type OREST
	VAR_TYPE 'to' castto=Type ')' ('cleanup' clause+=Clause* | clause+=Clause+);

/*
 * A clause begins with the clause type — catch or filter — and contains the global variable representing
 * the "type" that may be caught or filtered respectively. Unlike the catch clause, the filter clause takes
 * an array constant as its argument. Use "[0 x i8**] undef" for a filter which cannot throw. The 'landingpad'
 * instruction must contain at least one clause or the cleanup flag.
 */
Clause:
	'catch' type=Type value=Type |
	'filter' filtertype+=Type filtervalue+=Type(',' filtertype+=Type filtervalue+=Type)*;

/*
 * The 'select' instruction is used to choose one value based on a condition, without branching.
 */
Select:
	'select' conditiontype=Type conditionvalue=Type',' val1type=Type val1value=Type',' val2type=Type val2value=Type;

/*
 * The 'va_arg' instruction is used to access arguments passed through the "variable argument" area of a 
 * function call. It is used to implement the va_arg macro in C.
 */
VA_Arg:
	'va_arg' listtype=Type listvalue=Type ',' argType=Type;

/*
 * The 'extractelement' instruction extracts a single scalar element from a vector at a specified index.
 */
ExtractElement:
	'extractelement' vectortype=Type vectorvalue=Type ',' indextype = Type index=Type;

/*
 * The 'insertelement' instruction inserts a scalar element into a vector at a specified index.
 */
InsertElement:
	'insertelement' vectortype=Type vectorvalue=Type ',' scalartype=Type scalarvalue =Type',' indextype = Type index=Type;

/*
 * The 'shufflevector' instruction constructs a permutation of elements from two input vectors, 
 * returning a vector with the same element type as the input and length that is the same as the shuffle mask.
 */
ShuffleVector:
	'shufflevector' val1type=Type val1value=Type',' val2type=Type val2value=Type ',' masktype=Type maskvalue=Type;

/*
 * This rule is to provide a typecast. Nothing special
 * Example
 *  %X = trunc i32 257 to i8
 *  %Z = fptosi float 1.04E+17 to i8
 */
Cast:
	CAST_TYPE castfrom=Type value=Type 'to' castto=Type;

/*
 * The instructions in this category are the conversion instructions (casting) which
 * all take a single operand and a type. They perform various bit conversions on the operand.
 */
CAST_TYPE:
	'trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' | 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'
	| 'bitcast';

/*
 * The 'icmp' instruction returns a boolean value or a vector of boolean values based on comparison of 
 * 		its two integer, integer vector, pointer, or pointer vector operands.
 * The 'fcmp' instruction returns a boolean value or vector of boolean values based on comparison of its operands.
 */
Compare:
	'icmp' I_PREDICATES comptype=Type value1=Type ',' value2=Type |
	'fcmp' F_PREDICATES comptype= Type value1=Type ',' value2=Type;

/*
 * This is to summarize the possible Integer Predicates
 */
I_PREDICATES:
	'eq' | 'ne' | 'ugt' | 'uge' | 'ult' | 'ule' | 'sgt' | 'sge' | 'slt' | 'sle';

/*
 * This is to summarize the possible Floating Predicates
 */
F_PREDICATES:
	'false' | 'oeq' | 'ogt' | 'oge' | 'olt' | 'ole' | 'one' | 'ord' |
	'ueq' | 'ugt' | 'uge' | 'ult' | 'ule' | 'une' | 'uno' | 'true';

/*
 * This is to summarize the possible Arithmetic Operations
 */
ARITHMETIC_OP:
	('add' | 'fadd' | 'sub' | 'fsub' | 'mul' | 'fmul' | 'udiv' | 'sdiv' | 'fdiv' | 'urem' | 'srem' | 'frem')
	optype=Type value1=Type ',' value2=Type;

/*
 * This is to summarize the possible Logical Operations
 */
LOGICAL_OP:
	('shl' | 'lshr' | 'ashr' | 'and' | 'or' | 'xor')optype=Type value1=Type ',' value2=Type;

/*
 * The 'indirectbr' instruction implements an indirect branch to a label within the current function, whose 
 * address is specified by "address". Address must be derived from a blockaddress constant.
 */
IndirectBranch:
	'indirectbr' adresstype=Type adress=Type ',' '[' (lList=LabelList)? ']';

/*
 * The Indirect Branch instruction needs a List of labels to jump to. 
 * This List is created here an contains Pairs of Types and Values
 */
LabelList:
	(labeltype+=Type labels+=Type)+;

/*
 * The 'switch' instruction is used to transfer control flow to one of several different places. It is a generalization of 
 * the 'br' instruction, allowing a branch to occur to one of many possible destinations.
 */
Switch:
	'switch' comptype=Type compvalue=Type ',' defaulttype=Type defaultvalue=Type '[' (jTable=JumpTable)? ']';

/*
 * The Switch instruction needs a list of values and destination, that will be jumped in case of value occures
 */
JumpTable:
	(jtypes+=Type jvalues+=Type ',' destinationtypes+=Type destinations+=Type)+;

/*
 * The 'invoke' instruction causes control to transfer to a specified function, with the possibility of 
 * control flow transfer to either the 'normal' label or the 'exception' label. If the callee function 
 * returns with the "ret" instruction, control flow will return to the "normal" label. If the callee 
 * (or any indirect callees) returns via the "resume" instruction or other exception handling mechanism, 
 * control is interrupted and continued at the dynamically nearest "exception" label.
 * 
 * The 'exception' label is a landing pad for the exception. As such, 'exception' label is required to
 *  have the "landingpad" instruction, which contains the information about the behavior of the program 
 * after unwinding happens, as its first non-PHI instruction. The restrictions on the "landingpad" 
 * instruction's tightly couples it to the "invoke" instruction, so that the important information contained 
 * within the "landingpad" instruction can't be lost through normal code motion.
 */
Invoke:
	'invoke' CallingConv? RETURN_ATTRIBUTES? functiontype=Type functionvalue=Type pList=ParameterList FUNCTION_ATTRIBUTES* 'to'
	totype=Type tovalue=Type 'unwind' unwindtype=Type unwindvalue=Type;
	
/*
 * The 'resume' instruction is a terminator instruction that has no successors.
 */
Resume:
	'resume' resumestruct=Structure resumevalue=Type;
/*
 * The 'unreachable' instruction has no defined semantics. This instruction is used to inform the 
 * optimizer that a particular portion of the code is not reachable. This can be used to indicate 
 * that the code after a no-return function cannot be reached, and other facts.
 */
Unreachable:
	{Unreachable}'unreachable'
;

/*
 * The 'ret' instruction is used to return control flow (and optionally a value) 
 * from a function back to the caller.
 * 
 * There are two forms of the 'ret' instruction: one that returns a value and then 
 * causes control flow, and one that just causes control flow to occur.
 */
Return:
	{Return} 'ret' 'void' (',' '!dbg' '!' INT)? | 'ret' returntype=Type returnvalue=Type (',' '!dbg' '!' INT)?;

/*
 * The 'br' instruction is used to cause control flow to transfer to a different basic block in 
 * the current function. There are two forms of this instruction, corresponding to a conditional 
 * branch and an unconditional branch.
 */
Branch:
	'br' destinationtype=Type destination=Type | 'br' condtype=Type condvalue=Type ',' labelTruetype=Type labelTrue=Type ',' labelFalsetype=Type labelFalse=Type;

/*
 * This is to summarize the possible visibilities
 */
VISIBILITY:
	'default' | 'hidden' | 'protected';

/*
 * This is to summarize the possible linkages
 */
LINKAGE:
	'private' | 'linker_private' | 'linker_private_weak' | 'available_externally' | 'linkonce' | 'common' |
	'appending' | 'extern_weak' | 'linkonce_odr' | 'linkonce_odr_auto_hide' | 'dllimport' | 'dllexport' | ALIAS_LINKAGE;

/*
 * There are restriction on the Linkages of Aliasees. So...
 */
ALIAS_LINKAGE:
	'external' | 'internal' | 'weak' | 'weak_odr';

/*
 * This rule is needed to support Metadata
 * Example:
 *  ; Named metadata
 *	!1 = metadata !{i32 42}
 *	!foo = !{!1, null} 
 *  !1 = metadata !{metadata !"omnipotent char", metadata !2}
 */
MetadataValue:
	(('!' INT )| ('!{' NOBRACKET '}') | ("!" NOBRACKET)) 
	('=' 
		(('!' INT) | 
		 ('!{' NOBRACKET '}') |
		 ("!" NOBRACKET) |
		 'metadata'(('!''{'|'!{')'metadata''!'STRING','('metadata''!'INT)'}')?
		)
	)?;

/*
 * This rule is to define the alignment
 */
ALIGNMENT:
	'align' INT //must be a power of 2
;