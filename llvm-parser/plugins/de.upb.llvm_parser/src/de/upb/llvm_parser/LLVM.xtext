grammar de.upb.llvm_parser.LLVM with org.eclipse.xtext.common.Terminals

generate llvm "http://www.upb.de/llvm_parser/llvm"

LLVM:
	elements+=AbstractElement*;
	//[%@][a-zA-Z$._][a-zA-Z$._0-9]*
terminal INTEGER:
	'i' ('0'..'9')+ '*'*;

terminal SL_COMMENT:
	';' !('\n' | '\r')* ('\r'? '\n')?;

terminal VAR_TYPE:
	((('%' | '@') (NOBRACKET | '(' NOBRACKET ')' | INT) '*'*) | '('+ ('%' | '@') (NOBRACKET | '(' NOBRACKET ')' | '%'
	INT) '*'* ')'+ '*'*);

terminal NOBRACKET:
	(('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* POINT?);

terminal POINT:
	'.' ((NOBRACKET) | '(' NOBRACKET ')');
	//	('%'|'@')NOBRACE | '('VAR_TYPE')'
//;
//terminal NEXTVAR:
//	BRACE | NOBRACE
//;
//terminal NOBRACE:
//	(('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*(POINT|'*'+)?)|INT
//;
//terminal BRACE:
//	'(' NEXTVAR ')' ('*'+| POINT)?
//;
//terminal POINT:
//	'.'NEXTVAR
//;
AbstractElement:
	TopLevelEntity SL_COMMENT? |
	MainLevelEntity SL_COMMENT?;

TopLevelEntity:
	'module' 'asm' module=STRING |
	'target' ('datalayout' | 'triple') '=' target=STRING |
	'deplibs' '=' '[' libs+=STRING (',' libs+=STRING)* ']';

MainLevelEntity:
	FunctionHeader |
	LocalVar;

FunctionHeader:
	'define' LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=(Type)
	name=VAR_TYPE pList=ParameterList 'unnamed_addr'? FUNCTION_ATTRIBUTES? ('section ' STRING)? ALIGNMENT?
	body=FunctionBody |
	'declare' LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=(Type)
	name=VAR_TYPE (tList=TypeList|'(...)') 'unnamed_addr'? FUNCTION_ATTRIBUTES? ('section ' STRING)? ALIGNMENT?;

TypeList:
	{TypeList} '(' (types+=Type(',' types+=Type)*)? ')';


Aggregate:
	'{' agg+=Type (',' agg+=Type) '}';

LocalVar:
	name=Type '=' (type=LocalType | instr=LocalInstruction | alias=LocalAlias);

LocalType:
	'type' type=Type;

LocalInstruction:
	instr=Instruction;

LocalAlias:
	'alias' ALIAS_LINKAGE? VISIBILITY? type=TypeAndValue aliasee=Type;

Type:
	(StructType | VAR_TYPE | BType);

TypeAndValue:
	(type=(VAR_TYPE | BType) value=Type) | aggregate=Aggregate value=Type;

StructType:
	'{' ((VAR_TYPE | BType) (',' (VAR_TYPE | BType))*)? '}' |
	'<' '{' ((VAR_TYPE | BType) (',' (VAR_TYPE | BType))*)? '}' '>';

BType:
	INTEGER | F_POINT | BasicType | INT;

BasicType:
	'void' | 'null' | 'label' | 'undef';

F_POINT:
	'half' | 'float' | 'double' | 'x86_fp80' | 'fp128' | 'ppc_fp128';

GetElementPtr:
	'getelementptr' 'inbounds'? pointer+=TypeAndValue (',' params+=TypeAndValue)*;

ExtractValue:
	'extractvalue' aggregate=Aggregate type=Type (',' index+=INT)+;

InsertValue:
	'insertvalue' aggregate=Aggregate type=Type ',' value=TypeAndValue (',' index+=INT)+;

Fence:
	'fence' 'singlethread'? ordering=ATOMIC_ORDERING;

ATOMIC_ORDERING:
	'unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst';

CmpXchg:
	'cmpxchg' 'volatile'? adress=TypeAndValue ',' compare_val=TypeAndValue ',' new_val=TypeAndValue 'singlethread'?
	ordering=ATOMIC_ORDERING;

AtomicRMW:
	'atomicrmw' 'volatile'? BIN_OP adress=TypeAndValue ',' value=TypeAndValue 'singlethread'? ordering=ATOMIC_ORDERING;

BIN_OP:
	'xchg' | 'add' | 'sub' | 'and' | 'nand' | 'or' | 'xor' | 'max' | 'min' | 'umax' | 'umin';

Load:
	'load' 'volatile'? adress=TypeAndValue (',' align=ALIGNMENT)? (',' '!nontemporal' '!' index=INT)? |
	'load' 'atomic' 'volatile'? adress=TypeAndValue 'singlethread'? ordering=ATOMIC_ORDERING (',' 'align' index=INT)?;

Store:
	'store' 'volatile'? value=TypeAndValue ',' adress=TypeAndValue (',' 'align' INT)? |
	'store' 'atomic' 'volatile'? value=TypeAndValue ',' adress=TypeAndValue 'singlethread'? ordering=ATOMIC_ORDERING (','
	'align' index=INT)?;

Call:
	'tail'? 'call' CallingConv? RETURN_ATTRIBUTES? pointer=TypeAndValue plist=ParameterList FUNCTION_ATTRIBUTES?;

RETURN_ATTRIBUTES:
	'zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest';

Alloc:
	'alloca' type=Type (',' numElements=TypeAndValue)? (',' ALIGNMENT)?;

CallingConv:
	'ccc' | 'fastcc' | 'coldcc' | 'x86_stdcallcc' | 'x86_fastcallcc' | 'x86_thiscallcc' | 'arm_apcscc' |
	'arm_aapcscc' | 'arm_aapcs_vfpcc' | 'msp430_intrcc' | 'ptx_kernel' | 'ptx_device' | 'spir_func' | 'spir_kernel' |
	'cc' '<' INT '>' INT;

FUNCTION_ATTRIBUTES:
	'address_safety' | 'alignstack' '(' '<' INT '>' ')' | 'alwaysinline' | 'nonlazybind' | 'inlinehint' | 'naked' |
	'noimplicitfloat' |
	'noinline' |
	'noredzone' | 'noreturn' | 'nounwind' | 'optsize' | 'readnone' | 'readonly' | 'returns_twice' | 'ssp' | 'sspreq' |
	'uwtable';

ParameterList:
	{ParameterList} '(' (params+=TypeAndValue (',' params+=TypeAndValue)*)? ')';

PHI:
	'phi' Type '[' values+=ValuePair ']' (',' '[' values+=ValuePair ']')*;

ValuePair:
	value1=Type ',' value2=Type;

LandingPad:
	'landingpad' type=Type 'personality' personality=TypeAndValue ('cleanup' clause+=Clause* | clause+=Clause+) |
	'landingpad' type=Type 'personality' personalitytype=Type personalityfunction=CAST_TYPE '(' value=Type '(...)*'
	VAR_TYPE 'to' castto=Type ')' ('cleanup' clause+=Clause* | clause+=Clause+);

Clause:
	'catch' TypeAndValue |
	'filter' filter+=TypeAndValue (',' filter+=TypeAndValue)*;

Select:
	'select' condition=TypeAndValue ',' val1=TypeAndValue ',' val2=TypeAndValue;

VA_Arg:
	'va_arg' list=TypeAndValue ',' argType=Type;

ExtractElement:
	'extractelement' vector=TypeAndValue ',' index=TypeAndValue;

InsertElement:
	'insertelement' vector=TypeAndValue ',' scalar=TypeAndValue ',' index=TypeAndValue;

ShuffleVector:
	'shufflevector' vector1=TypeAndValue ',' vector2=TypeAndValue ',' mask=TypeAndValue;

Cast:
	CAST_TYPE value=TypeAndValue 'to' castto=Type;

CAST_TYPE:
	'trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' | 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'
	| 'bitcast';

Compare:
	'icmp' I_PREDICATES Type ValuePair |
	'fcmp' F_PREDICATES Type ValuePair;

I_PREDICATES:
	'eq' | 'ne' | 'ugt' | 'uge' | 'ult' | 'ule' | 'sgt' | 'sge' | 'slt' | 'sle';

F_PREDICATES:
	'false' | 'oeq' | 'ogt' | 'oge' | 'olt' | 'ole' | 'one' | 'ord' |
	'ueq' | 'ugt' | 'uge' | 'ult' | 'ule' | 'une' | 'uno' | 'true';

ARITHMETIC_OP:
	'add' | 'fadd' | 'sub' | 'fsub' | 'mul' | 'fmul' | 'udiv' | 'sdiv' | 'fdiv' | 'urem' | 'srem' | 'frem';

LOGICAL_OP:
	'shl' | 'lshr' | 'ashr' | 'and' | 'or' | 'xor';

Arithmetic:
	ARITHMETIC_OP Type ValuePair;

Logical:
	LOGICAL_OP Type ValuePair;

Instruction:
	Switch | IndirectBranch | Branch | Return | Load | Store | Fence | GetElementPtr | Logical | Arithmetic | Compare |
	Cast | ShuffleVector | InsertElement | ExtractElement | Invoke | Resume | InsertValue | ExtractValue | Alloc |
	CmpXchg | AtomicRMW | PHI | Select | Call | VA_Arg | LandingPad | LocalVar;

IndirectBranch:
	'indirectbr' adress=TypeAndValue ',' '[' (lList=LabelList)? ']';

LabelList:
	(labels+=TypeAndValue)+;

Switch:
	'switch' value=TypeAndValue ',' default=TypeAndValue '[' (jTable=JumpTable)? ']';

JumpTable:
	(values+=TypeAndValue ',' destinations+=TypeAndValue)+;

Invoke:
	'invoke' CallingConv? RETURN_ATTRIBUTES? function=TypeAndValue pList=ParameterList FUNCTION_ATTRIBUTES? 'to'
	to=TypeAndValue 'unwind' unwind=TypeAndValue;

Resume:
	'resume' TypeAndValue;

Return:
	{Return} 'ret' 'void' (',' '!dbg' '!' INT)? | 'ret' value=TypeAndValue (',' '!dbg' '!' INT)?;

Branch:
	'br' destination=TypeAndValue | 'br' cond=TypeAndValue ',' labelTrue=TypeAndValue ',' labelFalse=TypeAndValue;

FunctionBody:
	'{' blocks+=BasicBlock+ '}';

BasicBlock:
	label=NOBRACKET ':'
	instructions+=Instruction*;

VISIBILITY:
	'default' | 'hidden' | 'protected';

LINKAGE:
	'private' | 'linker_private' | 'linker_private_weak' | 'available_externally' | 'linkonce' | 'common' |
	'appending' | 'extern_weak' | 'linkonce_odr' | 'linkonce_odr_auto_hide' | 'dllimport' | 'dllexport' | ALIAS_LINKAGE;

ALIAS_LINKAGE:
	'external' | 'internal' | 'weak' | 'weak_odr';

MetadataValue:
	'!' INT | '!{' STRING '}' | "!" STRING;

ALIGNMENT:
	'align' INT //must be a power of 2
;