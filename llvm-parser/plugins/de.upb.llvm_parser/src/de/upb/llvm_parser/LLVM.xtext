grammar de.upb.llvm_parser.LLVM with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate llvm "http://www.upb.de/llvm_parser/llvm"

LLVM:
	elements+=AbstractElement*;

terminal INT returns ecore::EInt:
	'-'? ('0'..'9')+;

terminal VALID_ID:
	((('%' | '@') '.'*
		(
			(('a'..'z' | 'A'..'Z' | '_' | '0'..'9')+) | STRING
		)
	) | ('(' VALID_ID POINTER? ')'))
	
	('.'
		(
			( ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')+) |('(' ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')+ POINTER? ')')
		)
	)*;

terminal INT_TYPE:
	'i' ('0'..'9')+ POINTER?;

terminal STRING:
	'c'?'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '0' | '"' | "'" | '\\') | !('\\' | '"'))* '"' |
	'c'?"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '0' | '"' | "'" | '\\') | !('\\' | "'"))* "'";

terminal OREST:
	'(...)' POINTER?;

terminal SL_COMMENT:
	';' !('\n' | '\r')* ('\r'? '\n')?;

terminal POINTER:
	'*'+;

ID_FQN:
	(INT_TYPE|ID | 'catch' | 'invoke' | 'resume' | 'switch' | 'true' | 'false') ('.' (INT_TYPE|ID | 'catch' | 'invoke' | 'resume' | 'switch' | 'true' | 'false'))*;

AbstractElement:
	TopLevelEntity SL_COMMENT? |
	MainLevelEntity SL_COMMENT?;

TopLevelEntity:
	'module' 'asm' module=STRING |
	'target' ('datalayout' | 'triple') '=' target=STRING |
	'deplibs' '=' '[' libs+=STRING (',' libs+=STRING)* ']';

	/*
 * This rule is used to devide the Function Definitions form the Variable Definitions.
 */
MainLevelEntity:
	TypeDefinition
	| GlobalDefinition
	| FunctionDefinition
	| AliasDefinition
	| meta += MetadataValue;

TypeDefinition:
	(address=Address '=' (('type' (struct=Structure | Opaque))));

GlobalDefinition:
	adress=Address '=' (LINKAGE | 'global' | 'unnamed_addr' | 'constant')* type = (TypeUse|Aggregate_Types) value=(ValueStruct|Value)?
	(',' ALIGNMENT)?;

FunctionDefinition:
	('define' LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=(TypeUse)
	address=Address pl=ParameterList 'unnamed_addr'? FUNCTION_ATTRIBUTES* ('section ' STRING)? ALIGNMENT?
	body=FunctionBody) | 
	('declare' LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=(TypeUse)
	address=Address (tList=TypeList | OREST) 'unnamed_addr'? FUNCTION_ATTRIBUTES* ('section ' STRING)? ALIGNMENT?);

AliasDefinition:
	address=Address '=' 'alias' ALIAS_LINKAGE? VISIBILITY? aliastype=TypeUse aliasvalue=Value aliasee=(TypeUse);

TypeUse:
	(Predefined | AddressUse) ('()*')? OREST?;

AddressUse:
	address=[Address|VALID_ID] (pointer=POINTER)?;

Address:
	name=VALID_ID;

Predefined:
	type=PredefinedType (pointer=POINTER)?;

PrimitiveType:
	'void' | 'null' | 'label' | 'undef' | 'true' | 'false';

Initializers:
	'zeroinitializer';

FloatingPoint_Type:
	'half' | 'float' | 'double' | 'x86_fp80' | 'fp128' | 'ppc_fp128';

PredefinedType:
	PrimitiveType | INT_TYPE | FloatingPoint_Type;

Vector:
	'<' INT 'x' type=TypeUse '>';

Array:
	{Array} ('[' INT 'x' type=TypeUse ']' | '[]' | '[' ']') POINTER?;

Aggregate_Types:
	Structure | Array | Vector;

Constant:
	value=INT;

NonConstantValue:
	name=VALID_ID (pointer=POINTER)?;

Value:
	{Value} name= (STRING| PrimitiveType | Initializers) | Cast | NestedGetElementPtr | Constant | NonConstantValue;

ValueStruct:
	'{' types+=TypeUse value+=Value (',' types+=TypeUse value+=Value)* '}';

Structure:
	{Structure} '{' (types+=TypeUse (',' types+=(TypeUse|Aggregate_Types))*)? '}' POINTER?;

Opaque:
	'opaque';

ParameterList:
	{ParameterList} (('()')|('('
	(types+=TypeUse (Lists+=TypeList)? RETURN_ATTRIBUTES* variables+=Value
	(',' types+=TypeUse (Lists+=TypeList)? RETURN_ATTRIBUTES* variables+=Value)*)?
	')'));

TypeList:
	{TypeList} ('()' | ('(' (types+=TypeUse (typelists+=TypeList)? RETURN_ATTRIBUTES? (',' types+=TypeUse
	(typelists+=TypeList)? RETURN_ATTRIBUTES?)*)? (')' | ')*' | ')**' | ')***' | ')****' | ')*****')));

FunctionBody:
	meta+=MetadataValue*
	'{' blocks+=BasicBlock+ '}'
	;
Instruction:
	StandartInstruction | ReturnInstruction
;
BasicBlock:
	(label=ID_FQN ':')
	instructions+=(InstructionUse | StandartInstruction)*
	(retadr=VALID_ID '=')? terminator=ReturnInstruction;

InstructionUse:
	reg_or_var=VALID_ID '=' instruction=StandartInstruction;

ReturnInstruction:
	Return | Branch | Switch | IndirectBranch | Invoke | Resume | Unreachable;

StandartInstruction:
	('volatile'? Load) | ('volatile'? Store) | Fence | GetElementPtr | LogicOperation | ArithmeticOperation | Compare |
	Cast | ShuffleVector | InsertElement | ExtractElement | InsertValue | ExtractValue | Alloc |
	CmpXchg | AtomicRMW | Phi | Select | Call | VariableAttributeAccess | LandingPad;

ArithmeticOperation:
	operation = ('add' | 'fadd' | 'sub' | 'fsub' | 'mul' | 'fmul' | 'udiv' | 'sdiv' | 'fdiv' | 'urem' | 'srem' | 'frem') (('nsw' |
	'nuw') ('nuw' | 'nsw')?)?
	optype=TypeUse value1=Value ',' value2=Value;

LogicOperation:
	operation = ('shl' | 'lshr' | 'ashr' | 'and' | 'or' | 'xor') optype=TypeUse value1=Value ',' value2=Value;

Cast:
	operation = Cast_OP (('(' from=(TypeUse|Aggregate_Types) value=Value 'to' to=TypeUse ')') | (from=(TypeUse|Aggregate_Types) value=Value 'to' to=TypeUse));

MetadataValue:
	(('!' INT) | ('!{' ID_FQN '}') | ('!' ID_FQN))
	('='
	(('!' INT) |
	('!{' ID_FQN '}') |
	('!' ID_FQN) |
	'metadata' (('!' '{' | '!{') (('metadata' '!' STRING (',' (('metadata' '!' INT)|'null'))?)|(INT_TYPE INT ',' INT_TYPE INT)) '}')?))?;

ALIGNMENT:
	'align' INT //must be a power of 2
;

GetElementPtr:
	'getelementptr' 'inbounds'? 
		(aggregate=(TypeUse|Array) aggregatename=Value(',' indTypes+=TypeUse indizies+=Value)*)
;
NestedGetElementPtr:
	'getelementptr' 'inbounds'? 
		('('aggregate=(TypeUse|Array) aggregatename=Value(',' indTypes+=TypeUse indizies+=Value)*')')
;
	
ExtractValue:
	'extractvalue' (array=Array | struct=Structure) value=Value (',' index+=INT)+;

InsertValue:
	'insertvalue' struct=Structure value=Value ',' inserttype=TypeUse insertvalue=Value (',' index+=INT)+;

Fence:
	'fence' 'singlethread'? ordering=ATOMIC_ORDERING;

CmpXchg:
	'cmpxchg' 'volatile'? adresstype=TypeUse adress=Value ',' comparetype=TypeUse comparevalue=Value ',' newtype=TypeUse
	newvalue=Value 'singlethread'?
	ordering=ATOMIC_ORDERING;

AtomicRMW:
	'atomicrmw' 'volatile'? operation = BIN_OP adresstype=TypeUse adress=Value ',' optype=TypeUse opvalue=Value 'singlethread'?
	ordering=ATOMIC_ORDERING;

Load:
	'load' 'volatile'? adresstype=TypeUse (types=TypeList)? adress=Value (',' ((ALIGNMENT) | (MetadataValue)+))* |
	'load' 'atomic' 'volatile'? adresstype=TypeUse adress=Value (types=TypeList)? 'singlethread'?
	ordering=ATOMIC_ORDERING (',' 'align'
	index=INT)?;

Store:
	'store' 'volatile'? newtype=(TypeUse) (types+=TypeList)? (newvalue=Value) ','
	adresstype=TypeUse (types+=TypeList)? adress=Value (',' ((ALIGNMENT) |
	(MetadataValue)+))* 
	|
	'store' 'atomic' 'volatile'? newtype=TypeUse (types+=TypeList)? newvalue=Value ',' adresstype=TypeUse
	(types+=TypeList)? adress=Value 'singlethread'?
	ordering=ATOMIC_ORDERING (','
	'align' index=INT)?;

Call:
	'tail'? 'call' CallingConv? RETURN_ATTRIBUTES? adresstype=TypeUse ((adress=Value) | 'asm' 'sideeffect'? STRING ','
	STRING) pList=ParameterList FUNCTION_ATTRIBUTES* (',' '!srcloc' '!' INT)*;

Alloc:
	'alloca' ((type=TypeUse typelist=TypeList?)) (',' numelementstype=TypeUse numelementsvalue=Value)? (',' ALIGNMENT)?;

Phi:
	'phi' type=TypeUse '[' firstclass+=Value ',' values+=Value ']' (',' '[' firstclass+=Value ',' values+=Value ']')*;

LandingPad:
	'landingpad' struct=Structure 'personality' personalitytype=TypeUse
	personalityvalue=Value ('cleanup' clause+=Clause* | clause+=Clause+);

Clause:
	'catch' type=TypeUse value=Value |
	'filter' filterarray=Array (constant=Value);

Select:
	'select' conditiontype=TypeUse conditionvalue=Value ',' val1type=TypeUse val1value=Value ',' val2type=TypeUse
	val2value=Value;

VariableAttributeAccess:
	'va_arg' listtype=TypeUse listvalue=Value ',' argType=TypeUse;

ExtractElement:
	'extractelement' vectortype=TypeUse vectorvalue=Value ',' indextype=TypeUse index=Value;

InsertElement:
	'insertelement' vectortype=TypeUse vectorvalue=Value ',' scalartype=TypeUse scalarvalue=Value ',' indextype=TypeUse
	index=Value;

ShuffleVector:
	'shufflevector' val1type=TypeUse val1value=Value ',' val2type=TypeUse val2value=Value ',' masktype=TypeUse
	maskvalue=Value;

Compare:
	'icmp' pred = I_PREDICATES comptype=TypeUse value1=Value ',' value2=Value |
	'fcmp' pred = F_PREDICATES comptype=TypeUse value1=Value ',' value2=Value;

IndirectBranch:
	'indirectbr' adresstype=TypeUse adress=Value ',' '[' (labeltype+=TypeUse labels+=Value (',' labeltype+=TypeUse labels+=Value)*)? ']';

Switch:
	'switch' comptype=TypeUse compvalue=Value ',' defaulttype=TypeUse defaultvalue=Value '[' (jtypes+=TypeUse jvalues+=Value ',' destinationtypes+=TypeUse destinations+=Value)+ ']';

Invoke:
	'invoke' CallingConv? RETURN_ATTRIBUTES? functiontype=TypeUse name=Address pList=ParameterList
	FUNCTION_ATTRIBUTES* 'to'
	totype=TypeUse tovalue=Value 'unwind' unwindtype=TypeUse unwindvalue=Value;

Resume:
	'resume' resumestruct=Structure resumevalue=Value;

Unreachable:
	{Unreachable} 'unreachable';

Return:
	{Return} 'ret' 'void' (',' '!dbg' '!' INT)? | 'ret' returntype=TypeUse returnvalue=Value (',' '!dbg' '!' INT)?;

Branch:
	('br' 'label' destination=Value) | 
	('br' INT_TYPE condvalue=Value ',' labelTruetype=TypeUse	labelTrue=Value	',' labelFalsetype=TypeUse labelFalse=Value);

ATOMIC_ORDERING:
	'unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst';

BIN_OP:
	('xchg' | 'add' | 'sub' | 'and' | 'nand' | 'or' | 'xor' | 'max' | 'min' | 'umax' | 'umin');

RETURN_ATTRIBUTES:
	'zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest';

CallingConv:
	'ccc' | 'fastcc' | 'coldcc' | 'x86_stdcallcc' | 'x86_fastcallcc' | 'x86_thiscallcc' | 'arm_apcscc' | 'arm_aapcscc' |
	'arm_aapcs_vfpcc' | 'msp430_intrcc' | 'ptx_kernel' | 'ptx_device' | 'spir_func' | 'spir_kernel' | 'cc' '<' INT '>'
	INT;

FUNCTION_ATTRIBUTES:
	'address_safety' | 'alignstack' '(' '<' INT '>' ')' | 'alwaysinline' | 'nonlazybind' | 'inlinehint' | 'naked' |
	'noimplicitfloat' | 'noinline' | 'noredzone' | 'noreturn' | 'nounwind' | 'optsize' | 'readnone' | 'readonly' |
	'returns_twice' | 'ssp' | 'sspreq' | 'uwtable';

Cast_OP:
	'trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' | 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'
	| 'bitcast';

I_PREDICATES:
	'eq' | 'ne' | 'ugt' | 'uge' | 'ult' | 'ule' | 'sgt' | 'sge' | 'slt' | 'sle';

F_PREDICATES:
	'false' | 'oeq' | 'ogt' | 'oge' | 'olt' | 'ole' | 'one' | 'ord' |
	'ueq' | 'ugt' | 'uge' | 'ult' | 'ule' | 'une' | 'uno' | 'true';

VISIBILITY:
	'default' | 'hidden' | 'protected';

LINKAGE:
	'private' | 'linker_private' | 'linker_private_weak' | 'available_externally' | 'linkonce' | 'common' | 'appending' |
	'extern_weak' | 'linkonce_odr' | 'linkonce_odr_auto_hide' | 'dllimport' | 'dllexport' | ALIAS_LINKAGE;

ALIAS_LINKAGE:
	'external' | 'internal' | 'weak' | 'weak_odr';