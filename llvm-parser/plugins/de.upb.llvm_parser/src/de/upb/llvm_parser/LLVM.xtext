grammar de.upb.llvm_parser.LLVM with org.eclipse.xtext.common.Terminals

generate llvm "http://www.upb.de/llvm_parser/llvm"

LLVM:
	elements+=AbstractElement*;
/*
 * Integer defintion: iN(*)*
 * Examples:
 * 	i32  			- 32 bit Integer
 *  i1   			- Single bit Integer
 *  i32 (i32*) *	- A pointer to a function that takes an i32*, returning an i32.
 */
terminal INTEGER:
	'i' ('0'..'9')+ '*'*;

/*
 * Comments are delimited with a ';' and go until the end of line.
 */
terminal SL_COMMENT:
	';' !('\n' | '\r')* ('\r'? '\n')?;

/*
 * Initial Variable Definition
 * Every Variable starts with either '%' for local or '@' for global
 * the regualar expression for this identifiers is [%@][a-zA-Z$._][a-zA-Z$._0-9]*
 * 
 * Examples:
 *  %foo
 *  (%Stack.Node).Node.a.very.long.identifier 
 *  @_44bar.your.choice
 */
terminal VAR_TYPE:
	((('%' | '@') (NOBRACKET | '(' NOBRACKET ')' | INT) '*'*) | '('+ ('%' | '@') (NOBRACKET | '(' NOBRACKET ')' | '%'
	INT) '*'* ')'+ '*'*);

/*
 * Inner Identifier Rule (no Brackets allowed)
 */
terminal NOBRACKET:
	(('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* POINT?);
	
/*
 * This rule is responsible for the dot
 */
terminal POINT:
	'.' ((NOBRACKET) | '(' NOBRACKET ')');

/*
 * An Abstract Element is either a TopLevelEntity, used for the predefinitions of the llvm-code
 * or a MainLevelEntity, which are basically functiondefinitions. 
 */
AbstractElement:
	TopLevelEntity SL_COMMENT? |
	MainLevelEntity SL_COMMENT?;
	
/*
 * Predefinitions of the llcm-code
 */
TopLevelEntity:
	'module' 'asm' module=STRING |
	'target' ('datalayout' | 'triple') '=' target=STRING |
	'deplibs' '=' '[' libs+=STRING (',' libs+=STRING)* ']';

/*
 * This rule is used to devide the Function Definitions form the Variable Definitions.
 */
MainLevelEntity:
	FunctionHeader |
	LocalVar;

/*
 * A Function Header has to be defined or declared.
 * If a function is declared, there will be no function body, and also the parameterlist needn't to be defined
 * Example: 
 *  declare i32 @__gxx_personality_v0(...)
 * If a function is defined, there are multiple optional parameters such as visibility or return attributes.
 * Example:
 *  define linkonce_odr void @_ZN4NodeC1Ev(%class.Node* %this) unnamed_addr align 2 { ... }
 */
FunctionHeader:
	'define' LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=(Type)
	name=VAR_TYPE pList=ParameterList 'unnamed_addr'? FUNCTION_ATTRIBUTES? ('section ' STRING)? ALIGNMENT?
	body=FunctionBody |
	'declare' LINKAGE? VISIBILITY? CallingConv? RETURN_ATTRIBUTES? returnType=(Type)
	name=VAR_TYPE (tList=TypeList | '(...)') 'unnamed_addr'? FUNCTION_ATTRIBUTES? ('section ' STRING)? ALIGNMENT?;

/*
 * If a function is declared, the parameterlist has to be set empty or contain a List of Types.
 */
TypeList:
	{TypeList} '(' (types+=Type (',' types+=Type)*)? ')';

/*
 * An Aggregate is a tuple of types enclosed by curly brackets
 */
Aggregate:
	'{' agg+=Type (',' agg+=Type) '}';

/*
 * A Local Variable definition needs a name, followed by an equalsign and either an Instruction, an Alias or a Type  
 */
LocalVar:
	name=Type '=' ('type' type=Type | instr=Instruction | alias=Alias);


/*
 * Aliases act as "second name" for the aliasee value (which can be either function, 
 * global variable, another alias or bitcast of global value). 
 * Aliases may have an optional linkage type, and an optional visibility style
 */
Alias:
	'alias' ALIAS_LINKAGE? VISIBILITY? type=TypeAndValue aliasee=Type;

/*
 * Types..
 * A Type is a type.
 * There are different types. Primitive Types, Struct Types, or own VaraiableTypes.
 * This rule is used to summarize them
 */
Type:
	(StructType | VAR_TYPE | BType);

/*
 * This rule is used to bind a Type to a value.
 * It is used for example on parameterlists, on instructions etc.
 */
TypeAndValue:
	(type=(VAR_TYPE | BType) value=Type) | aggregate=Aggregate value=Type;

/*
 * This rule specified Stuctures
 */
StructType:
	'{' ((VAR_TYPE | BType) (',' (VAR_TYPE | BType))*)? '}' |
	'<' '{' ((VAR_TYPE | BType) (',' (VAR_TYPE | BType))*)? '}' '>';

/*
 * To summerize all BasicTypes inside one Rule.
 */
BType:
	INTEGER | F_POINT | BasicType | INT;

/*
 * To distinguish the types here only Basic Types
 */
BasicType:
	'void' | 'null' | 'label' | 'undef';

/*
 * To distinguish the types here only Floating Types
 */
F_POINT:
	'half' | 'float' | 'double' | 'x86_fp80' | 'fp128' | 'ppc_fp128';

/*
 * The 'getelementptr' instruction is used to get the address of a subelement of an aggregate data structure. 
 * It performs address calculation only and does not access memory.
 */
GetElementPtr:
	'getelementptr' 'inbounds'? pointer+=TypeAndValue (',' params+=TypeAndValue)*;

/*
 * The 'extractvalue' instruction extracts the value of a member field from an aggregate value.
 */
ExtractValue:
	'extractvalue' aggregate=Aggregate type=Type (',' index+=INT)+;

/*
 * The 'insertvalue' instruction inserts a value into a member field in an aggregate value.
 */
InsertValue:
	'insertvalue' aggregate=Aggregate type=Type ',' value=TypeAndValue (',' index+=INT)+;

/*
 * The 'fence' instruction is used to introduce happens-before edges between operations.
 */
Fence:
	'fence' 'singlethread'? ordering=ATOMIC_ORDERING;

/*
 * This is only a summarize of the possible atomic orderings
 */
ATOMIC_ORDERING:
	'unordered' | 'monotonic' | 'aquire' | 'release' | 'acq_rel' | 'seq_cst';

/*
 * The 'cmpxchg' instruction is used to atomically modify memory. It loads a value in memory and compares it to 
 * a given value. If they are equal, it stores a new value into the memory.
 */
CmpXchg:
	'cmpxchg' 'volatile'? adress=TypeAndValue ',' compare_val=TypeAndValue ',' new_val=TypeAndValue 'singlethread'?
	ordering=ATOMIC_ORDERING;

/*
 * The 'atomicrmw' instruction is used to atomically modify memory.
 */
AtomicRMW:
	'atomicrmw' 'volatile'? BIN_OP adress=TypeAndValue ',' value=TypeAndValue 'singlethread'? ordering=ATOMIC_ORDERING;

/*
 * This is only to summarize the different Binary Operations
 */
BIN_OP:
	'xchg' | 'add' | 'sub' | 'and' | 'nand' | 'or' | 'xor' | 'max' | 'min' | 'umax' | 'umin';

/*
 * The 'load' instruction is used to read from memory.
 */
Load:
	'load' 'volatile'? adress=TypeAndValue (',' align=ALIGNMENT)? (',' '!nontemporal' '!' index=INT)? |
	'load' 'atomic' 'volatile'? adress=TypeAndValue 'singlethread'? ordering=ATOMIC_ORDERING (',' 'align' index=INT)?;

/*
 * The 'store' instruction is used to write to memory.
 */
Store:
	'store' 'volatile'? value=TypeAndValue ',' adress=TypeAndValue (',' 'align' INT)? |
	'store' 'atomic' 'volatile'? value=TypeAndValue ',' adress=TypeAndValue 'singlethread'? ordering=ATOMIC_ORDERING (','
	'align' index=INT)?;

/*
 * The 'call' instruction represents a simple function call.
 */
Call:
	'tail'? 'call' CallingConv? RETURN_ATTRIBUTES? pointer=TypeAndValue plist=ParameterList FUNCTION_ATTRIBUTES?;

/*
 * This is to summarize the possible return attributes
 */
RETURN_ATTRIBUTES:
	'zeroext' | 'signext' | 'inreg' | 'byval' | 'sret' | 'noalias' | 'nocapture' | 'nest';

Alloc:
	'alloca' type=Type (',' numElements=TypeAndValue)? (',' ALIGNMENT)?;

/*
 * This is to summarize the possible Calling Conventions
 */
CallingConv:
	'ccc' | 'fastcc' | 'coldcc' | 'x86_stdcallcc' | 'x86_fastcallcc' | 'x86_thiscallcc' | 'arm_apcscc' |
	'arm_aapcscc' | 'arm_aapcs_vfpcc' | 'msp430_intrcc' | 'ptx_kernel' | 'ptx_device' | 'spir_func' | 'spir_kernel' |
	'cc' '<' INT '>' INT;

/*
 * This is to summarize the possible function attributes
 */
FUNCTION_ATTRIBUTES:
	'address_safety' | 'alignstack' '(' '<' INT '>' ')' | 'alwaysinline' | 'nonlazybind' | 'inlinehint' | 'naked' |
	'noimplicitfloat' |
	'noinline' |
	'noredzone' | 'noreturn' | 'nounwind' | 'optsize' | 'readnone' | 'readonly' | 'returns_twice' | 'ssp' | 'sspreq' |
	'uwtable';

/*
 * This rule creates a Parameterlist and saves also the TypeAndValue to each parameter
 * Brackets are 
 */
ParameterList:
	{ParameterList} '(' (params+=TypeAndValue (',' params+=TypeAndValue)*)? ')';
	
/*
 * The 'phi' instruction is used to implement the φ node in the SSA graph representing the function.
 */
PHI:
	'phi' Type '[' values+=ValuePair ']' (',' '[' values+=ValuePair ']')*;

/*
 * This rule is used to bring in more clarity in some instructions
 */
ValuePair:
	value1=Type ',' value2=Type;

/*
 * The 'landingpad' instruction is used by LLVM's exception handling system to specify that a basic 
 * block is a landing pad — one where the exception lands, and corresponds to the code found in the 
 * catch portion of a try/catch sequence. It defines values supplied by the personality function (pers_fn)
 * upon re-entry to the function. The resultval has the type resultty.
 */
LandingPad:
	'landingpad' type=Type 'personality' personality=TypeAndValue ('cleanup' clause+=Clause* | clause+=Clause+) |
	'landingpad' type=Type 'personality' personalitytype=Type personalityfunction=CAST_TYPE '(' value=Type '(...)*'
	VAR_TYPE 'to' castto=Type ')' ('cleanup' clause+=Clause* | clause+=Clause+);

/*
 * A clause begins with the clause type — catch or filter — and contains the global variable representing
 * the "type" that may be caught or filtered respectively. Unlike the catch clause, the filter clause takes
 * an array constant as its argument. Use "[0 x i8**] undef" for a filter which cannot throw. The 'landingpad'
 * instruction must contain at least one clause or the cleanup flag.
 */
Clause:
	'catch' TypeAndValue |
	'filter' filter+=TypeAndValue (',' filter+=TypeAndValue)*;

/*
 * The 'select' instruction is used to choose one value based on a condition, without branching.
 */
Select:
	'select' condition=TypeAndValue ',' val1=TypeAndValue ',' val2=TypeAndValue;

/*
 * The 'va_arg' instruction is used to access arguments passed through the "variable argument" area of a 
 * function call. It is used to implement the va_arg macro in C.
 */
VA_Arg:
	'va_arg' list=TypeAndValue ',' argType=Type;

/*
 * The 'extractelement' instruction extracts a single scalar element from a vector at a specified index.
 */
ExtractElement:
	'extractelement' vector=TypeAndValue ',' index=TypeAndValue;

/*
 * The 'insertelement' instruction inserts a scalar element into a vector at a specified index.
 */
InsertElement:
	'insertelement' vector=TypeAndValue ',' scalar=TypeAndValue ',' index=TypeAndValue;

/*
 * The 'shufflevector' instruction constructs a permutation of elements from two input vectors, 
 * returning a vector with the same element type as the input and length that is the same as the shuffle mask.
 */
ShuffleVector:
	'shufflevector' vector1=TypeAndValue ',' vector2=TypeAndValue ',' mask=TypeAndValue;

/*
 * This rule is to provide a typecast. Nothing special
 * Example
 *  %X = trunc i32 257 to i8
 *  %Z = fptosi float 1.04E+17 to i8
 */
Cast:
	CAST_TYPE value=TypeAndValue 'to' castto=Type;

/*
 * The instructions in this category are the conversion instructions (casting) which
 * all take a single operand and a type. They perform various bit conversions on the operand.
 */
CAST_TYPE:
	'trunc' | 'zext' | 'sext' | 'fptrunc' | 'fpext' | 'fptoui' | 'fptosi' | 'uitofp' | 'sitofp' | 'ptrtoint' | 'inttoptr'
	| 'bitcast';

/*
 * The 'icmp' instruction returns a boolean value or a vector of boolean values based on comparison of 
 * 		its two integer, integer vector, pointer, or pointer vector operands.
 * The 'fcmp' instruction returns a boolean value or vector of boolean values based on comparison of its operands.
 */
Compare:
	'icmp' I_PREDICATES Type ValuePair |
	'fcmp' F_PREDICATES Type ValuePair;

/*
 * This is to summarize the possible Integer Predicates
 */
I_PREDICATES:
	'eq' | 'ne' | 'ugt' | 'uge' | 'ult' | 'ule' | 'sgt' | 'sge' | 'slt' | 'sle';

/*
 * This is to summarize the possible Floating Predicates
 */
F_PREDICATES:
	'false' | 'oeq' | 'ogt' | 'oge' | 'olt' | 'ole' | 'one' | 'ord' |
	'ueq' | 'ugt' | 'uge' | 'ult' | 'ule' | 'une' | 'uno' | 'true';

/*
 * This is to summarize the possible Arithmetic Operations
 */
ARITHMETIC_OP:
	('add' | 'fadd' | 'sub' | 'fsub' | 'mul' | 'fmul' | 'udiv' | 'sdiv' | 'fdiv' | 'urem' | 'srem' | 'frem')
	Type ValuePair;

/*
 * This is to summarize the possible Logical Operations
 */
LOGICAL_OP:
	('shl' | 'lshr' | 'ashr' | 'and' | 'or' | 'xor')Type ValuePair;

/*
 * This is only to summarize all possible Instructions
 */
Instruction:
	Switch | IndirectBranch | Branch | Return | Load | Store | Fence | GetElementPtr | LOGICAL_OP | ARITHMETIC_OP | Compare |
	Cast | ShuffleVector | InsertElement | ExtractElement | Invoke | Resume | InsertValue | ExtractValue | Alloc |
	CmpXchg | AtomicRMW | PHI | Select | Call | VA_Arg | LandingPad | LocalVar | Unreachable;

/*
 * The 'indirectbr' instruction implements an indirect branch to a label within the current function, whose 
 * address is specified by "address". Address must be derived from a blockaddress constant.
 */
IndirectBranch:
	'indirectbr' adress=TypeAndValue ',' '[' (lList=LabelList)? ']';

/*
 * The Indirect Branch instruction needs a List of labels to jump to. 
 * This List is created here an contains Pairs of Types and Values
 */
LabelList:
	(labels+=TypeAndValue)+;

/*
 * The 'switch' instruction is used to transfer control flow to one of several different places. It is a generalization of 
 * the 'br' instruction, allowing a branch to occur to one of many possible destinations.
 */
Switch:
	'switch' value=TypeAndValue ',' default=TypeAndValue '[' (jTable=JumpTable)? ']';

/*
 * The Switch instruction needs a list of values and destination, that will be jumped in case of value occures
 */
JumpTable:
	(values+=TypeAndValue ',' destinations+=TypeAndValue)+;

/*
 * The 'invoke' instruction causes control to transfer to a specified function, with the possibility of 
 * control flow transfer to either the 'normal' label or the 'exception' label. If the callee function 
 * returns with the "ret" instruction, control flow will return to the "normal" label. If the callee 
 * (or any indirect callees) returns via the "resume" instruction or other exception handling mechanism, 
 * control is interrupted and continued at the dynamically nearest "exception" label.
 * 
 * The 'exception' label is a landing pad for the exception. As such, 'exception' label is required to
 *  have the "landingpad" instruction, which contains the information about the behavior of the program 
 * after unwinding happens, as its first non-PHI instruction. The restrictions on the "landingpad" 
 * instruction's tightly couples it to the "invoke" instruction, so that the important information contained 
 * within the "landingpad" instruction can't be lost through normal code motion.
 */
Invoke:
	'invoke' CallingConv? RETURN_ATTRIBUTES? function=TypeAndValue pList=ParameterList FUNCTION_ATTRIBUTES? 'to'
	to=TypeAndValue 'unwind' unwind=TypeAndValue;
	
/*
 * The 'resume' instruction is a terminator instruction that has no successors.
 */
Resume:
	'resume' TypeAndValue;
/*
 * The 'unreachable' instruction has no defined semantics. This instruction is used to inform the 
 * optimizer that a particular portion of the code is not reachable. This can be used to indicate 
 * that the code after a no-return function cannot be reached, and other facts.
 */
Unreachable:
	{Unreachable}'unreachable'
;

/*
 * The 'ret' instruction is used to return control flow (and optionally a value) 
 * from a function back to the caller.
 * 
 * There are two forms of the 'ret' instruction: one that returns a value and then 
 * causes control flow, and one that just causes control flow to occur.
 */
Return:
	{Return} 'ret' 'void' (',' '!dbg' '!' INT)? | 'ret' value=TypeAndValue (',' '!dbg' '!' INT)?;

/*
 * The 'br' instruction is used to cause control flow to transfer to a different basic block in 
 * the current function. There are two forms of this instruction, corresponding to a conditional 
 * branch and an unconditional branch.
 */
Branch:
	'br' destination=TypeAndValue | 'br' cond=TypeAndValue ',' labelTrue=TypeAndValue ',' labelFalse=TypeAndValue;

/* 
 * This rule is the start of the function body and has to be right after de 'define' of a function.
 * Every Functionbody contains at leaset one Basic Block. 
 */
FunctionBody:
	'{' blocks+=BasicBlock+ '}';

/*
 * Every Basic Block is contained inside a Functionbody and has a label and at least one instruction 
 */
BasicBlock:
	label=NOBRACKET ':'
	instructions+=Instruction+;

/*
 * This is to summarize the possible visibilities
 */
VISIBILITY:
	'default' | 'hidden' | 'protected';

/*
 * This is to summarize the possible linkages
 */
LINKAGE:
	'private' | 'linker_private' | 'linker_private_weak' | 'available_externally' | 'linkonce' | 'common' |
	'appending' | 'extern_weak' | 'linkonce_odr' | 'linkonce_odr_auto_hide' | 'dllimport' | 'dllexport' | ALIAS_LINKAGE;

/*
 * There are restriction on the Linkages of Aliasees. So...
 */
ALIAS_LINKAGE:
	'external' | 'internal' | 'weak' | 'weak_odr';

/*
 * This rule is needed to support Metadata
 * Example:
 *  ; Named metadata
 *	!1 = metadata !{i32 42}
 *	!foo = !{!1, null} 
 */
MetadataValue:
	(('!' INT )| ('!{' STRING '}') | ("!" STRING)) '=' (('!' INT) | ('!{' STRING '}') | ("!" STRING));

/*
 * This rule is to define the alignment
 */
ALIGNMENT:
	'align' INT //must be a power of 2
;